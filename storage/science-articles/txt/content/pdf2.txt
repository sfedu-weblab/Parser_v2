

В.В. Ерохин 
Х.М. Бахадиров 
 
 
 
 
 
 
 
 
ВЕРИФИКАЦИЯ ИНФОРМАЦИИ  
И ЗАЩИТА ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ  
В ИНФОРМАЦИОННО-ТЕЛЕКОММУНИКАЦИОННЫХ 
СИСТЕМАХ БАНКА 
 
 
 
Монография 
 
 
 
 
 
 
 
 
 
Москва 2021 

УДК 004.056.5:004.627 
ББК 32.972.53 
Е  78 
 
Авторы: 
доктор технических наук, доцент, профессор кафедры математических 
методов и бизнес-информатики Московского государственного  
института международных отношений (университета) МИД России 
Ерохин Виктор Викторович; 
магистрант направления «Бизнес-информатика»  
Московского государственного института международных отношений  
(университета) МИД России 
Бахадиров Хикмет Муратович 
 
Научный редактор: 
доктор технических наук 
Лагерев Александр Валерьевич 
 
Рецензенты: 
доктор технических наук 
Гольдфарб Вениамин Иосифович; 
доктор технических наук 
Лагерев Игорь Александрович 
 
  Ерохин В.В., Бахадиров Х.М. 
Е  78   Верификация информации и защита программного 
обеспечения в информационно-телекоммуникационных 
системах банка: Монография.– М.: Издательство «Спутник +», 2021. – 181 с. 
 
ISBN 978-5-9973-5919-5 
 
Излагаются основные аспекты и характеристики технологии защиты информации 
в банковских телекоммуникационных системах, а также подходы к анализу информационной безопасности банковских систем. Решаются задачи обеспечения информационной 
верификации информации в компьютерных и экономических системах банка. 
Монография предназначена для специалистов в области защиты компьютерных 
систем и студентов по направлениям подготовки  09.04.01  –  «Информатика и вычислительна
я техника»,  09.04.02  –  «Информационные системы и технологии»,  38.04.05  –  
«Бизнес-информатика». 
 
Ил. 49. Табл. 19. Библиогр. – 74 назв. 
 
УДК 004.056.5:004.627 
ББК 32.972.53 
 
Отпечатано с готового оригинал-макета. 
 
ISBN 978-5-9973-5919-5 © Ерохин В.В., Бахадиров Х.М., 2021 

3 
ВВЕДЕНИЕ 
 
 
В предлагаемой монографии излагаются основные принципы и 
положения формирования общих знаний в области безопасности экономических систем, в частности, коммерческих банков. 
Современные коммерческие банки всё чаще сталкиваются с 
проблемой нарушения параметров защиты информационного и программного обеспечения банка, связанной с несанкционированными 
действиями легальных пользователей  –  сотрудников банка. Ведущие 
коммерческие банки страны 
ставят задачи усовершенствования механизмов и технологий контроля работы с информационным и программным обеспечением. В настоящее время банки используют интегрированные информационные среды, технологии классов   CALS,   
ERP, MRP, SCADA, CAD/CAM/CAE, применение которых предполагает наличие высокого уровня защиты информационного и программного обеспечения. Существует ряд систем предотвращения несанкционированного использования информационного и программного 
обеспечения, но ни одна из них не обеспечивает комплексной 
защиты ресурсов банка. Необходимость обеспечения комплексной 
защиты информационных и программных ресурсов требует разработки единой, интегрированной в основную информационную среду 
банка, системы, основной задачей которой является предотвращение 
максимального количества видов «инсайдерских» атак. Сложность 
структуры информационного и программного обеспечения коммерческого банка определяет
 сложность структуры разрабатываемой автоматизированной системы разграничения доступа к информационному и программному обеспечению (АСРДкИПО). 
Большинство вычислительных систем, используемых для технических, инженерных, коммерческих, научных целей имеют сложную 
архитектуру. Будучи состоящими из множества взаимодействующих 
компонентов, современные вычислительные системы подвержены 
сбоям, причем сбои могут происходить как вследствие отказа оборудования, так 
и вследствие некорректной работы программного обеспечения. В этой связи, все большее значение и актуальность приобретают математические методы оценки влияния сбоев на работу компьютерных систем. Одним из подходов к рассматриваемым проблемам является вероятностный. 

4 
Проблема анализа качества аппаратного и программного обеспечения (ПО) становится сегодня все более острой, особенно по мере 
расширения использования в информационных банковских технологиях при разработке ПО. 
Экспоненциальный рост сложности аппаратного и программного обеспечения вычислительных процессов порождает повышенные 
требования к бездефектному проектированию. Известны примеры, 
как дорого обходятся ошибки, допущенные на
 различных этапах проектирования, поэтому все современные ИС обязательно снабжаются 
методологическими, программными и инструментальными средствами анализа разрабатываемого изделия на всех этапах автоматизированного проектирования. Не менее актуальными являются проблемы, 
связанные с обеспечением проектирования надежного ПО. Большой 
вклад в становление и развитие методов решения данной проблемы 
внесли отечественные ученые Пархоменко 
П.П., Липаев В.В., Согомонян Е.С., Майоров С.А., Немолочнов О.Ф., Рябов Г.Г., Селютин 
В.А., Курейчик В.М. и многие другие.  
В настоящее время сложилось несколько подходов к проверке 
правильности программного обеспечения (ПО): тестирование, теоретико-доказательный подход и верификация моделей программ.  
Наиболее распространённым методом
 является тестирование. 
При тестировании на вход программе подаются заранее приготовленные тестовые данные и проверяется соответствие результата, выданного программой, ожидаемому. Важным свойством, используемом 
при тестировании, является свойство детерминированности алгоритма. В случае распределённого ПО, использующего несколько процессов и выполняющегося на нескольких ЭВМ, поведение ПО становится существенно неоднозначным. 
В этом случае для проверки поведения ПО в ходе вычисления могут использоваться средства трассировки. 
Методы верификации направлены на доказательство утверждений о свойствах поведения ПО или результатов её работы. Этот подход к проверке правильности ПО был впервые предложен в работах 
А.А. Ляпунова, Т. Хоара, Э. Дейкстры, Пратта
 и Флойда. 
Методы верификации ПО, использующие теоретикодоказательный подход, основываются на средствах автоматического 
доказательства теорем (САДТ,  theorem  prover,  «прувер»). Описание 
ПО представляется в виде множества логических утверждений. Спецификация ПО также представляется в виде утверждения. САДТ 

5 
строит доказательство выполнимости спецификации, исходя из 
утверждений, описывающих проверяемое ПО. 
При использовании САДТ в процессе построения доказательства может потребоваться участие эксперта. Одной из наиболее трудных задач, возникающих при верификации ПО с помощью САДТ, является задача порождения инварианта цикла. Инвариант цикла требуется при проверке выводимости постусловия функции из
 предусловия.  
Верификация ПО с использованием логических утверждений, 
построенных непосредственно на основании исходных кодов ПО, 
увеличивает сложность процесса доказательства. Некоторые фрагменты кода могут быть несущественными для проверки выделенных 
свойств ПО. Свойства ПО могут быть проверены на модели ПО, более простой, чем исходное ПО. Группа методов, основанных на верификации моделей  (Model  Checking,  MC),  использует компромиссный подход между полноценной верификацией ПО и тестированием, 
использующим формальную проверку свойств. 
В области ЭВМ исследуются классы ИС, параметризованных по 
числу взаимодействующих компонентов:  
 распределённые алгоритмы: волновые алгоритмы, распределения ресурсов, взаимного исключения доступа к критической секции, 
избрания лидера     (leader     election),     обнаружения завершения 
(termination     detection),     согласованного принятия транзакции 
(distributed commit); 
 сетевые
 протоколы: кольцо с маркером, протоколы маршрутизации, протоколы обеспечения качества сервиса, широковещательные 
протоколы; 
 аппаратные схемы: аппаратные схемы управления доступом к 
шине при различном числе клиентских устройств, протоколы обеспечения когерентности кэшей. 
При построении модели распределённой ИС, которая может потенциально содержать любое количество однотипных процессов, 
ограничиваются моделью с небольшим, 
фиксированным числом процессов. Предполагается, что свойства, проверенные на модели с фиксированным числом процессов, автоматически масштабируются для 
моделей с большим числом процессов. Однако этот приём не является вполне корректным: известны примеры, когда спецификация была 
верна на модели с одним числом процессов и нарушалась при изменении числа процессов. 

6 
Это означает, что для верификации параметризованных моделей 
ПО недостаточно проверить спецификацию на нескольких моделях с 
фиксированным числом процессов: необходимо обоснование масштабируемости проверенной спецификации на остальные модели. 
Так как число процессов в моделях не ограничено, то спецификация 
должна быть проверена на бесконечном семействе моделей с конечным числом состояний.  
Наиболее перспективными
 методами, настраиваемыми на различные виды топологии параметризованных систем, являются методы, основанные на поиске инвариантов, и символьные методы. 
Символьные методы верификации параметризованных систем 
могут потребовать участия эксперта для переработки модели и указания дополнительных подсказок.  
Помимо верификации моделей с произвольным числом однотипных процессов алгоритмы решения задачи  PMC  позволяют проводить редукцию моделей с большим числом однотипных процессов 
к моделям с малым числом процессов. Решение задачи  PMC  имеет 
практический смысл даже тогда, когда рассматриваются модели с 
фиксированным, но очень большим числом процессов. В этом случае 
задача, требующая недоступных на практике вычислительных ресурсов, может быть сведена к практически решаемой задаче. 
Задача верификации
 параметризованных моделей распределённых ИС актуальна. Однако при разработке таких методов и средств 
необходимо сохранить основное преимущество метода  MC  –  свойство автоматической верификации модели. Необходимо, чтобы для 
верификации параметризованной модели не требовалась существенная перестройка модели, использованной при верификации средствами MC, или участие эксперта. 
В четвертой главе использовался формальный анализ для 
разработки и проверки платежных протоколов, но, несмотря на развитие 
семантики и выразительности, в литературе мало внимания уделялось 
аспектам автоматизации систем подтверждения платежей в банковской системе. Это исследование совершенствует платформу автоматизированного анализа для платежных протоколов. 
Усовершенствована комплексная и автономная система подтверждения, которая позволяет в платежных системах повысить кон
фиденциальность, целостность, аутентификацию, актуальность, подтверждение и неотказуемость. Моделируются общие примитивы безопасности, такие как шифрование, дешифрование, цифровые подпи
7 
си, дайджесты сообщений, коды аутентификации сообщений и сертификаты X.509. 
Представлен автоматизированный анализ реальных протоколов 
платежей по банковским картам, а также протоколов бесконтактных 
мобильных платежей. В некоторых протоколах обнаружены недостатки безопасности; рассматриваются их причины и последствия. 
По тематике настоящей монографии имеется достаточно обширная литература, однако в них недостаточно изложены вопросы
 
практического применения основных правил функционирования различных технологий безопасности информации в коммерческих банках. Это дает нам право предложить данную монографию в качестве 
ключевого систематизированного материала для более полного и достаточного изучения экономической безопасности в области технологий обработки информации коммерческим банком. 
 
 
  

8 
1. АНАЛИЗ АВТОМАТИЗИРОВАННЫХ МЕТОДОВ 
ПОСТРОЕНИЯ УПРАВЛЕНИЯ ДОСТУПОМ К 
ИНФОРМАЦИОННОМУ И ПРОГРАММНОМУ 
ОБЕСПЕЧЕНИЮ БАНКА 
 
 
На сегодняшний день существует множество систем защиты 
информационного и программного обеспечения от внутренних угроз. 
Одной из наиболее популярных технологий является технология  IPC  
(Information Protection and Control). Основные функции, выполняемые 
технологией IPC: 
- предотвращение различных видов утечек информационных ресурсов; 
- защита информационных и программных ресурсов от внутренних угроз; 
- предупреждение промышленного шпионажа. 
К информационным ресурсам банка 
относятся: 
- данные банка о разработках, проектах; 
- персональные данные сотрудников банка. 
К данным банка о проектах можно отнести: 
- технические задания; 
- программные коды разработок; 
- проектно-конструкторскую документацию; 
- сопровождающую документацию; 
- экономические характеристики проектов. 
К персональным данным сотрудников банка относятся: 
- номера паспортов; 
- номера документов, заверяющих личность; 
- номера страховок; 
- номера 
кредитных и дебетовых банковских карт. 
Разрабатываемая автоматизированная система разграничения 
доступа к информационному и программному обеспечению (далее 
АСРДкИПО) имеет сложную структуру, так как должна решать не 
только проблему утечки информационных ресурсов за пределы программного обеспечения банка. Основными объектами защиты, проектируемой АСРДкИПО являются: 
- информационные ресурсы банка, потеря или несанкционированное 
изменение которых влечѐт за собой ущерб, потерю репутации 
банка; 

9 
- процессы обработки информационных и программных ресурсов. Примером процессов обработки могут служить хранение, исполнение (запуск), передача, отображение, изменение, вычислительная 
обработка, утилизация; 
- программное обеспечение банка; 
- информационная архитектура, представляющая собой структурированную совокупность автоматизированных систем и технологий 
банка. 
Информационная среда банка является распределенной структурой, объединяющей информационные подсистемы банка в 
единую 
интегрированную автоматизированную компьютерную систему банка, осуществляющую обработку, хранение и преобразование данных. 
К основным особенностям информационной среды банка относятся: 
- хранение информационных ресурсов в единых хранилищах 
(северах, банках данных, «серверных фермах» и т.д.); 
- многофункциональность и широкий круг применения программного и информационного обеспечения банка; 
- возрастание ответственности принимаемых решений
, возложенной на программное обеспечение банка; 
- функциональное разнообразие выполняемых задач программного обеспечения банка; 
- высокий показатель нагрузки внутреннего информационного 
трафика (особенно это касается файлов банковской документации, 
графических файлов); 
- применение особых технологий обработки графических файлов; 
- недопустимость возникновения перебоев работы ПО банка, 
особенно при применении систем реального времени; 
- многообразие
 пользователей ПО банка – сотрудников банка; 
- объединение большого количества информационного, программного и аппаратного обеспечения в единую интегрированную 
информационную систему. 
С учѐтом перечисленного ужесточаются требования к соблюдению норм и правил работы с информационным и программным обеспечением коммерческого банка. К субъектам защиты АСРДкИПО относятся: 
- юридические и физические лица, 
задействованные в обеспечении выполнения банком своих функций (разработчики, консультан
10 
ты, сторонние организации, привлекаемые для оказания услуг, обслуживающий персонал и т.д.); 
- сотрудники структурных подразделений банка; 
- подразделения банка; 
- руководство банка; 
- банк в целом; 
- представители третьей стороны. 
Перечисленные субъекты заинтересованы в обеспечении: 
- целостности информационных ресурсов ПО банка; 
- полезности информационных ресурсов ПО банка; 
- достоверности информационных ресурсов ПО банка
; 
- конфиденциальности информационных ресурсов ПО банка; 
- доступности информационных ресурсов ПО банка; 
- защиты информационных ресурсов ПО банка от несанкционированного копирования, распространения, тиражирования; 
- защиты программных ресурсов банка от некомпетентного и 
некорректного использования (как специально, так и по неосторожности); 
- разграничения ответственности за нарушения и отклонения от 
правил работы с информационными
 и программными ресурсами банка; 
- возможности мониторинга работы с информационными и программными ресурсами банка, определения причин инцидентов нарушения их защиты. 
Основной целью проектируемой АСРДкИПО является защита 
перечисленных объектов от возможного нанесения им физического, 
материального, морального или иного ущерба. Указанная цель должна достигаться посредством обеспечения и постоянного поддержания
 
следующих свойств информационных ресурсов банка: 
- конфиденциальность – сохранение в секрете информационных 
ресурсов, находящихся внутри ПО банка; 
- целостность – сохранение свойств и полноты информационных 
ресурсов, находящихся внутри ПО банка; 
- доступность информационных ресурсов для легальных пользователей  –  нахождение ПО банка в таком состоянии, при котором 
санкционированные пользователи (сотрудники банка) могли обращаться и
 работать с запрашиваемыми информационным и программными ресурсами банка. 

11 
К качеству информационных ресурсов, предоставляемых сотрудникам банка, предъявляются определенные требования, прежде 
всего требования о том, чтобы они были полезными. Для того чтобы 
информационные ресурсы банка обладали перечисленными свойствами, необходима разработка методики защиты информационных и 
программных ресурсов банка. Методика защиты информационных и 
программных ресурсов банка должна включать в себя следующие
 аспекты: 
- применение принципа предоставления сотруднику минимального количества разрешенных программ, специального программного 
обеспечения для работы с журналами безопасности (для сотрудников 
отдела информационной безопасности банка), оперативного контроля 
состояния автоматизированных рабочих мест сотрудников; 
- обеспечение комплексного использования средств защиты информационных и программных ресурсов банка; 
- централизованное управление потоками информации в банке
; 
- централизованное управление учѐтными записями сотрудников 
банка, зарегистрированных в ПО банка, их правами доступа к информационным массивам; 
- комплексное использование средств защиты от утечки информационных ресурсов по техническим каналам. 
Для обеспечения доходности, ликвидности, конкурентоспособности, сохранения репутации банка информационные ресурсы ПО 
банка должны обладать всеми перечисленными свойствами. В соответствии с изложенными аспектами, в АСРДкИПО предполагается 
использовать средства защиты информационного и программного 
обеспечения банка: 
- централизованное управление параметрами операционных систем, установленных на рабочих станциях сотрудников банка; 
- централизованное управление учѐтными записями сотрудников 
банка – пользователей ПО банка; 
- применение современных методов идентификации, аутентификации и авторизации сотрудников банка при работе с 
информационным и программным обеспечением банка; 
- применение методов шифрования; 
- использование только зарегистрированных, прошедших контроль на наличие закладок и вирусов, устройств и внешних носителей; 

12 
- использование лицензированного, прошедшего специальный 
контроль программного и аппаратного обеспечения; 
- использование только сертифицированных средств защиты 
информации; 
- применение методики однонаправленной передачи информации от удаленных подсистем, между контурами различных грифов 
секретности, а также с автоматизированных рабочих мест ввода данных, при обращении к базе данных инцидентов нарушения защиты 
информационного и программного 
обеспечения банка; 
- защита от несанкционированного физического доступа к серверам, хранилищам информации, «серверным фермам»; 
- проведение специальных проверок технических средств банка; 
- проведение специальных проверок аппаратного обеспечения 
банка; 
- проведение специальных проверок программного обеспечения 
банка; 
- проведение специальных исследований технических средств 
банка; 
- проведение специальных исследований помещений; 
- проведение специальных исследований программного обеспечения банка; 
- проведение специальных исследований аппаратного обеспечения банка; 
- применение механизма сигнализации  –  события несанкционированного доступа на автоматизированных рабочих местах сотрудников – отслеживание и оповещение сотрудников отдела информационной безопасности банка. Также должна существовать возможность 
информирования не только сотрудников отдела безопасности банка, 
но и непосредственно руководства. Важно отметить, что события
 несанкционированного доступа также заносятся в базу данных инцидентов нарушения правил работы с информационным и программным обеспечением банка; 
- применение методики «замкнутой программной среды»  –  для 
каждого сотрудника банка  –  пользователя ПО банка  –  формируется 
определенный перечень программ, разрешенных только ему для запуска. Перечень может быть задан как индивидуально для каждого
 
пользователя, так и определен на уровне групп пользователей. Применение данного режима необходимо для исключения попыток заражения вирусами,  «червями», для предотвращения промышленного 

13 
шпионажа, а также применения нелицензированного программного 
обеспечения. 
Информация в коммерческом банке может существовать в различных формах: 
- в бумажной форме; 
- в электронном виде; 
- устно. 
В электронном виде информация может передаваться как в локально-вычислительной сети (ЛВС), так и в глобальной вычислительной сети (ГВС). Безотносительно формы выражения информационных ресурсов, средств их распространения или хранения они 
должны всегда быть защищены. В банке большая часть информационных ресурсов хранится в электронном виде. Это, в первую очередь, 
связано с повсеместным внедрением: 
- электронного документооборота; 
- интеграционных средств поддержки; 
- единых сред обработки большого количества информации; 
- технологии непрерывной информационной поддержки поставок и
 жизненного цикла изделий CALS; 
- технологии планирования ресурсов банка ERP; 
- технологии управления и сбора данных систем реального времени SCADA; 
- технологии проектирования CAD/CAM/CAE; 
- применение дополнительных вспомогательных программных 
модулей и комплексов. 
При проектировании специального программного обеспечения 
(ПО), используемого сотрудниками банка при выполнении своих 
должностных обязанностей, должны учитываться требования методики защиты ПО банка. Примером
 такого специального ПО являются 
среды программирования: 
- Oracle JDevelope; 
- Microsoft Visual Studio; 
- Embarcadero RAD Studio; 
и среды проектирования: 
- AutoCAD; 
- ProEngineer; 
- T-Flex; 
редакторы-верификаторы G-кода: 
- NCManager; 

14 
- CIMCO Edit; 
- cgtech VERICUT; 
текстовые редакторы: 
- Microsoft Word; 
- TEX. 
Определение требований согласно методике обеспечения защиты информационного и программного обеспечения банка включает в 
себя: 
 оценку рисков безопасности функционирования ПО банка. В 
рамках оценки рисков необходимо произведение подсчѐта возможных угроз нарушения защиты ПО банка, планирование комплекса 
мероприятий по их предотвращению; 
 приведение к соответствию требованиям 
нормативных документов ключевых параметров АСРДкИПО; 
 формирование специального набора норм, законов, целей и 
требований, разработанных банком в отношении работы с информационными и программными ресурсами банка. 
Решения о расходах на мероприятия по защите информационного и программного обеспечения банка должны приниматься, исходя и 
из возможного ущерба, нанесенного банку в результате
 нарушений 
параметров защиты систем. Оценки рисков могут проводиться как 
для ПО банка в целом, так и для отдельных составляющих модулей. 
Оценка риска  –  это систематический анализ следующих вероятностей: 
- возникновения угрозы; 
- возникновения инцидента нарушения правил работы с информационными и программными ресурсами банка – реализации угрозы; 
- возникновение последствий инцидента. 
Оценка рисков
 должна производиться с использованием принципов системности и комплексности: для банка должны быть выявлены возможные источники угроз, предоставлены подробные отчѐты 
о проведенном анализе. В ходе анализа необходимо учитывать: 
- технический прогресс; 
- возможные изменение направления деятельности банка; 
- возможные изменение приоритетов деятельности банка; 
- появление новых видов уязвимостей ПО банка; 
- появление
 новых видов угроз. 
После анализа рисков необходима разработка комплекса мероприятий для обеспечения требуемого уровня защиты. При выборе 

15 
мероприятий следует придерживаться принципа, что стоимость их 
проведения не должна превышать ценности защищаемых ресурсов 
ПО банка. Ценность информационных ресурсов составляют их актуальность и полезность. Ценность программных ресурсов составляет 
их функциональность и полезность. Также следует принимать во 
внимание факторы, которые не могут быть представлены в денежном 
выражении, например, потерю репутации. Ключевыми
 мерами контроля с точки зрения законодательства Российской Федерации являются: 
- обеспечение конфиденциальности персональных данных сотрудников банка; 
- защита учѐтных данных банка; 
- защита прав на интеллектуальную собственность. 
Типами доступа, которые следует рассматривать согласно ГОСТ 
Р ИСО/МЭК 17799-2005, являются: 
- физический  –  к помещениям, компьютерным комнатам, серверным; 
- логический – к базам
 данных, информационным системам банка. 
В соответствии с системой классификации информационных ресурсов банка, принятой в банке, необходимо проведение процедур их 
маркировки. Процедуры маркировки должны осуществляться для 
информационных ресурсов как в электронной, так и в бумажной 
форме. В рамках работы рассматривается маркировка информационных ресурсов в электронном виде. При проведении 
маркировки следует учитывать процессы обработки информационных ресурсов (хранение, копирование, утилизация, передача и т.д.). Маркирование информационных ресурсов также необходимо для последующего проведения процедуры авторизации сотрудников банка. 
Технология  Information  Protection  and  Control  (IPC)  является 
технологией защиты информационных ресурсов от внутренних угроз. 
Решения класса IPC предназначены для защиты информационных ресурсов от внутренних угроз, предотвращения
 различных видов утечек 
информационных ресурсов, промышленного шпионажа и разведки. 
Задача технологии IPC – предотвращение передачи информационных 
ресурсов за пределы периметра основной информационной системы. 
Технология IPC соединяет в себе три основных принципа: 
- мониторинг технических каналов связи с помощью технологии 
Data Loss Prevention (DLP); 

16 
- контроль доступа к сети, приложениям и данным; 
- шифрование носителей информации. 
В ходе работы систем IPC широко используется детектирование 
информационного контента. Детектирование информационного контента может происходить с помощью следующих методов: 
- метод ручного детектирования («Карантин»); 
- метод «цифровых отпечатков»; 
- метод сигнатур; 
- метод, основанных на проставлении меток; 
- метод лингвистического анализа; 
- метод
, основанный на «регулярных выражениях». 
Метод ручного детектирования («Карантин») основан на применении ручной проверки. При обращении сотрудника к файлам, содержащим конфиденциальные данные, производится информирования сотрудников отдела информационной безопасности банка, которые принимают решение о дальнейших действиях: предоставлении 
сотруднику запрашиваемых данных или отказе в доступе. 
Достоинством метода является его 
эффективность. Недостатком 
является тот факт, что данный метод практически не реализуем в 
крупных банках, т.к. требует привлечения больших человеческих ресурсов (для формирования штата сотрудников отдела безопасности). 
Метод «карантин» можно применять с другими методами для анализа 
данных выбранных «подозрительных» сотрудников. При использовании метода «цифровых отпечатков»   (англ.   «Digital   Fingerprints»)   
формируется база данных
 образцов (паттернов, шаблонов) конфиденциальных файлов. В начале работы создается файл-шаблон и передается  DLP-системе, далее формируется отпечаток и передается в специальную базу данных так называемых «паттернов». Затем в правилах фильтрации контента файлов настраивается процентное соответствие шаблону из базы. Достоинством метода является тот факт, что 
система 
фильтрации информационного трафика, основанная на данном методе, способна работать с информацией любого формата. Также достоинствами системы на основе технологии «цифровых отпечатков» являются: 
- прозрачность работы алгоритма для сотрудников отдела информационной безопасности; 
- высокая степень детектирования инцидентов нарушения правил работы с информационным обеспечением; 
- простота добавления новых файловшаблонов (паттернов). 

17 
Недостатками метода являются: 
- чувствительность к изменениям файлов-шаблонов; 
- требование обеспечения дополнительной защиты базы данных 
паттернов (особое расположение серверов, формирование правил и 
настройка допуска сотрудников к базе); 
- снижение эффективности детектирования при переполнении 
базы данных паттернов, что на практике происходит довольно часто; 
- высокая степень влияния на производительность основной информационной системы
 банка; 
- низкая эффективность метода при работе с графическими файлами. 
В крупных банках данную технологию трудно реализовать, так 
как база данных файлов-шаблонов увеличивается слишком быстро, 
что повышает нагрузку на сервера  DLP-системы, кроме того постоянно приходится сталкиваться с проблемой заполнения базы данных, 
распределения нагрузки. Метод сигнатур представляет собой поиск
 в 
информационном потоке определенных символьных последовательностей, так называемых «стоп-выражений» запрещенных последовательностей символов. Метод относится к «детерминистским», т.к. алгоритм метода настроен на поиск   100   %   совпадения «стопвыражения». Большинство сигнатурных систем предназначены для 
поиска нескольких слов и частоту их встречаемости. Достоинства метода сигнатур: 
- очевидность принципа работы; 
- 
простота реализации и настройки. 
Недостатками метода являются: 
- чувствительность к специальной замене некоторых символов 
(например, на похожие символы из другого алфавита); 
- неэффективность метода при работе с файлами программного 
кода; 
- неприменимость метода к графическим файлам; 
- зависимость функционирования от языка (как естественного, 
так искусственного). 
DLP-системы, основанные на методе сигнатур хорошо «приспо
соблены» для западного рынка, но практически не пригодны в России. Причина  –  русский язык несигнатурен: в нѐм много приставок, 
суффиксов и окончаний. Метод «меток» заключается в расстановке 
специальных «меток» внутри файлов конфиденциальной информации. Достоинства метода: 

18 
- высокая эффективность детектирования; 
- точность предоставляемой информации; 
- высокое быстродействие. 
Недостатки метода: 
- сложность реализации  -  данный метод требует изменение 
структуры всей основной информационной системы банка; 
- требование выполнения дополнительных настроек при формировании нового файла конфиденциальной информации. 
Лингвистические методы являются самыми распространенными 
в применении в DLP-системах, т.к. предоставляют гибкий аппарат детектирования информационного контента. Лингвистический анализ 
текста включает в себя несколько методов детектирования: 
- синтаксический анализ; 
- семантический анализ; 
- морфологический анализ и т.д. 
Применение перечисленных методов анализа увеличивает эффективность DLP-системы. Недостатки лингвистических методов: 
- чувствительность к переформированию предложений; 
- неэффективность метода к файлам программного кода; 
- неприменимость метода для графических файлов; 
- 
зависимость от языка информационного контента. 
Метод «регулярных выражений»  (метод «текстовых идентификаторов») применяется в  DLP-системах недавно. Регулярные выражения позволяют находить совпадения по типу данных (их форме 
представления). Основное отличие от метода «сигнатур» является 
особенность поиска: не по значению, а по типу данных. Таким образом, производится поиск целого блока идентичной
 информации. Подобный метод эффективен для поиска: 
- обозначений изделий; 
- дат; 
- адресов (MAC, IP, интернет-сервисов); 
- номеров портов; 
- номеров кредитных карт; 
- номеров счетов; 
- номеров паспортов; 
- классификаторов и т.д. 
Достоинства метода: 
- высокая эффективность; 
- высокий уровень быстродействия; 

19 
- способность детектировать специфичный для каждого банка 
тип контента; 
- применимость метода для работы с графическими файлами. 
Часто метод «регулярных выражений» применяется в качестве 
дополнительного алгоритма в  DLP-системе, но не в качестве основного. Следует отметить, что вышеперечисленные методы, применяемые в современных системах  DLP,  работают с открытыми данными. 
Если злоумышленник в лице
 сотрудника банка, превышающего 
должностные обязанности и нарушающего правила работы с информационными ресурсами банка, попытается передать конфиденциальную информацию в зашифрованном виде, современные DLP-системы 
не смогут предотвратить утечку. В проектируемой АСРДкИПО 
предусмотрено решение данной проблемы путѐм добавления специального модуля, в ядро которого включены криптоаналитические методы. 
Следует уделить особое 
внимание модулю мониторинга информационного трафика банка (как внутреннего, так и внешнего) разрабатываемой АСРДкИПО, а именно, работе с зашифрованными данными. Также следует отметить, что большую часть информационного 
контента банка составляют графические файлы. Большинство методов детектирования не предназначены для работы с такими файлами. 
Злоумышленник может воспользоваться данным недостатком и
 передать конфиденциальные информационные ресурсы,  «зашив» их в 
графические файлы с помощью методов стеганографии, кроме того, 
сами графические файлы представляют собой конфиденциальные 
информационные ресурсы. 
Важно предусмотреть мероприятия по управлению защитой информационного и программного обеспечения банка, необходимые 
для управления доступом к средствам обработки информационных 
ресурсов третьей стороной. Все требования безопасности, 
связанные 
с доступом третьей стороны или мероприятиями по управлению защитой ПО банка, следует отражать в контракте с третьей стороной. 
Например, если существует специальная потребность в обеспечении 
конфиденциальности информационных ресурсов, следует заключить 
соглашение о их неразглашении. Недопустимо предоставлять третьей 
стороне доступ к информационным ресурсам и средствам их обработки до тех
 пор, пока не установлены соответствующие мероприятия по управлению защитой и не подписан контракт, определяющий 
условия предоставления информационных и программных ресурсов 

20 
банка. Распределение уровней доступа, предоставляемых сотрудникам банка, лицам третьей стороны, представлен на рис.  1.  Согласно 
рис. 1, субъектам информационных отношений может быть присвоен 
уровень доступа к объектам информационных отношений. Управление присвоением соответствующего уровня доступа обеспечивается 
разрабатываемой АСРДкИПО. 
 
 
Рис. 1. Распределение уровней доступа для сотрудников банка и 
представителей «третьей стороны» 
 
Для обеспечения
 должного уровня защиты информационного и 
программного обеспечения банка необходимо проведение надлежащего контроля запросов сотрудников банка к соответствующим ресурсам. Одной из важных задач АСРДкИПО является контроль запросов сотрудников банка к информационным и программным ресурсам банка. Так как запросы пользователей могут быть адресованы 
как в Интернет, так и 
в сеть серверов данных банка с одного и того 
же автоматизированного рабочего места (АРМ), может произойти 
утечка информационных ресурсов. С целью предотвращения утечки 

21 
секретных данных в разрабатываемой автоматизированной системе 
должен быть модуль контроля запросов сотрудников банка к информационным ресурсам (МКЗСПкИР). МКЗСПкИР должен производить 
мониторинг запросов пользователей к информационным ресурсам 
банка и отправлять соответствующие отчѐты в модули аудита, сотрудникам отдела информационной безопасности банка, руководству 
в случае необходимости. МКЗСПкИР в качестве основных механизмов
 должен использовать, в первую очередь, методы детектирования 
информационного контента. Доступ к информационным и программным ресурсам в банке должен быть регламентирован. По установленному регламенту все информационные массивы банка разделяются на 
группы (грифы) секретности с помощью специальных меток. Каждой 
такой группе соответствует список лиц, допущенных к работе с ней. 
Цель 
системы класса DLP – предотвращение утечки стратегически важных информационных ресурсов банка за пределы основной 
информационной системы – определяет ее архитектуру. Архитектура 
DLP-системы представлена на рис. 2. 
DLP  –система включает в себя подсистему контроля и мониторинга информационного контента и подсистему реагирования на инциденты нарушения параметров защиты ПО банка. Подсистема контроля и мониторинга
 информационного контента включает в себя 
контроль доступа к данным, к сети, к приложениям, шифрование информации, детектирование информационного контента. 
Подсистема реагирования на инциденты включает настройку 
правил и условий срабатывания сигнала-оповещения (alarm) и самого 
модуля оповещение сотрудников службы безопасности и руководства 
банка. 
Настройка подсистемы мониторинга информационного контента 
осуществляется сотрудниками службы информационной 
безопасности банка. Настройка подсистемы реагирования на инциденты производится сотрудниками службы безопасности банка с непосредственным контролем руководящего состава банка. Важно отметить, что в 
условиях совершенствования методов осуществления угроз снижения 
уровня защиты основной информационной системы, в качестве которой в работе рассматривается ПО банка, необходимо учитывать: 
- возможность совершенствования DLP-системы; 
- возможность модификации основных составляющих; 
- возможность добавление компонентов. 
 

22 
 
Рис. 2. Архитектура DLP-системы 
 
Инфраструктура DLP-системы представлена на рис. 3. 
Условные обозначения: 
- АРМ П – автоматизированное рабочее место пользователя (сотрудника банка); 
- АРМ А  –  автоматизированное рабочее место (АРМ) администратора (сотрудника отдела безопасности банка); 
- АРМ Р – АРМ руководящего состава банка; 
- синяя стрелка – запрос к данным; 
- красная стрелка – осуществление контроля; 
- зелѐная
 стрелка – оповещение; 
- зелѐная пунктирная стрелка  –  «скрытое»  (прозрачное для всех 
сотрудников банка) оповещение. Передача информации происходит 
от одного модуля (программного или аппаратного обеспечения) к 
другому автоматически (без участия сотрудников банка). 

23 
 
Рис. 3. Инфраструктура DLP-системы 
 
Согласно рис. 3, пользователь (сотрудник банка) может обращаться к информационным ресурсам банка, физически расположенной во внутренней распределѐнной сети банка, а также обращаться за 
необходимой информацией в Интернет. Кроме того, сотрудник может 
обращаться к приложениям и сервисам (программному обеспечению) 
банка и ГВС. Таким образом, формируются два основных 
информационных потока запросов, над которыми необходимо осуществлять 
контроль со стороны АСРДкИПО. 
На рис.   4   представлены взаимодействия основных структур 
DLP-системы. В состав  DLP-системы входят три основных компонента: 

24 
- рабочие станции сотрудников банка (автоматизированные места сотрудников банка, администраторов и руководящего состава 
банка); 
- контролирующие структуры (модули); 
- данные (Интернет, файлы локальной сети банка, база данных 
инцидентов нарушений правил работы с информационным и программным обеспечением банка). Сотрудники банка производят обращение к данным (в Интернет, в локальной сети банка, 
к базе данных 
инцидентов безопасности банка). 
 
 
Рис. 4. Взаимодействие основных структур DLP-системы 
 
 

25 
Условные обозначения к рис. 4: 
- фигурная стрелка  –  запрос данных, обращение к модулю оповещения; 
- чѐрная стрелка  –  действия модуля оповещения (информирование сотрудников отдела безопасности и руководства, запись в базу 
данных инцидентов нарушения правил работы с информационным и 
программным обеспечением банка); 
- красная стрелка  –  обращение сотрудников отдела информационной безопасности и руководства 
к базе данных инцидентов банка и 
получение ответа. Затем сотрудник получает доступ к запрашиваемым информационным ресурсам. 
В табл.  1  приведена информация о  DLP-системах от основных 
поставщиков IPC-продуктов на российском рынке: 
- Simantec Data Loss Prevention; 
- InfoWatch Traffic Monitor; 
- McAfee Host Data Loss Prevention; 
- Websence Data Security Suite. 
Изложенные в предыдущем пункте характеристики информационных систем класса   DLP   можно привести к восьми основным 
(рис. 5): 
- гибкость; 
- способность к
 адаптации; 
- способность к интеграции; 
- производительность детектирования ошибок I рода; 
- производительность детектирования ошибок II рода; 
- масштабируемость; 
- скорость анализа сетевого трафика; 
- прозрачность работы. 
Из рис.  5  видно, что лучшей системой класса  DLP  по перечисленным критериям является  Simantec  DLP.  Существует только один 
критерий, по которому она уступает отечественной разработке 
InfoWatch  Traffic  Monitor  –  способность к интеграции. Это, прежде 
всего
, связано с особенностями предпочтения использования программных продуктов почты и т.д.) на российском рынке. 
 
 
 
 
 

26 
Таблица 1 
Сравнение основных DLP-систем 
 

27 
 

28 
 

29 
 

30 
 

31 
 

32 
 

33 
 
 
 
Рис. 5. Сравнительная диаграмма основных характеристик систем 
класса DLP 
 
Надежность и точность идентификации стратегически важных 
информационных ресурсов в информационных потоках банка с по
34 
мощью технологии лингвистического анализа зависят от принципа 
формирования БКФ, на основе которой осуществляется анализ. Поэтому важно создать базу, которая обеспечит надежные результаты 
фильтрации информационного контента по категориям. Основным 
методом лингвистического анализа с помощью БКФ является поиск в 
анализируемом фрагменте информации слов и словосочетаний, описывающих стратегически важные данные и структурированных
 по 
категориям групп слов. 
 
 
1.1. Управления доступом к информационному и 
программному обеспечению в коммерческом банке 
 
 
Управление доступом (access control) – это процесс проверки запросов на доступ к сервису с целью определить разрешить или запретить доступ. Большая часть современных систем использует модель 
управления доступом, предложенную Лампсоном в 1974 г (рис. 6). 
 
 
Рис. 6. Модель управления доступом (Лампсон, 1974) 
 
Модель Лампсона включает следующие элементы: 
- Principal – автор запроса (принципал, иногда называют субъектом). 
-  Object  –  ресурс, информационный, сетевой или вычислительный. 
- Request – запрос на выполнение операции с объектом. 
-  Reference  Monitor  –  диспетчер доступа, проверяющий все запросы к объекту и принимающий решение о разрешении или запрещении доступа. 
Диспетчер доступа для принятия решения проводит три процедуры защиты информации. Определение источника запроса называется идентификацией, подтверждение подлинности 
источника назы
35 
вается аутентификацией, анализ правил разграничения доступа называется авторизацией. 
Наиболее полную интероперабельность интегрируемых систем 
обеспечивает семантическая интеграция. Интеграционные решения, 
использующие синтаксический и структурный подход, являются 
частными, рассчитанными на определенные системы. Широкое применение таких решений затруднено. 
В настоящее время наиболее популярной технологией семантической интеграции являются онтологии. Онтологии определяют общий
 словарь предметной области, который может совместно использоваться людьми или информационными системами. Для разработки 
онтологий существует широкий набор инструментальных средств: 
язык описания онтологий OWL (Web Ontology Language), являющийся стандартом   W3C,   среды редактирования онтологий   Protégé,   
Ontolingua,  Chimaera,  готовые и доступные к использованию онтологии, описывающие различные предметные области. 
Выявлены аналоги трех типов: системы централизованного 
управления, системы федеративной идентификации
, системы интегрированного управления. Оценка наиболее близких аналогов приведена в табл. 2. 
 
Таблица 2 
Оценка существующих систем интеграции управления доступом 
 

36 
 
 
Оценка наиболее близких онтологий с точки зрения возможности применения для интеграции управления доступом к сервисам 
разных типов приведена в табл. 3. 
 
Таблица 3 
Оценка онтологий в предметной области управления доступом 
 
 
Схема прототипа и существующее решение в «Газпромбанке» 
приведена на рис. 7. 
Основным недостатком прототипа является низкая интероперабельность, вызванная использованием 
структурной интеграции. Для 
увеличения интероперабельности предлагается использовать семантическую интеграцию: разработать семантическую модель в виде онтологии, ввести блок согласования семантики в адаптеры сервисов, 

37 
модифицировать схему данных и блоки хранения правил разграничения доступа, ПО управления доступом и консоль управления доступом. 
 
 
Рис. 7. Процесс доступа к информации в «Газпромбанке» 
 
Используется методика интеграции управления доступом к сервисам разных типов на основе семантического подхода. Методика заключается в выполнении следующих шагов: 
1. Задать множество сервисов 
S, которые подлежат интеграции. 

38 
2. Задать множество моделей М, используемых для управления 
доступом к сервисам из множества 
S. 
3. Задать множество репозиториев правил разграничения доступа 
R, которые подлежат интеграции. 
4. Задать множество протоколов управления доступом 
P, которые используются сервисами из множества 
S. 
5. Разработать унифицированную модель управления доступом 
M
0
. Модель включает семантическое описание базовых понятий и 
операций систем управления доступом (представленное в виде онтологии) и синтаксис записи правил разграничения доступа с использованием данной семантики. 
6. Определить отображение моделей управления доступом 
m
i
M 
в унифицированную модель 
М
0
: F:m
i
M
0
|m
i
M. 
7. Создать консолидированный репозиторий правил разграничения доступа 
R
0
, использующий унифицированную модель M
0
. 
8. Разработать адаптеры 
AR, обеспечивающие перенос данных 
из репозиториев 
r
i
R в консолидированный репозиторий R
0
. 
9. Создать программное обеспечение управления доступом, реализующее процедуры защиты информации с использованием правил 
разграничения доступа в консолидированном репозитории 
R
0
. 
10. Разработать адаптеры 
AS протоколов управления доступом 
p
i
P, обеспечивающие взаимодействие сервисов s
i
S с ПО управления доступом, для выполнения процедур защиты информации с использованием протокола 
p
i
P. 
11. Настроить сервисы 
s
i
S для взаимодействия с ПО управления доступом с помощью адаптеров 
a
i
AS по протоколам p
i
P. 
12. Разработать консоль управления правилами разграничения 
доступа в консолидированном репозитории 
R
0
. 
Структурная схема системы семантической интеграции управления доступом к сервисам разных типов, получаемой с помощью 
предлагаемой методики, показана на рис. 8. 
Особенность предлагаемого метода интеграции управления доступом к сервисам разных типов заключается в применении семантического подхода к интеграции, обеспечивающее большую интероперабельность, по сравнению с используемыми в настоящее время 
синтаксическим и структурным подходами. Построенная с применением 
данного метода система обеспечит интеграцию более широкого круга 
сервисов и использование большего количества методов управления 
доступом. 

39 
 
Рис. 8. Структурная схема системы семантической интеграции 
управления доступом к сервисам 
 
Логическая архитектура комплекса программ показана на рис. 9 
и состоит из трех уровней: 
- Уровень технических служб отвечает за взаимодействие с репозиториями правил разграничения доступа 
r
i
R, обеспечивает создание консолидированного репозитория правил разграничения доступа 
R
0
. 
- Уровень приложений реализует прикладную логику управления доступом: процедуры защиты информации, управление сессиями 
и т.д. 
- Уровень представления обеспечивает взаимодействие комплекса с внешним миром: сервисами, администраторами, пользователями и внешними информационными системами. 
 

40 
 
Рис. 9. Архитектура комплекса программ по управлению доступом к 
сервисам 
 
Консолидированный репозиторий правил разграничения доступа построен на основе LDAP-каталога Sun Java System Directory Server. Адаптеры протоколов идентификации реализованы с использованием ПО  FreeRADIUS,  OpenSSO,  Samba.  Система управления построена на основе  Sun  Java  System  Delegated  Administrator,  функциональность которого расширена для возможности управления доступом к сервисам разных типов. Система управления предоставляет два
 
типа интерфейса: Web и командную строку. Распределение полномочий между администраторами реализовано с помощью делегирования 
на двух уровнях: администратор с полным доступом и администратор 
организации. Комплекс работает под управлением ОС   Solaris.   
Надежность работы комплекса обеспечивается с помощью структурного резервирования. 
Удобство использования сервисов повышается за счет единого 
идентификатора и пароля. Количество необходимых 
для работы 
идентификаторов сократилось с  10  (соответствует количеству сервисов, подключенных к системе управления доступом) до одного. Со
41 
кращение количества идентификаторов также привело к уменьшению 
количества запросов в службу поддержки по восстановлению забытых паролей и консультаций по порядку доступа к сервисам на 60 %. 
Проведен сравнительный анализ временных характеристик процесса управления доступом к сервисам с использование системы интегрированного управления и без нее. Результаты сравнительного 
анализа представлены в табл
. 4. 
 
Таблица 4 
Результаты сравнительного анализа временных затрат в ходе 
управления доступом к сервисам 
 
 
Время, сэкономленное при управлении доступом с использованием системы интегрированного управления, может составлять до 
80% от обычного времени работы с применением существующих систем управления доступом за счет сокращения количества ручных 
операций. 
Интеграция управления доступом к сервисам 
разных типов позволяет снизить требования к администраторам за счет предоставления единой интуитивной понятной системы управления с   Webинтерфейсом. 
 
 
1.2. Анализ методов проверки корректности работы 
программного обеспечения 
 
 
Если корректность модели можно гарантировать с помощью 
ограничений на методы построения модели в ПО, тогда адекватность 
может быть проверена только после того, как проведена верификация 
модели. Для построения корректной модели могут использоваться 

42 
методы автоматического порождения моделей  (Model  Extraction)  по 
заданному алгоритму, а автоматическое построение адекватной модели достигается за счёт комбинирования методов булевой абстракции с итеративной верификацией моделей. Такой подход к построению моделей получил название  Counter  Example  Guided  Abstraction  
Refinement. В случае неудачной проверки построенной модели проводится уточнение модели с помощью САДТ. В данном случае комбинируются средства  MC  и САДТ. Гарантия полностью автоматической проверки моделей исчезает, т.к. не во всех случаях САДТ способны выдать доказательство запрашиваемого утверждения. 
Эффект «комбинаторного взрыва» связан с экспоненциальным 
ростом пространства состояний при линейном росте числа взаимодействующих процессов. Последствиями экспоненциального роста 
пространства состояний становятся высокие требования к объему па
мяти, используемой верификатором моделей, и долгое время проверки модели. Для сжатия проверяемого множества состояний используются символьные способы представления моделей, например, двоичные разрешающие диаграммы  (Binary  Decision  Diagrams,  BDD).  В 
символьном представлении модели выражаются с помощью BDD, которые реализуют функции алгебры логики. При поиске в пространстве состояний вместо перебора состояний используются операции 
над функциями. 
Алгоритмы верификации моделей с помощью  BDD  могут быть 
значительно эффективнее явного перебора состояний в том случае, 
когда BDD системы переходов модели и промежуточных результатов 
остаются компактными. Для моделей аппаратных схем представление 
модели в виде  BDD  даёт хороший коэффициент сжатия по отношению к явному представлению множеств. Модели распределённого 
ПО сжимаются несколько хуже
, т.к. в распределённом ПО используется асинхронное взаимодействие. 
Для борьбы с «комбинаторным взрывом» при верификации моделей ПО используются методы редукции частичных порядков. В 
этих методах проверяется достаточное подмножество множества всех 
трасс. Такое подмножество вычисляется на основании зависимостей 
между переходами процессов модели. Типы проверяемых зависимостей выявляются эмпирически. Оптимальный 
выбор правил редукции 
может существенно ускорить алгоритм верификации модели. 
Третьей проблемой применения группы методов  MC  является 
требование конечности числа состояний проверяемой модели. Алго
43 
ритмы   MC   гарантированно завершаются и эффективно работают 
именно на моделях с конечным числом состояний. При попытке 
обобщения задачи верификации методами  MC  с целью проверки систем с бесконечными множествами состояний возникает два направления: верификация моделей с бесконечным числом состояний и верификация параметризованных моделей. 
При верификации моделей с бесконечным числом состояний 
(Infinite  State-Space  Model  Checking)  
в описании модели могут присутствовать переменные с неограниченными типами данных, а порождаемая по описанию система переходов обладает бесконечным 
множеством состояний. Для решения этой задачи используются комбинации символьных методов верификации моделей. 
Задача верификации параметризованных моделей (Parameterized 
Model  Checking,  PMC)  возникает при рассмотрении моделей распределённых систем, в которых число однотипных взаимодействующих 
процессов 
зависит от начальной конфигурации системы и может быть 
сколь угодно большим. Увеличение числа вычислителей не всегда 
приводит к линейному росту производительности распределённой 
ИС. Аналогично, выводы о выполнимости спецификации, полученные для конфигурации с одним числом процессов, нельзя переносить 
на конфигурации с другим числом процессов, не приводя дополнительной аргументации. Решение задачи
  PMC  позволяет убедиться в 
выполнимости проверяемых спецификаций при масштабировании 
распределённого ПО, т.е. при росте числа взаимодействующих процессов.  
При фиксированном числе процессов может быть построена модель распределённой ИС с конечным числом состояний. Однако число взаимодействующих процессов неограниченно, и множество моделей с различным числом процессов бесконечно. Проверка произвольных моделей с фиксированным числом процессов не даёт гарантии выполнимости проверяемого свойства при увеличении числа взаимодействующих процессов, а все модели проверить невозможно.  
В задаче PMC рассматриваются распределённые ИС взаимодействующих процессов. В этих ИС присутствует фиксированное число 
статических процессов и неограниченное число однотипных процессов. Так как число однотипных процессов
 не ограничено, то по распределённой ИС может быть построено бесконечное семейство моделей. Каждая модель соответствует конфигурации ИС с фиксированным числом процессов. Для проверки свойств распределённой ИС 

44 
необходимо проверить спецификацию на всех моделях бесконечного 
семейства. 
Методы решения задачи   PMCP   развивались в следующих 
направлениях: 
 аналитические методы редукции; 
 методы абстракции; 
 символьные методы; 
 методы, основанные на поиске инварианта. 
В аналитических методах редукции указывается способ отображения моделей семейства параметризованных моделей на одну модель этого семейства  (cut-off  model).  В этом
 случае точно известны 
ограничения, которым должны удовлетворять модели семейства. 
Несомненными достоинствами аналитических методов редукции являются: точное описание области применимости методов, алгоритмизация и завершаемость. С помощью средств  MC  достаточно 
проверить все модели 
ܯ
1
, ..., ܯ
ܰ
 до порогового значения ܰ, где ܰ известно заранее. 
Среди недостатков подхода можно перечислить следующие. Вопервых, аналитические методы редукции применимы только к двум 
видам ИТС: асинхронным ИТС с кольцевой топологией, процессы 
которых обмениваются маркером, а также асинхронным широковещательным ИТС с переходами специального вида. Во-вторых, теоретические оценки порогового значения для некоторых методов зависят 
от числа состояний процессов, поэтому число состояний пороговой 
модели может быть настолько большим, что в результате проверка 
пороговой модели будет практически невозможной. 
Для методов абстракции также указывается способ отображения 
параметризованных моделей на одну модель, но эта модель не принадлежит самому параметризованному семейству, а моделирует поведение любого числа однотипных процессов
. Из способа отображения следуют структурные ограничения на параметризованные семейства моделей, которые могут быть верифицированы таким способом. 
Основное достоинство методов абстракции заключается в том, 
что после нахождения вида абстрактной модели и отображения моделей семейства 
࣠ на абстрактную модель, проверка свойств осуществляется автоматически для любой параметризованной модели (за исключением метода Лесена и Сайди, где булева абстракция строится с 
помощью САДТ). Методы верификации параметризованных моделей 
с помощью абстракции опираются на постоянно развивающийся ап
45 
парат построения булевых абстракций и абстрактной интерпретации. 
Поэтому область применимости методов абстракции к задаче  PMC  
постепенно расширяется. 
Недостатки. Даже в тех случаях, когда экспертам удаётся указать вид абстрактной модели 
ܣ и способ абстракции ߙ для класса моделей, область применимости методов ограничивается: ИТС, процессы которых обмениваются маркером; широковещательными ИТС; 
ИТС с топологией «звезда». В остальных случаях методы абстракции 
требуют подсказок от эксперта. Например, требуется явное указание 
существенных переменных и предикатов в ИТС переходов. Когда абстракция построена, спецификация может не выполняться на абстрактной модели. Из чего не следует, что спецификация нарушается 
и на моделях параметризованного семейства 
࣠. В таком случае требуется участие эксперта для уточнения абстракции, однако уточнение 
возможно не для всех указанных методов. 
Символьные методы используют модификации символьного 
подхода к решению задачи  MC.  Для описания параметризованного 
семейства моделей используются системы переходов, в которых переходы задаются неявно, с помощью символьных описаний. Например, множества переходов могут 
представляться регулярными выражениями или логическими формулами с кванторами существования и 
всеобщности. Для заданной системы переходов ищется множество 
состояний, достижимых из начальных состояний. В случае символьных методов, как правило, нет гарантии завершаемости. 
Достоинства. Символьные методы могут применяться для проверки свойств информационной безопасности (ИБ) параметризованных моделей асинхронных распределённых ИТС
 со следующими топологиями: кольцевая, древовидная, полносвязная. Положительным 
свойством методов является использование известных в математической логике языков и готовых средств вывода для этих языков. Выразительные возможности применяемых языков позволяют описывать 
протоколы, параметризованные не только по числу процессов, но и 
использующие бесконечные типы данных, например, целочисленные 
счётчики. 
Недостатки. Так 
как символьные методы основаны на представлении ИТС переходов параметризованного семейства 
࣠ в целом с 
помощью более выразительных языков, нежели  LTS,  размеченных 
пропозициональными переменными, завершаемость методов, в общем случае не гарантируется. В некоторых случаях завершаемость 

46 
может быть достигнута модификацией преобразователя ܶ, например, 
с помощью применения техник добавления дополнительных переходов (акселерация, acceleration) и поиска аппроксимаций (расширение, 
widening). Однако в этом случае требуется участие эксперта с целью 
изменения преобразователя. Другим недостатком является требование повторного описания модели в параметризованном виде на языках, сильно отличающихся от языков описания моделей, используемых в средствах  MC.  После
 того, как модель распределённой ИТС 
построена и верифицирована для фиксированного числа процессов с 
помощью стандартного средства  MC,  желательно использовать выбранный уровень абстракции и перевести модель в параметризованный вид с минимальным вмешательством эксперта. 
В методах, основанных на поиске инварианта, ищется или конструируется процесс-инвариант, моделирующий поведение нескольких процессов 
ИС. Инвариант должен обладать следующим свойством: ИС, состоящая из инварианта с дополнительными однотипными процессами, также моделируется инвариантом. С помощью индукции показывается, что ИС со сколь угодно большим числом однотипных процессов моделируется системой, состоящей из фиксированного числа процессов и инварианта. Основное отличие от методов 
абстракции состоит в
 том, что не требуется явное отображение каждой модели параметризованного семейства на модель-инвариант. 
Достоинства. В методах инвариантов используется способ индуктивного доказательства и довольно простой критерий проверки 
инварианта. Поэтому методы могут быть автоматизированы. Поиск 
инварианта среди моделей семейства 
࣠ с малым числом процессов 
соответствует интуитивному представлению инженеров, разрабатывающих модель, о поведении модели. С помощью методов инвариантов могут проверяться параметризованные модели с нетривиальной 
топологией, представляемой сетевыми грамматиками, и различными 
прототипами процессов. Существенным достоинством является и то, 
что после нахождения инварианта (или нескольких инвариантов в 
случае сетевой грамматики), для 
проверки модели, содержащей инвариант, достаточно применить развитые средства метода верификации 
моделей. 
Недостатки. В тех случаях, когда не удаётся найти инвариант 
среди моделей с малым числом процессов, необходимо дополнительно применять методы абстракции, требующие знаний эксперта. Так 
как автоматический поиск инварианта проводится среди моделей се
47 
мейства, в общем случае для процедуры поиска нет гарантии завершаемости. Однако, на практике инварианты необходимо искать среди 
моделей с довольно небольшим числом процессов, так как размер 
множеств состояний в моделях параметризованного семейства растёт 
экспоненциально с числом процессов. 
На основе описания достоинств и недостатков представленных 
методов решения задачи PMCP, большинство аналитических методов
 
редукции и методов абстракции обладает свойствами алгоритмизации 
и завершаемости. 
Однако область применимости обеих групп методов невелика: 
асинхронные модели, в которых процессы обмениваются маркером; 
асинхронные модели с широковещательной передачей сообщений; 
асинхронные модели с топологией «звезда». При необходимости проверки моделей с другой топологией требуется разработка новых методов, возможно, аналогичных уже 
известным. 
Сравним символьные методы и методы инвариантов. Символьные методы и методы инвариантов применяются к параметризованным моделям с различной топологией: кольцевой, линейной, древовидной. Символьные методы применяются, в основном, для проверки 
свойств безопасности, в то время как многие методы инвариантов 
применимы и для проверки свойств живучести. 
Обе группы методов используют
 полуразрешающие процедуры, 
поэтому, в общем случае, не завершаются. 
Для применения символьных методов описание параметризованной модели требуется представить на специальном языке метода, 
обычно довольно сильно отличающегося от языков описания моделей 
средств  MC.  Методы инвариантов используют описания процессов в 
виде LTS, размеченных пропозициональными переменными, и совместимы с языками описания моделей средств  MC.  Методы 
инвариантов используют для проверки спецификации и поиска контрпримеров 
существующие средства  MC,  символьные же методы требуют реализации специальных алгоритмов. 
Учитывая вышесказанное, в настоящей работе в качестве базового метода выбран метод инвариантов, а процедура порождения моделей параметризованного семейства и поиска инвариантов основана 
на процедуре, используемой в методах сетевых инвариантов. 
Метод сетевых инвариантов с использованием квазиблочной и 
блочной симуляций
. Идея метода заключается в поиске моделейинвариантов среди  LTS,  соответствующих деревьям вывода, с ис
48 
пользованием отношения блочной симуляции. Если такие моделиинварианты найдены, задача PMC может быть сведена к проверке конечного числа моделей методом MC.  
При поиске инварианта сначала ищутся инварианты для тех нетерминалов 
ܣ, из которых выводятся лишь терминалы или сам нетерминал 
ܣ. После того, как инварианты для таких нетерминалов 
найдены, осуществляется поиск инвариантов для нетерминалов, использующих в правилах вывода другие нетерминалы. 
Так как поиск осуществляется только среди LTS, выводимых из 
нетерминалов, перебор осуществляется полностью автоматически. 
Однако, не для каждого параметризованного семейства процедура 
перебора завершается. Алгоритм построения блочной симуляции является ключевым для 
поиска инварианта. Из этого следует, что достаточно ограничиться построением полублочной симуляции. Таким 
образом, алгоритм построения полублочной симуляции является 
ключевым в методе поиска инвариантов. 
Алгоритм построения полублочной симуляции. В начале работы 
алгоритма пары начальных состояний первой и второй модели заносятся в множество неподтверждённых пар. На каждой итерации алгоритма проверяется гипотеза о том, что все неподтверждённые пары 
удовлетворяют определению полублочной симуляции. Если в ходе 
проверки обнаруживается, что некоторая пара не удовлетворяет этому определению, она заносится в 
множество опровергнутых пар. 
Проверка прекращается, как только множества неподтверждённых и 
опровергнутых пар перестаёт расширяться. 
При анализе ПО выделяют два основных метода контроля и 
анализа программ: статический и динамический. Статические методы 
основаны на исследовании тех или иных свойств ПО без его выполнения с использованием различных инструментальных сред. Наиболее широкое распространение
 имеют следующие методы статического контроля: 
• синтаксический контроль; 
• контроль структурированности ПО; 
• контроль правдоподобия программ; 
• верификация ПО. 
Методы верификации основаны на доказательстве корректности 
или некорректности ПО, соответствии разработанного ПО его спецификациям. 

49 
Верификация ПО весьма сложна, но практически гарантирует 
правильность полученного ПО относительно сформулированных для 
него спецификаций. К недостаткам методов верификации можно отнести то, что формирование метаописания ПО весьма сложно. Кроме 
того, верификация практически не применяется на поздних этапах 
жизненного цикла ПО. 
Существует два основных вида тестирования ПО: 
• функциональное тестирование; 
• структурное
 тестирование. 
Функциональное тестирование рассматривает программу как 
«черный ящик». Проверяется соответствие программы ее внешней 
спецификации. Отмечено, что исчерпывающее функциональное тестирование невозможно, а для программных продуктов большого 
размера применение его нецелесообразно. Структурное тестирование 
основано на знании внутренней структуры программы и предполагает 
обход всех ветвей по графу управления ПО. 
 
  

50 
2. АВТОМАТИЗАЦИЯ ПРОЦЕССА УПРАВЛЕНИЯ 
ДОСТУПОМ К ИНФОРМАЦИОННОМУ И 
ПРОГРАММНОМУ ОБЕСПЕЧЕНИЮ БАНКА 
 
 
2.1. Автоматизация разграничения доступа к 
информационному и программному обеспечению банка 
 
 
Для создания структурной модели управлением банком необходимо выявление взаимосвязей структурных подразделений банка с 
точки зрения управления защитой информационного и программного 
обеспечения банка. На рис. 10 представлена структура банка с точки 
зрения управления защитой информационного и программного обеспечения банка. Объектом защиты являются данные о деятельности 
банка, составляющие совершенно секретную информацию
, коммерческую тайну, а также другую конфиденциальную информацию. 
К совершенно секретным информационным и программным ресурсам банка относятся проекты, разработки банка, такие как проектно-конструкторская документация, программно-аппаратные продукты, сопровождающая документация к ним. К коммерческой тайне относится информация о материальных и финансовых ресурсах, вложенных в производство 
конечного продукта банка. 
К другой конфиденциальной информации можно отнести идентифицирующую информацию сотрудников. 
Согласно рис. 10, в банке существуют, как минимум, три уровня 
доступа к информационным и программным ресурсам: 
 «красный» уровень, к которому относится доступ непосредственно к стратегически важным информационным и программным 
ресурсам банка, информации о разработках, проектах, сопровождающей
 документации к ним; 
 «жѐлтый» уровень  –  доступ к информационным и программным ресурсам банка, связанным с разработками, проектами, но не 
имеющим непосредственного отношения к совершенно секретным; 
 «зелѐный» уровень – отсутствие доступа к информационным и 
программным ресурсам банка, связанным с разработками и проектами банка. 

51 
 
Рис. 10. Структура коммерческого банка в аспекте управления 
защитой информационного и программного обеспечения банка 
 
К «красному» уровню доступа относятся структурные подразделения банка, которые имеют отношение к разработке проектов и их 
сопровождению. К сопровождению относятся: тестирование, проверка качества продуктов банка, проверка технической документации, 
проверка соблюдения установленных норм защиты информационного 
и 
программного обеспечения банка. 
К «желтому» уровню доступа относятся структурные подразделения банка, которые производят обработку информации о проектах 
и разработках банка, не содержащей совершенно секретных данных. 
К ним относятся структуры, проводящие экономический расчѐт, отдел кадров, отдел закупок. Экономическим группам, отделу снабжения нет необходимости знать детали разработок и проектов. Данная
 
информация является для них избыточной. То же касается отдела 
кадров банка: сотрудники отдела кадров имеют доступ только к персональным данным других сотрудников банка. 

52 
К «зеленому» уровню доступа относятся подразделения банка, 
которым нет необходимости в ознакомлении со стратегически важными информационными и программными ресурсами банка. К ним 
относятся подразделения сторонних служб, например, здравпункт и 
столовая. Основной целью разрабатываемой АСРДкИПО является 
обеспечение должного уровня защиты информационного и программного обеспечения банка согласно требованиям ранжирования 
доступа, представленного
 на рис.  10.  Данные об уровне доступа сотрудников структурных подразделений банка к информационным ресурсам банка представлен в табл. 5. Согласно представленной структурной модели управления банка с учѐтом требований защиты информационного и программного обеспечения банка, а также представленных в таблице уровней доступа подразделений банка к информации о 
проектах, требуется создание эффективного решения в 
виде отдельного модуля АСРДкИПО. 
АСРДкИПО при работе с «красным» уровнем доступа должна 
отслеживать внутренние информационные потоки банка. Поддержка 
журнала аудита важна с целью детектирования инцидентов нарушений правил работы с информационным и программным обеспечением 
банка и дальнейшего их расследования. 
Что касается внешних информационных потоков на
 «красном» 
уровне доступа, то лучшим вариантом является изолирование рабочих мест сотрудников, относящихся к «красному» уровню доступа, от 
ГВС (Интернет). Если полное изолирование невозможно, то необходимо обеспечить фильтрацию информационного потока в виде агента 
подсистемы класса DLP – Endpoint Solution. Также это касается переносных носителей данных и принтеров: лучшим вариантом является 
полный запрет 
на распечатку или хранение на съѐмных носителях 
стратегически важной информации  –  организация хранения информационных ресурсов только в контуре ЛВС банка. Если это решение 
невозможно, то необходимо также применять подсистему класса DLP 
– Endpoint Solution. На рис. 10 видно, что также к «красному» уровню 
относятся отделы стандартизации, контроля качества и контроля технической документации. Перечисленные отделы 
также имеют доступ 
к стратегически важной информации о разрабатываемом проекте, поэтому им необходимо уделить особое внимание.  
 
 
 

53 
              
Таблица
 5 
Уровень
 
доступа
 
структурных
 
подразделений
 
банка
 
к
 
стратегически
 
важным
 
информационным
 
ресурсам
 
банка
 

54 
Сопровождающая документация представлена в электронном 
или бумажном виде, и она также является стратегически важным информационным ресурсом, поэтому при работе с ней необходимо подключать все три составляющие АСРДкИПО: подсистему класса  DLP  
–  Endpoint  Solution;  подсистему слежения за внутренними потоками 
информации; подсистему разграничения доступа сотрудников к информационным и программным ресурсам банка. Основная задача 
отдела информационной безопасности банка  –  отслеживание, предотвращение и ведение расследований инцидентов нарушения правил 
работы с информационным и программным обеспечением банка. 
Также в полномочия сотрудников отдела входит проверка поступающего в банк аппаратного и программного обеспечения на наличие вирусов, программных и аппаратных закладок, подслушивающих 
устройств и т.д. Отдел информационной
 безопасности также несет 
ответственность за поддержку функционирования АСРДкИПО, поэтому его сотрудники должны проходить особую проверку (на полиграфе). «Who guards the guardians?» «Кто следит за следящими?» философский вопрос, который до сих пор не решѐн, поэтому подбор 
персонала в отдел информационной безопасности банка должен осуществлять особо строго. 
Информационные ресурсы, доступные сотрудникам отдела 
кадров, является, несомненно, конфиденциальными, но не обязательно 
критичными для банка. Злоумышленник, перехвативший данные из 
отдела кадров, не будет осведомлѐн о разработках банка, более того, 
ему не будет доступен список сотрудников, задействованных в тех 
или иных текущих проектах, поэтому уровень доступа для сотрудников отдела кадров  –  «жѐлтый». К информации о разработках
 сотрудники отдела кадров вовсе не имеют доступа, поэтому необходимости 
в очень строгом уровне контроля нет. Аналогична ситуация с экономическими службами банка  –  расчѐт заработной платы и расходнодоходной части также производится изолированно. Сотрудники экономических отделов не имеют доступа к стратегически важным информационным ресурсам банка – к информации о 
разработках и проектах. Злоумышленник, перехвативший данные из экономического 
отдела максимум, что может узнать  –  это размер заработной платы 
сотрудника и кодировку проекта, в котором сотрудник задействован, 
поэтому все экономические службы банка имею «жѐлтый» уровень 
доступа. Сотрудники отделов снабжения и закупок осведомлены о 
материальных ресурсах, требуемых для основного производства, но 

55 
им присвоен «жѐлтый» уровень доступа. Сотрудники общего отдела 
не имеют доступа ни к каким стратегически важным информационным ресурсам банка, поэтому они относятся к «зелѐному» уровню 
доступа. Таким образом, три уровня доступа охватывают всех сотрудников банка. Основной задачей разрабатываемой АСРДкИПО 
является поддержание описанной выше методики управления защитой информационного и
 программного обеспечения банка. На рис. 11 
отображены части информации о проекте, к каждой из которых определен свой уровень доступа. 
 
 
Рис. 11. Области доступа к информации о проекте 
 
Для осуществления организации допуска сотрудника к той или 
иной части информации о проекте необходим дополнительный модуль  –  менеджер доступа. Основной задачей менеджера доступа 
является проведение аутентификации и авторизации сотрудника. Для 
работы менеджера потребуется база данных сотрудников банка. В базе данных должны содержаться имена сотрудников и их аутентифицирующая информация, в качестве которой могут выступать пароль, 
информация о материальном носителе, информация о биометрических характеристиках сотрудника; также в базе данных необходимо 

56 
наличие информации о метках доступа объектов информационных 
отношений – информационном и программном обеспечении банка. 
На рис.  12  представлен алгоритм работы сотрудника банка с 
АСРДкИПО. 
 
 
Рис. 12. Алгоритм работы сотрудника банка с АСРДкИПО 
 
Перед началом работы сотрудника с ПО банка, управление передаѐтся АСРДкИПО. Сотрудник предоставляет идентифицирующую 

57 
информацию (IDe) и аутентификатор (Pe), в качестве которого могут 
выступать: 
- пароль; 
- материальный носитель; 
- биометрические данные сотрудника. 
Далее происходят процессы: 
- идентификации; 
- аутентификации; 
- авторизации сотрудника. 
Все процедуры проходят последовательно. При неудачном прохождении любой из них управление передаѐтся в начало алгоритма. 
После удачно пройденных последовательных процедур идентификации, аутентификации и авторизации сотруднику
 предоставляется 
метка доступа 
L. Метка доступа содержит данные об уровне доступа 
сотрудника к информационным массивам банка. Соответственно 
представленной структурной модели автоматизированного управления банком, метка доступа может определять «красный уровень», 
«жѐлтый уровень» и «зелѐный уровень» доступа. 
Для реализации методики защиты информационного и программного обеспечения банка необходимо использования базы данных, которая содержит информацию
 как об объектах, так и о субъектах защиты. 
На рис. 15 представлена схема таблиц базы данных банка. 
В базе данных банка находятся шесть основных таблиц: 
- таблица «Сотрудники»; 
- таблица «Проекты»; 
- таблица «Сопровождающая документация»; 
- таблица «Экономические характеристики»; 
- таблица «Отдела кадров предприятия»; 
- таблица «Информационная безопасность». 
Поля таблицы базы данных перечислены 
в табл. 6. 
 
Таблица 6 
Таблица базы данных «Сотрудники» 
 
 
 

58 
 
Рис. 13. Схема таблиц базы данных коммерческого банка 

59 
В табл. 6 имеются следующие поля: 
-  ID  –  идентифицирующая информация сотрудника (ключевое 
поле); 
-  P  –  аутентифицирующая информация сотрудника, в качестве 
которой могут выступать пароль, материальный носитель, биометрические данные сотрудника; 
- Descr – описание сотрудника – поле, в котором могут храниться данные о сотруднике (ФИО, год рождения, подразделение банка, к 
которому относится сотрудник); 
- Level – информация об уровне доступа
 сотрудника («красный», 
«жѐлтый» или «зелѐный»). 
Поля таблицы базы «Проекты» данных перечислены в табл. 7. 
 
Таблица 7 
Таблица базы данных «Проекты» 
 
 
Как представлено в табл.  7,  таблица базы данных «Проекты» 
имеет поля: 
- ProjectID – идентификатор проекта (ключевое поле); 
- Descr – описание проекта; 
-  Field1,...,  FieldN  –  поля подробной информации о проекте. В 
качестве подробной информации о проекте могут выступать
 сроки 
сдачи проекта, дополнительные характеристики, входные данные, 
ограничения и т.д. 
Поля таблицы базы данных «Сопровождающая документация» 
перечислены в табл. 8. 
 
Таблица 8 
Таблица базы данных «Сопровождающая документация» 
 
 
Таблица базы данных «Сопровождающая документация» имеет 
поля: 
- DocID – идентификатор документа (ключевое поле); 

60 
-  ProjectID  –  идентификатор проекта, к которому относится документ; 
-  Field1,...,  FieldM  –  поля подробной информации о документе. 
В качестве подробной информации о документе могут выступать 
сроки сдачи документа, грифы секретности, дополнительные ограничения и т.д. 
Поля таблицы базы данных «Экономические характеристики» 
перечислены в табл. 9.  
 
Таблица 9 
Таблица базы данных «Экономические характеристики» 
 
 
Таблица базы 
данных «Экономические характеристики» имеет 
поля: 
- EcoID – идентификатор экономического показателя (ключевое 
поле); 
- ProjectID – идентификатор соответствующего проекта; 
- Field1,..., FieldK – поля подробной информации экономического показателя. В качестве подробной информации могут выступать 
стоимость, условия финансирования, номер контракта, договора и т.д. 
Поля таблицы базы данных «Отдел кадров предприятия» перечислены в табл. 10. 
 
Таблица 10 
Таблица базы данных
 «Отдел кадров предприятия» 
 
 
Таблица базы данных «Экономические характеристики» имеет 
поля: 
-  ID  –  идентифицирующая информация сотрудника (ключевое 
поле); 
- DepartmentID – идентификатор подразделения банка; 
- Field1,..., FieldL – поля дополнительной информации о сотруднике банка. В качестве дополнительной информации могут высту
61 
пать: фамилия, имя, отчество, должность, семейное положение, дата 
принятия на работу, другие персональные данные сотрудника. 
Поля таблицы базы данных «Информационная безопасность» 
перечислены в табл. 11. 
 
Таблица 11 
Таблица базы данных «Информационная безопасность» 
 
 
Таблица базы данных «Информационная безопасность» имеет 
следующие поля: 
- T – время инцидента (ключевое поле); 
-  incidentID  –  идентификатор инцидента нарушения правил работы 
с информационным и программным обеспечением банка; 
- subjectID – идентификатор субъекта, породившего инцидент, в 
качестве которого может выступать как сотрудник организации, так и 
сама система (ее процесс); 
- objectID – идентификатор объекта инцидента – части стратегически важного информационного пространства банка; 
- LocationID – идентификатор места инцидента, в качестве которого могут выступать любые «интерфейсы-выходы» из ПО банка 
(порт связи с Интернет, USB-порт, принтер и т.д.); 
- Field1,..., FieldT – поля дополнительной информации об инциденте нарушения правил работы с информационным и программным 
обеспечением банка. В качестве дополнительной информации могут 
выступать: коды ошибок и исключений (детализация происшествия) 
– информация для сотрудника отдела информационной безопасности 
банка, идентификатор «подозрительного» пакета передачи данных и 
т.д. 
Вспомогательные таблицы базы данных. Для корректной работы 
АСРДкИПО с базой данной сотрудников банка необходимо наличие 
вспомогательных таблиц. 
- таблица «Инциденты»; 
- таблица «Субъекты»; 
- таблица «Объекты»; 
- таблица «Интерфейсы-выходы». 
Поля таблицы базы данных «Инциденты» перечислены в 
табл. 12. 

62 
Таблица 12 
Таблица базы данных «Инциденты» 
 
 
Таблица базы данных «Инциденты» имеет следующие поля: 
-  incidentID  –  идентификатор инцидента нарушения правил работы с информационным и программным обеспечением банка (ключевое поле); 
- incidentDescr – описание инцидента. 
Поля таблицы базы данных «Субъекты» перечислены в табл. 13. 
 
Таблица 13 
Таблица базы данных «Субъекты» 
 
 
Таблица базы данных «Субъекты» имеет 
следующие поля: 
- subjectID – идентификатор субъекта информационных отношений (ключевое поле); 
- subjectDescr – описание субъекта; 
- ID – идентификатор сотрудника, соответствующего идентификатору субъекта информационных отношений. 
Поля таблицы базы данных «Объекты» перечислены в табл. 14. 
 
Таблица 14 
Таблица базы данных «Объекты» 
 
 
Таблица базы данных «Объекты» имеет следующие поля: 
-  objectID  –  идентификатор объекта информационных отношений (ключевое поле); 
- objectDescr – описание
 объекта информационных отношений; 
-  DepartmentID  –  идентификатор подразделения банка, к которому относится соответствующий объект информационных отношений; 

63 
-  ID  –  идентификатор сотрудника, несущего ответственность за 
соответствующий объект информационных отношений. 
Поля таблицы базы данных «Интерфейсы-выходы» перечислены 
в табл. 15. 
 
Таблица 15 
Таблица базы данных «Интерфейсы-выходы» 
 
 
Таблица базы данных «Интерфейсы-выходы» имеет следующие 
поля: 
-  LocationID  –  идентификатор потенциального места инцидента 
нарушения правил работы с информационным и программным обеспечением банка – «интерфейса-выхода» 
из информационной системы 
банка (ключевое поле); 
- locationDescr – описание места инцидента; 
-  DepartmentID  –  идентификатор подразделения банка, к которому относится соответствующий «интерфейс-выход» из ПО банка. 
-  ID  –  идентификатор сотрудника, несущего ответственность за 
соответствующий «интерфейс-выход». 
Для достижения требований принятой методики защиты информационного и программного обеспечения банка необходимо разграничить доступ к таблицам базы 
данных. 
Сотрудники разных структурных подразделений банка обращаются к одному и тому же информационному ресурсу  –  базе данных 
сотрудников банка. Соответственно, к таблицам:  «Информационная 
безопасность»,     «Инциденты,     «Субъекты,     «Интерфейсы-входы», 
«Объекты» имеют доступ только сотрудники отдела информационной безопасности. Сотрудники отдела кадров имеют доступ к таблице 
«Отдел кадров предприятия». Экономические группы (планово
финансовый отдел, бухгалтерия, отдел труда и т.д.) имеют доступ к 
таблице «Экономические характеристики». К таблице «Проекты» 
полного доступа не имеет никто. Разграничение доступа производится относительно строк таблицы, а не таблицы целиком. Также организуется доступ к таблице «Сопровождающая документация». Это 
связано с такой характеристикой информации, как полезность. 

64 
Сотрудник банка, принадлежащий к одному из отделов разработки, имеет доступ только к тем строкам (кортежам таблицы), которые относятся к проекту, над которым он работает в данный момент 
времени. Причѐм, эффективность работы сотрудника увеличится, если ему будет предоставлена максимально большая часть информации 
о проекте. Это связано с тем, что
 зачастую за надуманной секретностью разработки прячется корыстное утаивание от разработчика важной для него информации, в том числе информации о технических 
заданиях, о требованиях заказчика, о планах и сроках сдачи и т.д.  –  
той информации, которая является важной для разработчика. Поэтому в рамках предлагаемой методики защиты информационного и 
программного обеспечения банка предполагается следующее утверждение: если конкретный разработчик (сотрудник одного из проектно-конструкторских или научно-исследовательских подразделений 
банка) имеет доступ к проекту, то этот доступ определяет максимальный уровень осведомленности об информации о этом проекте. Данное утверждение не противоречит принципу полезности информационных и программных ресурсов банка
, описанном ранее. Для более 
высокого уровня защиты информационного и программного обеспечения банка доступ к таблице «Проекты» сотрудник получает не 
напрямую, а через таблицу «Объекты»  (связь по идентификатору сотрудника  «ID»).  Аналогично, сотрудник экономической группы получает информацию о сотруднике банка (например, когда производит 
расчѐт заработной платы) не напрямую, а через 
таблицы «Проекты», 
«Объекты», «Сотрудники». Полного доступа к таблице «Сотрудники» 
не имеет никто из физических лиц, в том числе и доступа по строкам. 
Обращение к этой таблице также происходит во время процедур 
идентификации, аутентификации и авторизации пользователей. Соответственно, это обращение формирует сама АСРДкИПО. Также можно организовать дополнительную защиту за 
счѐт использования 
«двойной аутентификации». Сотрудник банка проходит процедуру во 
время входа в систему, а также во время обращения к данным. На 
рис.  14  отображено соответствие таблиц базы данных банка и структурным подразделениям. Примеры окон программы работы с базой 
данных банка приведены в приложении. 

65 
 
Рис. 14. Соответствие таблиц базы данных банка и доступа к ним 
сотрудников структурных подразделений 

66 
Для фиксации инцидентов, а также для проведения расследований при разработке АСРДкИПО необходимо предусмотреть наличие 
журнала аудита. Журнал аудита представляет собой таблицу базы 
данных, а также копию данной таблицы в отдельном файле (чаще 
всего лог-файле). Файл-лог может иметь несколько копий в системе. 
Также необходимо предусмотреть тот факт, что журнал
 аудита должен быть доступен только для просмотра и только сотрудниками отдела информационной безопасности банка.  «Дозапись» строк (кортежей) должна производиться только самой АСРДкИПО. Согласно 
представленным структурной модели автоматизированного управления банком на основе принципов ограничения доступа к стратегически важным информационным, программным ресурсам, и схеме базы 
данных, журнал 
аудита относится к таблице «Информационная безопасность». Полями таблицы являются: 
- Идентификационный номер инцидента нарушения правил работы с информационным и программным обеспечением банка – является уникальным, поэтому является ключевым полем. Тип данных  –  
счѐтчик; 
- Время инцидента. Тип данных - время; 
- Идентификатор субъекта, инициализировавшего инцидент 
(идентификатор сотрудника). Тип данных - GUID; 
- Идентификатор объекта, 
к которому относится инцидент (файл 
конфиденциальной информации). Тип данных - GUID; 
- Идентификатор места инцидента  –  физическое расположение 
инцидента (USB-порт, принтер, терминал сотрудника, терминал ГВС 
и т.д.). Тип данных - GUID; 
- Дополнительные поля  –  поля, в которых располагается специфическая информация об инциденте. Как правило, данное поле имеет 
тип данных «строка», так как чаще всего специфической
 информацией об инциденте являются коды ошибок, инициализированные исключения. 
Необходимо предусмотреть функцию просмотра таблицы «Информационная безопасность» с возможностью фильтрации по: 
- времени; 
- субъекту; 
- объекту; 
- месту происхождения инцидента. 
Как видно из рис. 14 данная таблица связана с таблицами: 

67 
-  «Инциденты», в которой хранится подробная информация об 
инциденте – описание инцидента и т.д.; 
- «Субъекты», в которой хранятся данные о сотрудниках банка; 
- «Объекты», в которой хранится подробная информация о файлах стратегически важных информационных ресурсах банка; 
-  «Интерфейсы-входы», в которой перечислены все возможные 
каналы утечки информационных ресурсов. 
Перечисленные таблицы также
 доступны только для просмотра 
и записи только сотрудниками отдела информационной безопасности 
банка. Как правило, данные таблицы формируются при проектировании АСРДкИПО сотрудниками отдела информационной безопасности с занесение в них информации о файлах стратегически важных 
информационных и программных ресурсов банка, о сотрудниках, о 
физических расположения портов. В таблицы заносятся изменения 
в 
процессе работы АСРДкИПО при следующих ситуациях: 
- изменение списка сотрудников; 
- изменение списка файлов стратегически важных информационных ресурсах; 
- изменение списка портов, физических устройствах, терминалов 
входа в ГВС (Интернет) и т.д.; 
- изменение топологии ЛВС банка. 
С целью повышения отказоустойчивости АСРДкИПО необходимо предусмотреть обязательное резервное копирование информации о
 нарушениях  –  сохранение таблицы инцидентов в отдельном 
хранилище «Архив инцидентов нарушения правил работы с информационным и программным обеспечением банка». Работу с «архивом 
инцидентов» необходимо организовать таким образом, чтобы запись 
в архив (изменение содержимого архива) могла производить только 
АСРДкИПО (без участия человека)  –  т.е. в автоматическом режиме. 
Чтение информации из архива 
должно быть доступно всем сотрудникам отдела информационной безопасности банка. Процесс работы с 
архивом инцидентов нарушений правил работы с информационным и 
программным обеспечением банка представлен на рис. 15. 
Условные обозначения на рис. 15: 
- зеленая стрелка – обращение по чтению; 
- красная стрелка – обращение по записи. 
 

68 
 
Рис. 15. Процесс работы с архивом инцидентов 
 
Подразделение информационной безопасности банка относится 
к «красному» уровню доступа, но ответственность за обеспечение 
функционирования АСРДкИПО ложится именно на сотрудников этого подразделения, поэтому данное подразделение можно классифицировать как подразделение высшего уровня доступа. Сотрудники 
подразделения информационной безопасности банка  –  офицеры безопасности  –  наделены высшим уровнем 
доступа, поэтому при зачислении в штат банка им необходимо пройти особую проверку, в том 
числе с использованием полиграфа. Для непосредственной организации и эффективного функционирования АСРДкИПО как системы 
обеспечения защиты информационного и программного обеспечения 
банка, исключающей возможные конфликты интересов, в банке 
необходимо наличие единого подразделения. На данное подразделение необходимо
 возложить следующие задачи: 
- проведение в жизнь принятой методики обеспечения защиты 
информационного и программного обеспечения банка; 
- анализ текущего состояния обеспечения защиты; 
- организация мероприятий и координация работ всех подразделений банка по комплексной защите составляющих ПО банка; 
- контроль и оценка эффективности принятых мер и применяемых средств защиты; 

69 
Основные функции подразделения обеспечения защиты составляющих ПО банка заключается в следующем: 
- формирование требований к системам защиты (АСРДкИПО) в 
процессе создания и дальнейшего развития существующих компонентов банка; 
- участие в разработке, сопровождению АСРДкИПО, испытаниях и приемке в эксплуатацию; 
- обеспечение корректного функционирования АСРДкИПО; 
- постоянный контроль и мониторинг основных программно
аппаратных модулей АСРДкИПО на наличие вредоносного программного и аппаратного обеспечения; 
- проверка информационных файлов, генерируемых АСРДкИПО 
в ходе функционирования системы (так называемы log-файлов), в которых содержатся данные об информационных потоках и о работе 
основных пользователей ПО банка со стратегически важными информационными и программными ресурсами; 
- реагирование на инциденты 
нарушения правил работы с информационным и программным обеспечением банка согласно соответствующим инструкциям и нормативным документам; 
- проведение расследований инцидентов на основании полученных о АСРДкИПО файлов-логов; 
- генерация и распределение между пользователями необходимых атрибутов доступа к информационным и программным ресурсам 
банка; 
- наблюдение за функционированием АСРДкИПО и ее 
элементов; 
- постоянная проверка надѐжности функционирования АСРДкИПО; 
- разработка мер нейтрализации моделей возможных атак; 
- обучение пользователей и обслуживающего персонала правилам работы с информационным и программным обеспечением банка 
(в том числе особым правилам по работе с информационными ресурсами особой важности); 
- оказание методической помощи сотрудникам банка в вопросах 
обеспечения параметров защиты; 
- контроль за соблюдением пользователями (сотрудника банка) 
и обслуживающим персоналом установленных правил обращения с 
информационными и программными ресурсами банка (в том числе со 
стратегически важными); 

70 
- организация по указанию руководства служебного расследования по фактам нарушения правил обращения с информационными и 
программными ресурсами (в том числе со стратегически важными), 
оборудованием банка; 
- принятие мер при попытках несанкционированного доступа к 
информационным и программным ресурсам и компонентам ПО банка 
или при нарушениях правил функционирования системы защиты 
(АСРДкИПО); 
- сбор
, накопление, систематизация и обработка информации по 
вопросам обеспечения защиты информационных и программных ресурсов банка. 
Организационно-правовой статус подразделения обеспечения 
защиты банка должен определяться следующим образом: 
- численность подразделения должна быть достаточной для выполнения всех перечисленных выше функций; 
- сотрудники, занимающиеся обеспечением защиты информационного и программного обеспечения банка не 
должны иметь других 
обязанностей, связанных с обеспечением функционирования технических компонентов ПО банка; 
- сотрудники подразделения обеспечения защиты должны иметь 
право доступа во все помещения, где установлены технические средства банка, и право прекращать обработку информационных ресурсов 
при наличии непосредственной угрозы для них; 
- руководителю подразделения должно быть предоставлено право запрещать
 включение новых компонентов ПО банка в число действующих, если они не отвечают требования защиты и это может 
привести к серьезным последствиям в случае реализации значимых 
угроз нарушения параметров защиты; 
- подразделению обеспечения контроля защиты ПО банка должны обеспечиваться все условия, необходимые для выполнения своих 
функций. 
Основные компоненты АСРДкИПО представлены
 на рис. 16. 
Основная задача, решаемые данной подсистемой разграничения 
доступа сотрудников банка к информационным и программным ресурсам банка  –  обеспечение соблюдения разграничения доступа за 
счѐт применения организационных, правовых, технических (аппаратно-программные), физических мер защиты. Основные модули АСРДкИПО представлены на рис. 17. 
 

71 
 
Рис. 16. Основные компоненты АСРДкИПО 

72 
 
Рис. 17. Основные модули АСРДкИПО 
 
При разработке АСРДкИПО особое внимание уделялось применению аппаратно-программных мер защиты: применение алгоритма 
разграничения доступа, включающего процессы идентификации, 
аутентификации, авторизации. 
Организационные меры защиты – это меры, регламентирующие 
процессы функционирования системы обработки данных, использование ее ресурсов, деятельность персонала, а также порядок взаимодействия пользователей с системой 
таким образом, чтобы в наибольшей степени затруднить или исключить возможность реализации 
угроз безопасности циркулирующей в системе информации. 
К правовым мерам защиты относятся действующие в стране законы, указы и другие нормативные акты, регламентирующие правила 
обращения с информационными ресурсами и ответственность за их 
нарушения, препятствующие тем самым неправомерному их использованию
 и являющиеся сдерживающим фактором для потенциальных 
нарушений. Технические (аппаратно-программные) средства защиты 
– различные электронные устройства и специальные программы, которые выполняют (самостоятельно или в комплексе с другими средствами) функции защиты информационных и программных ресурсов 
банка (идентификацию и аутентификацию пользователей, разграничения доступ к ресурсам, регистрацию событий, криптографическое 
закрытие информации
 и т.д.). К физическим мерам защиты относят 

73 
разного рода механические, электронные или электронномеханические устройства и сооружения, специально предназначенные для создания физических препятствий на возможных путях проникновения и доступа потенциальных нарушителей к защищаемому 
информационному и программному обеспечению и другим ресурсам 
ПО банка, а также технические средства визуального наблюдения, 
связи охранной сигнализации. Система слежения за внутренними ин
формационными потоками в банке позволяет отслеживать весь жизненный цикл стратегически важных информационных ресурсов банка 
– кто создал, изменил, где он (ресурс) хранится, кто из сотрудников 
его копировал, кому передавал по внутренней электронной почте и 
т.д.  
Основной функцией модульной подсистемы класса DLP является отслеживание утечек информационных ресурсов банка через сеть
, 
съѐмные носители данных, принтеры и т.д.  –  т.е. детектирование 
угроз нарушения параметров защиты информационного и программного обеспечения банка происходит только «в месте» соприкосновения ПО банка с внешней средой – с ГВС, а также на всех «интерфейсах-выходах»: съѐмные носители данных, факсы, принтеры. За мониторинг внутренних потоков 
конфиденциальной информации в банке 
подсистема класса DLP ответственности не несѐт. Одной из задач модульной подсистемы класса DLP является контроль работы пользователей ПО банка в глобальной сети Интернет. Целью защиты стратегически важных информационных и программных ресурсов является 
предотвращение или минимизация наносимого ущерба (прямого или 
косвенного) субъектам информационных отношений посредством 
нежелательного воздействия
 на компоненты ПО банка, а также разглашения (утечки), искажения (модификации), утраты (снижения 
степени доступности) или незаконного тиражирования информационных ресурсов, некомпетентного и некорректного использования 
программных ресурсов. Таким образом, применение только одной из 
перечисленных технологий не способно решить поставленных в работе задач обеспечения защиты информационного и программного 
обеспечения банка. 
Для обеспечения требуемого уровня защиты 
необходимо применение всех трѐх подсистем в едином комплексе. 
 
 
 
 

74 
2.2. Обеспечение надёжности и доступности 
компьютерных систем банка 
 
 
Под надежностью понимается вероятность события, состоящего 
в том, что система выполняет требуемую задачу на временном интервале  [0,t].  Доступность есть вероятность события, состоящего в том, 
что система выполняет требуемую задачу в определенный момент 
времени. В монографии рассмотрим модель без восстановления рабочей станции после сбоя и модель с восстановлением. Рассмотрим 
сначала
 случай без восстановления рабочей станции. 
Пусть (
i,j) есть состояние, в котором находится система. Индекс 
i обозначает количество работоспособных рабочих станций (принимает значения 2,1,0), индекс 
j принимает значения 1-сервер работает, 
0-сервер находится в состоянии сбоя. Считаем, что система находится в работоспособном состоянии, если сервер и хотя бы одна из рабочих станция работоспособны. Множество возможных состояний системы есть А = {(0, 1), (1,1), (1,0), (2.0), (2,1)}. Пусть 
X
t
(w), t  R
+
 есть 
случайный процесс, описывающий состояние работы системы, принимающий значения из множества А. Пусть 
i
(t) = Р (w: X
t
(w)=i), i  
{(2.1), (1,1), (0,1), (2,0), (1,0)}. Предположим, что случайный процесс 
X
t
(w) есть марковская цепь со следующей диаграммой, рис. 18. 
 
 
Рис. 18. Диаграмма марковской цепи 
 
Величина надежности 
R(t) для данной системы имеет вид 
 

75 
Диаграмма марковской цепи для системы с восстановлением 
представлена на рис. 19. 
 
 
Рис. 19. Диаграмма марковской цепи для системы с восстановлением 
 
 
 
 
 
Условие 
w
 + подразумевает, что в случае сбоя одной из рабочих станций, осуществляется мгновенный переход в «идеальное» 
состояние  (2,1).  В этом случае показатель надежности 
R(t) достигает 
максимума и его предельное значение зависит лишь от параметра 
s
среднего времени сбоя сервера.  
Далее исследуем метод обновления работы программы. Предполагаем, что с самого начала работы компьютерная система, на которой исполняется программа, находится в некотором идеальном состоянии. Вероятность сбоев в этом состоянии близка к нулю. Идеальное состояние обозначим через  «0».  Предполагаем, что пребывание 
системы в состоянии  «0»  не 
бесконечно и через некоторое время система переходит в состояние «Р», в котором вероятность сбоя уже от
76 
лична от нуля. Происходит этот переход по причине того, что процесс функционирования системы со временем деградирует и начинает происходить постепенная утечка ресурсов компьютерной системы. 
Из состояния «Р» система через некоторое время переходит в состояние  «F»,  что соответствует сбою в работе системы. Данный процесс 
можно формализовать с помощью следующей математической
 модели. Пусть 
X
t
(w),t < R
+
 есть случайный процесс со значениями во 
множестве {0, Р, F}. Предполагаем, что 
X
t
(w),t < R
+
 есть марковская 
цепь, диаграмма которой представлена на рис. 20. 
 
 
Рис. 20. Диаграмма марковской цепи 
X
t
(w),t < R
+
 
 
Пусть также процесс 
X
t
(w) однородный по времени и обладает 
марковским свойством. Обозначим 
. 
Тогда справедлива система дифференциальных уравнений Колмогорова: 
 
В силу эргодической теоремы 
 
Таким образом, имеем следующую систему уравнения для предельных вероятностей: 

77 
 
Отсюда 
 
Величина 
F
 есть предельная вероятность пребывания системы в 
состоянии сбоя. С ее помощью можно оценить надежность работы 
компьютерной системы. Если величина 
F
 велика, то это говорит о 
низкой надежности системы. Величина доступности системы определяется как 
A
  =  1  –  
F
. Далее рассмотрим модель, в которой система 
из состояния «Р» может также переходить в состояние «R», в котором 
осуществляется обновление работы системы. Пусть диаграмма переходов системы имеет вид, представленный на рис. 21. 
 
 
Рис. 21. Диаграмма переходов компьютерной системы 
 
Считаем, что система во время пребывания в состоянии  «R»  не 
функционирует. Тогда выражение для предельной 
вероятности сбоя 
системы примет вид 

78 
 
Величина доступности системы определяется как 
 
 
 
Последние выражения указывают достаточное условие, при котором метод обновления увеличивает величину предельной доступности системы. 
Моделирование работы банкомата с применением ограничений доступа к программному обеспечению банка. 
Модель общения банкомата с сервером банка построена на основе транзакций: в ходе взаимодействия с пользователем
 устройство 
банкомата накапливает вводимую информацию в специальном внутреннем списке, отправляя серверу по требованию совершения операции полный набор информации, описывающий транзакцию. Так, в 
начале работы пользователь вводит номер карты. После этого банкомат запрашивает у него  PIN-код. Как номер карты, так и введенный 
PIN-код запоминаются во внутреннем списке. Банкомат
 запрашивает 
у сервера авторизацию для карты. В случае неверного ввода  PINкода, карта возвращается. 
После успешной проверки PIN-кода клиенту становится доступно основное меню, в котором он может выбрать одно из действий: 
 забрать карту; 
 посмотреть остаток счета; 
 снять деньги со счета. 
При выборе первого пункта пользователю возвращается карта, 
и 
работа с банкоматом завершается. При выборе последнего пункта 
пользователю необходимо дополнительно выбрать одну из предопределенных сумм для снятия или ввести сумму с клавиатуры. После 
этого, как и в случае выбора второго варианта, автомат отправляет 
серверу накопленные данные. При получении ответа от сервера клиенту отображается информация о результате операции
. После этого 
банкомат вновь отображает главное меню, или клиент забирает карту. 

79 
Управление осуществляется системой взаимодействующих автоматов. Формальное описание, содержащее в себе объекты управления, источники событий и систему автоматов, приведено ниже. На 
рис. 22 приведена схема связей автоматов. 
 
 
Рис. 22. Схема связей автоматов с поставщиками событий и 
объектами управления 

80 
На рис. 23 представлен граф переходов автомата, управляющего 
банкоматом. 
 
Рис. 23. Граф переходов автомата, отвечающего за работу банкомата 
 
Рассмотрим ситуацию, когда к созданной программе изменяются требования. Пусть сценарий работы с банкоматом изменился следующим образом: «В случае неверного ввода PIN-кода он запрашивается повторно. В случае неверного ввода  PIN-кода три раза
 подряд 
работа с банкоматом принудительно завершается». 
Граф переходов автомата, отвечающего за работу банкомата, 
достаточно громоздок. Упростим его, выделив два вызываемых автомата: один для режима просмотра остатка счета, второй для режима 
снятия денег со счета. Граф переходов автомата после применения 
таких рефакторингов представлен на рис. 24. 
 

81 
 
Рис. 24. Граф переходов автомата, отвечающего за работу банкомата, 
после выделения вызываемых автоматов 
 
Граф переходов стал существенно проще для восприятия. В новом графе существует фрагмент, который нуждается в изменении: из 
состояния  3  («Авторизация») по событию ݁11  («pin  код неверный») 
совершается действие ݋1.ݖ50  («Возврат карты») и переход в состояние  50  («Завершение работы»). 
Необходимо, чтобы по событию ݁11 
карта не возвращалась, а производился выбор действия в зависимости 
от числа неверных попыток ввода PIN-кода. Получается, что следует 
некоторым образом разделить связь события ݁11 и выходного воздействия ݋1.ݖ50. Самый простой способ сделать это – осуществить перенос воздействий с переходов, ведущих в состояние  50,  внутрь этого
 
состояния. 
Граф переходов автомата, получающийся после применения такого рефакторинга, представлен на рис. 25. 
По событию ݁11 должно осуществляться ветвление в зависимости от числа попыток. Поэтому добавим в граф переходов состояние 
5  («Неверный  PIN-код»), в котором будет это ветвление осуществляться. Теперь установим конечным состоянием перехода по собы
82 
тию ݁11 добавленное состояние. Полученный граф переходов представлен на рис. 26. 
 
 
Рис. 25. Граф переходов автомата, отвечающего за работу банкомата, 
после переноса воздействия внутрь состояния 
 
При входе в состояние  5  выполняется выходное воздействие 
݋2.ݖ5  («Проверка количества попыток»). Воздействие ݋2.ݖ5 активизирует одно из двух событий: ݁26  («Повторная авторизация») или 
݁7 
(«Карта заблокирована»). В первом случае, автомат должен перейти в 
состояние  2,  во втором  –  в состояние  50.  Соответствующие изменения графа переходов легко осуществить (рис. 27). 
Полученный граф переходов удовлетворяет всем поставленным 
требованиям. Стоит отметить, что при модификации программы применялись только рефакторинги и базовые изменения, что позволило 
избежать анализа графа переходов после 
каждого проведенного изменения. 
 

83 
 
Рис. 26. Граф переходов автомата, отвечающего за работу банкомата, 
после добавления нового состояния 
 
Рис. 27. Граф переходов автомата, отвечающего за работу банкомата 

84 
3. АНАЛИЗ ДОСТОВЕРНОСТИ И ВЕРИФИКАЦИИ 
ИНФОРМАЦИИ В ИНФОРМАЦИОННОТЕЛЕКОММУНИКАЦИОННЫХ СИСТЕМАХ БАНКА 
 
 
3.1. Алгоритм анализа достоверности и верификации 
информации 
 
 
Алгоритм построения отношения полублочной симуляции между двумя моделями при анализе достоверности и верификации информации в информационно-телекоммуникационных системах КБ. В 
разделе приведена упрощённая версия алгоритма. Различные оптимизации, нацеленные на повышение эффективности, указаны в приложении А. 
При описании алгоритма используются синтаксис и семантика 
языка C++, дополненные следующим синтаксисом
, типами и вспомогательными ключевыми словами: 
 Тип  tuple  <ܶ
1
, ..., ܶ
݊
> описывает кортеж над типами ܶ
1
,  ...,  ܶ
݊
. 
Кортеж может записываться следующим образом: (ܽ
1
, ..., ܽ
݊
), где ܽ
݅
 – 
значение или переменная типа ܶ
݅
. Кортежи поддерживают операции 
присваивания и сравнения. 
 Тип  set  <  ܶ  >  описывает множество из элементов типа ܶ. Тип 
set соответствует типу  std::set  стандартной библиотеки языка  C++.  
Для краткой записи пользуемся математическими обозначениями пустого множества (∅) и операций: ∈, /∈, ∪, ∩, ∖. 
 Тип  vector  <  ܶ  >  описывает массив из элементов типа ܶ. Тип 
vector соответствует 
типу  std::vector  стандартной библиотеки языка 
C++. Для типа   vector   <ܶ> используются стандартные функции: 
push_back, pop_back, back, operator[], size. 
 Тип  list  <  ܶ  >  описывает список из элементов типа ܶ. Тип  list  
соответствует типу  std::list  стандартной библиотеки языка  C++.  Для 
типа   list   <   ܶ   >   используются стандартные функции:   push_back,   
pop_back, back, size. 
 Цикл по множеству: foreach ݔ in ܺ. Перебирает элементы множества ܺ в произвольном порядке, на каждой итерации текущий 
элемент множества ܺ сохраняется в переменной ݔ. Оценка сложности 

85 
операции зависит от структуры данных, используемой для представления множества. 
 Выбор произвольного элемента из множества: ݔ = any from ܺ. 
Записывает в переменную ݔ произвольный элемент непустого множества ܺ. В случае пустого множества ܺ выполнение оператора приводит к ошибочной ситуации. Оценка сложности операции зависит от 
структуры данных, используемой для представления множества
. 
Используемые типы: 
 тип ݁ݐܽݐܵ
1
 описывает состояния LTS ܯ
1
, 
 тип ݁ݐܽݐܵ
2
 описывает состояния LTS ܯ
2
, 
 тип ݊݋݅ݐܿܣ
1
 описывает действия LTS ܯ
1
, 
 тип ݊݋݅ݐܿܣ
2
 описывает действия LTS ܯ
2
. 
Для построения полублочной симуляции воспользуемся подходом, основанным на итеративном вычислении неподвижной точки. 
Для того, чтобы избежать построения первого приближения отношения, которое на практике требует хранения большого количества состояний, инициализировали множество ܪ «ленивым» способом. 
Строящееся множество ܪ делится на два непересекающихся подмножества: опровергнутые пары  (negatives)  и неподтверждённые пары 
(positives). 
В начале работы алгоритма пары начальных состояний первой и 
второй модели заносятся в множество неподтверждённых пар. На 
каждой итерации алгоритма проверяется гипотеза о том, что все неподтверждённые пары удовлетворяют определению полублочной симуляции. Если в ходе проверки обнаруживается, что некоторая пара 
не удовлетворяет этому определению, тогда она заносится в 
множество опровергнутых пар. Проверка прекращается, как только множества неподтверждённых и опровергнутых пар перестаёт расширяться. 
Листинг. Краткое описание алгоритма построения полублочной 
симуляции. 

86 
 

87 
 

88 
 
Функция  build  строит отношение полублочной симуляции описанным выше способом.  
Функция satisfiesDef проверяет определение полублочной симуляции для одной пары состояний, используя множества ݈݀݋ܲ и ܰ. 
Функция    satisfiesDef    использует функции    lazyHasPositive,    
buildFront1 и buildFront2.  
Функция  lazyHasPositive  проверяет наличие пары в множествах 
ܲ ∪ ݈݀݋ܲ и ܰ. Если пара присутствует в множестве ܲ ∪ ݈݀݋ܲ (множестве ܰ
), функция возвращает истину (ложь соответственно). Если же 
пара не найдена в обоих множествах, тогда это означает, что она по
89 
сещается в первый раз, и в этом случае пара заносится в множество 
неподтверждённых пар ܲ, а функция возвращает истину.  
Функции buildFront1 и buildFront2 строят множества финальных 
переходов из заданного состояния  LTS  ܯ
1
 и ܯ
2
 соответственно 
(фронты). 
В качестве верификатора моделей ПО, используемого для проверки формул темпоральной логики, выбран верификатор  Spin.  На 
вход ИТС подаются описания прототипов процессов и сетевой грамматики. По сетевой грамматике строятся модели, порождаемые нетерминальными символами грамматики. Для каждого нетерминала 
грамматики проводится поиск модели-инварианта среди моделей, 
выводимых из данного
 нетерминала. Проверка того, что модель является инвариантом, осуществляется с помощью построения полублочной симуляции. Когда для каждого нетерминала найдена модельинвариант, может быть построен инвариант проверяемого семейства 
моделей. 
В тех случаях, когда найти инвариант не представляется возможным, предлагается использовать подсистему нахождения контрпримеров по построенному отношению полублочной симуляции 
между моделями. С помощью контрпримеров могут быть обнаружены различия в поведении моделей семейства с различным числом 
процессов. 
Протокол резервирования ресурсов предоставляет механизм резервирования сетевых ресурсов для соблюдения заданного качества 
сервиса  (QoS).  Протокол реализован на транспортном уровне стека 
протоколов  TCP/IP.  Данный протокол используется для обеспечения 
определённой скорости передачи аудио- и видеотрафика от
 сервера к 
потребителю. На уровне протокола выделяются три вида взаимодействующих хостов: производители данных (senders), потребители данных  (receivers)  и маршрутизаторы  (routers).  Потребители, производители и маршрутизаторы объединены сетью. Потребители подписываются на получение данных от заданных производителей, производители рассылают данные подписанным потребителям. Подписка потребителя проводится рассылкой соответствующим производителям 
запроса на 
резервирование канала от производителя к потребителю. В 
запросе на резервирование задаются ограничения на пропускную 
способность канала и скорость реакции. При прохождении запроса 
через маршрутизатор принимается решение, есть ли у него необходимые ресурсы для поддержания качества сервиса или нет. Если ре
90 
сурсов недостаточно, маршрутизатор отсылает потребителю отказ в 
резервировании. Если ресурсы имеются, тогда маршрутизатор пересылает запрос следующему хосту. После успешного резервирования 
канала создаётся сессия и производитель отсылает данные потребителю в рамках созданной сессии до тех пор, пока одна из сторон не 
закроет сессию. 
Так как протокол находится на транспортном уровне
, предполагается, что маршруты между хостами построены на сетевом уровне. В 
протоколе используются два вида рассылки: адресная  (unicast)  и 
групповая  (multicast).  В  RSVP  предусмотрена возможность подтверждения резервирования при изменении маршрутов в сети. В общем 
случае хост-потребитель может быть и хостом-производителем. 
В протоколе определены следующие вспомогательные механизмы: классификатор пакетов  (packet  classifier),  планировщик 
пакетов 
(packet  scheduler),  механизм контроля доступа  (policy  control),  механизм контроля соединения  (admission  control).  Классификатор пакетов выбирает уровень качества сервиса и возможные пути следования 
пакетов. Планировщик пакетов определяет порядок отправки пакетов. Механизм контроля доступа определяет права пользователя на 
резервирование ресурсов в заданном объёме. Механизм контроля соединения проверяет наличие необходимых сетевых ресурсов на промежуточных узлах сети. 
В протоколе определены следующие типы сообщений, которыми обмениваются производители и потребители: 
 сообщение path рассылается производителями для оповещения 
потребителей о наличии сетевого ресурса; 
 сообщение  resv  рассылается потребителями после получения 
сообщения path с целю подписки на ресурс производителя; 
 сообщение  path_teardown  рассылается производителем для закрытия всех существующих соединений; 
 сообщение
  resv_teardown  рассылается потребителем с целью 
прекращения подписки на сетевой ресурс производителя; 
 сообщение  path_refresh  периодически рассылается производителем для проверки работоспособности установленных соединений; 
 сообщение  resv_refresh  периодически рассылается потребителем для проверки работоспособности соединения; 
 сообщение  path_error  посылается маршрутизатором в случае 
ошибки во время рассылки path; 

91 
 сообщение  resv_error  посылается маршрутизатором в ответ на 
запрос о резервировании (сообщение  resv)  в случае отсутствия необходимых ресурсов; 
 сообщение  data  рассылается производителям для передачи 
данных потребителям; 
 сообщение  resv_conf  (необязательное) рассылается потребителям для подтверждения резервирования ресурса. 
Схема взаимодействия процессов. После установления сетевых 
маршрутов (на сетевом уровне) производители рассылают сообщение 
типа path для уведомления
 потребителей о наличии сетевых ресурсов. 
Маршрутизаторы пересылают эти сообщения по дереву маршрутизации. После приёма сообщения  path  потребитель может послать в ответ запрос на резервирование ресурса  resv  с заданными параметрами 
качества сервиса. Маршрутизаторы проверяют, выполняются ли требования к качеству сервиса. Если требования не выполняются, маршрутизатор отвечает сообщением   resv_error.   В противном 
случае 
маршрутизатор пересылает сообщение следующему хосту в таблице 
маршрутизации. В случае получения сообщения  resv  производитель 
создаёт сессию для обмена данными с потребителем и начинает посылать сообщения типа data, содержащие данные для потребителя. В 
любой момент производитель, потребитель или маршрутизатор могут 
проверить работоспособность соединения с помощью сообщений типаresv_refr и  path_refr.  Производитель (потребитель) может
 закрыть 
сессию рассылкой сообщения       path_teardown       (сообщения 
refr_teardown соответственно). 
При создании модели протокола по его описанию необходимо 
провести абстракцию с учётом выбранного класса свойств. Используем модель, в которой можно проверять спецификации для производителей, потребителей и маршрутизаторов по отправке/приёму сообщений в терминах логики линейного времени. 
Ниже перечислены основные абстракции, которые
 использовались при построении модели рассматриваемого протокола. 
Сообщения. В протоколе используются два вида рассылки сообщений: адресная и групповая. При адресной рассылке каждый потребитель задаёт адрес производителя, на сообщения которого он хочет подписаться, и сохраняет в пакете свой собственный адрес. В 
случае адресной рассылки модель должна описывать адрес 
узла, при 
этом размер типа адреса растёт с числом узлов в сети. Так как метод 
не поддерживает модели с бесконечным числом состояний, адресная 

92 
рассылка из модели исключена. В модели используется групповая 
рассылка в пределах одной группы. 
Логическая топология сети. Протокол располагается на транспортном уровне и использует протоколы маршрутизации сетевого 
уровня. Так как в модели рассматривается групповая рассылка сообщений, процессы объединены с помощью дерева групповой рассылки, в корне которого располагается производитель сообщения
 (source 
based  multicast  distribution  tree).  В модели используется бинарное дерево. Однако принципиальных ограничений на моделирование дерева 
с заданной степенью ветвления (для всей топологии) в методе нет. 
Типы сообщений. В модели используются сообщения типов: 
path, resv, data, path_teardown, resv_teardown, path_refresh, resv_refresh, 
path_error, resv_error. Необязательные сообщения типа path_conf, подтверждающие успешное резервирование, не используются. 
Механизм контроля соединения. В протоколе  RSVP  описан механизм задания ограничений
 на качество сервиса с помощью фильтров. В каждом маршрутизаторе, через который проходит запрос на 
резервирование, проводится проверка возможности резервирования с 
помощью механизма контроля соединения. В модели не рассматриваются различные варианты контроля соединения. Предполагается, 
что каждому маршрутизатору всегда хватает ресурсов для выполнения запроса на резервирование. 
Сбои. Описание протокола 
предусматривает возможность изменения топологии сети и реакции на отключение маршрутизаторов. В 
модели все маршрутизаторы и каналы считаются надёжными. 
Другие абстракции. В модели не рассматривается механизм контроля доступа. Также не моделируются тайм-ауты. 
Описание модели. Модель протокола реализована на языке 
TinyPromela. В модели участвуют процессы, порождаемые из описаний прототипов  Sender  (
производитель),  Router  (маршрутизатор) и 
Receiver  (потребитель). Указанные прототипы представлены размеченными системами переходов, содержащими  9408,  24  и  126  состояний соответственно. 
Листинг. Сетевая грамматика модели RSVP (RSVPNet). 

93 
 
 
На рис.  28  приведена архитектура подсистемы построения полублочной симуляции. По описанию прототипов процессов и описанию привязки процессов к каналам на подмножестве языка  Promela  
порождается описание на промежуточном языке описания моделей 
PTY. По описанию моделей на языке PTY порождаются функции вычисления следующих состояний системы по предыдущему на языке 
C++. Сгенерированные функции собираются
 вместе с модулями построения полублочной симуляции, в результате чего создаётся исполняемый файл, настроенный на построение симуляции между двумя заданными моделями. Язык  PTY  служит низкоуровневым текстовым представлением  LTS,  в котором описываются непосредственно 
переходы процессов из одного состояния в другое. 
Основные отличия языка PTY от MDL: 
 в качестве механизма синхронизации используется 
синхронизация действий и ко-действий вместо разделяемых переменных; 
 разрядность целочисленных переменных не указывается явно, 
а вычисляется по телу процессов, так как над целочисленными типами допустимы лишь операции присваивания и сравнения; 
 наряду с целочисленными типами поддерживаются перечислимые типы. 
 

94 
 
Рис. 28. Архитектура подсистемы проверки симуляции 

95 
На языке  PTY  LTS  задаётся с помощью трёх секций: секции 
прототипов процессов, секции экземпляров процессов и секции связывания действий различных процессов. 
В секции прототипов процессов для каждого прототипа описываются локальные переменные процесса и множество переходов вида:  action:  x_1  =  u_1,  ...,  x_m  =  u_m  =>  y_1  =  v_1,  ...,  y_n  =  v_n,  где 
action соответствует обозначению действия в LTS, пары x_i = u_i, 1 ≤ 
݅ ≤ ݉, задают условие на 
значения переменных, при котором срабатывает переход, а пары y_j = v_j, 1 ≤ ݆ ≤ ݊, задают новые значения переменных в результате выполнения перехода. 
В секции экземпляров процессов задаются процессы, порождаемые с помощью описаний в прототипах. Описание процесса выглядит 
следующим образом:  p1  =  new  Proto().  Данная запись означает порождение процесса с именем p1 и телом, изоморфным
 LTS, заданной 
в прототипе Proto. 
В секции связывания действий процессов задаются пары синхронизации действий экземпляров процессов вида: p.a / q.b, где p и q 
– имена экземпляров процессов,  a  и  b  –  названия синхронизируемых 
действий. 
Листинг. Состояние распределённой системы. 
 
Функция переходов системы задаётся с помощью функций переходов процессов. Для каждого процесса  pi  задаются массивы, указанные в следующем листинге. 
Листинг. Массивы описания переходов. 
 
Данное представление позволяет быстро перебирать возможные 
переходы из заданного состояния. При этом создаваемые массивы не 
потребляют критического объёма памяти, так как системы переходов 

96 
всех процессов малы, в то время как система переходов композиции 
процессов велика. 
Переходы LTS распределённой системы вычисляются «на лету» 
с использованием массивов переходов процессов. 
Листинг Б.6. Схема генерации функции построения переходов 
«на лету» 
 
 

97 
 
 

98 
 
Аналогично функции  nextState  порождается функция  prevState,  
вычисляющая состояния, из которых можно попасть в заданное состояние по заданному действию. Функция prevState используется для 
проверки пар состояний в отношении полублочной симуляции в том 
случае, когда пара состояний заносится в множество опровергнутых 
пар. 
Благодаря использованному подходу нам удалось избежать 
предварительного построения и хранения в памяти 
графа переходов 
распределённой системы без заметной потери производительности. 
В качестве хранилища пар состояний выбрали стандартный контейнер std::set<State1, std::set<State2> > (в дальнейшем это хранилище 
называется std). Однако с ростом числа процессов в моделях потребление памяти при построении отношения симуляции росло довольно 
быстро. При запуске тестов даже на 5 процессах со 100 состояниями 
объём используемой памяти превышал
 два гигабайта. 
Из-за нехватки памяти при использовании хранилища std решили использовать одно из символьных представлений множества состояний.  
Используется реализация  dfa  из исходных кодов  Spin  версии 
4.2.7. 
Для операций над dfa верны следующие оценки сложности: 
 время выполнения операции вставки слова оценивается величиной ܱ(݇·|Σ
ܣ
|), 
 время выполнения операции удаления слова так же оценивается величиной ܱ(݇|Σ
ܣ
|), 
 время выполнения операции проверки вхождения слова в язык 
автомата оценивается величиной ܱ(݇). 
Данное представление хорошо подходит для хранения множеств 
неподтверждённых и опровергнутых пар, т.к. проверка наличия состояния в множествах проводится чаще, чем вставка и удаление. При 
этом множество состояний довольно сильно сжимается, благодаря 
разметке рёбер интервалами 
целых чисел вместо значений. В используемой реализации нам не хватает операции перебора слов автомата 

99 
для организации цикла по неподтверждённым состояниям. Для реализации перебора слов автомата мы добавляем к слову дополнительный байт  –  признак чётности итерации. При переборе слов автомата 
на итерации ݅ в языке автомата ищется произвольное слово (݅ ݀݋݉ 
2)ݓ (с признаком чётности ݅ ݀݋݉2). Если такое слово найдено, то 
слово (݅
 ݀݋݉ 2)ݓ удаляется из языка автомата, добавляется слово ((݅ 
+ 1) ݀݋݉ 2)ݓ и выдаётся слово ݓ. 
Для быстрого поиска произвольного слова в автомате переходам 
приписывается флаг empty, информирующий о пустоте языка автомата по пройденному префиксу.  
Листинг. Перебор состояний в DFA. 
 

100 
 
 
На каждом уровне автомата необходимо перебрать не более |Σ
ܣ
| 
рёбер, поэтому сложность операции поиска произвольного слова с 
заданным префиксом оценивается величиной ܱ(݇|Σ
ܣ
|), последующие 
операции удаления и вставки также занимают ܱ(݇|Σ
ܣ
|). Сложность 
функции dfa_next равна ܱ(݇|Σ
ܣ
|). 

101 
Более эффективным представлением оказалось представление 
dfa, потребляющее в экспериментах 20-30 мегабайт памяти в тех случаях, когда представление  std  требует более  2  гигабайт. Применение 
представления dfa позволило сократить и время вычисления на больших примерах.  
 
 
3.2. Верификация вычислительных систем банка 
 
 
В качестве примера предложенного метода верификации моделей разного уровня рассмотрена графовая модель абстрактного и 
структурного автоматов схемы пересчета, его схемная реализация и 
построение комплексного покрытия синтезированной схемы методом 
пересечения всех кубов вырожденных покрытий подсхем и методом 
пересечения с ограничениями. На основе комплексного кубического 
покрытия схемы был восстановлен граф переходов
 схемы и сделано 
заключение об изоморфизме графов и, следовательно, об их идентичности, что позволило сделать заключение о верификации моделей 
разного уровня. 
Для моделей одного уровня абстракции предложен метод верификации с использованием комплексных покрытий на основании 
операций  #  и ∩ кубов комплексного покрытия анализируемых схем. 
Рассмотрим применение условий необходимости и 
достаточности 
при верификации схемных решений методом моделирования. Пусть 
задана некоторая булева функция f своими покрытиями C1( f ), при f 
=  1,  и  C0(  f  )  при  f  =  0,  которые построены произвольным методом, 
например по картам Карно. Требуется верифицировать некоторое 
схемное решение для f в виде логической схемы N ( с внешним выходом  ZN  ),  спроектированной, например, эвристическим способом в 
произвольном базисе с применением методов факторизации, 
декомпозиции или их сочетания. 
Необходимым условием верификации является совпадение реакций схемы N ZN =1 (ZN = 0) для ∀ c ∈ C1( f ) ( ∀ c ∈ C0( f )). 
Достаточным условием верификации является совпадение реакции схемы ZN =0 (ZN = 1) для ∀ c ∈ C0( f ) ( ∀ c ∈ C1( f ) ). 
Таким образом необходимым и достаточным условиями верификации схемы  N  является совпадение реакции схемы  ZN  со значе
102 
ниями булевой функции  f  для всех кубов  c  ∈  C1(  f  )  ∪  C0  (  f  ).  Комплексное покрытие КР = C1( f ) ∪ C0 ( f ) и есть метамодель схемы N, 
Верификацию схемы  N  можно осуществить и другим способом, отличным от метода моделирования. 
Построим метамодель схемы для значений выхода ZN, равных 0 
и 1, в виде комплексного покрытия КР = C0(ZN ) ∪ C1( ZN ). В этом 
случае требуется установить соответствие между покрытиями
 C1( f ) 
∪ C0 ( f ) и C0(ZN ) ∪ C1( ZN), которое может быть выполнено либо с 
использованием операции вычитания кубов покрытий  (#),  либо с помощью операции пересечения кубов покрытий (∩). При использовании операции вычитания для верификации схемы  N  необходимо, 
чтобы C1( f ) # C1( ZN) = ∅, и достаточно, чтобы C1( ZN) # C1( f ) = 
∅. Аналогично для покрытий C0( f ) и C0(ZN ). Из этого следует, что 
при использовании операции вычитания 
достаточно иметь только 
один тип покрытий: либо единичное C1( f ) и  C1(  ZN),  либо нулевое 
C0 ( f ) и C0(ZN ). 
Применение алгебро-топологических операций вычитания и пересечения покрытий позволяет при сравнении множеств избежать 
точного соответствия элементов множеств между собой, поэтому C1( 
f ) # C1( ZN) и C1( ZN) # C1( f ) не соответствуют аналогам (не топологическим) обычного вычитания множеств ( А \ В и В \ А). 
Применив операции
 вычитания ( # ) и пересечения ( 
∩ ) покр
ытий при верификации объектов получим четыре возможных отношения: 
1.  C1(  f  )  #  C1(  ZN)  =  ∅ и  C1(  ZN)  #  C1(  f  )  =  ∅, или  C1(  f  )  ∩ 
C0(ZN ) = ∅ и C0( f ) ∩ C1( ZN) = ∅ - условия полной верификации. 
2.  C1(  f  )  #  C1(  ZN)  
≠ 
∅ и  C1(  ZN)  #  C1(  f  )  =  ∅, или  C1(  f  )  
∩ 
C0(ZN  )  
≠
∅ и  C0(  f  )  
∩  C1(  ZN)  =  
∅  -  есть необходимое, но недостаточное условие верификации. 
3.  C1(  f  )  #  C1(  ZN)  =  ∅ и  C1(  ZN)  #  C1(  f  )  ≠ ∅
, или  C1(  f  )  ∩ 
C0(ZN ) =∅ и C0( f ) 
∩ C1( ZN) ≠ 
∅ - есть достаточное, но не необходимое условие верификации. 
4.  C1(  f  )  #  C1(  ZN)  ≠ ∅ и  C1(  ZN)  #  C1(  f  )  ≠ ∅, или  C1(  f  )  ∩ 
C0(ZN  )  
≠
∅ и  C0(  f  )  
∩  C1(  ZN)  ≠ 
∅  -  условия верификации отсутствуют. 
Во  2-ом и 3-ем случаях можно говорить о верификации частично определенных функций (объектов) с использованием «размытых» 
множеств, иначе говоря, один объект «делает» больше, чем другой. 
Полная верификация существует только при выполнении соотноше
103 
ний  1-го случая. Данное рассуждение проведено для случая одновыходной схемы  N  и исходного покрытия булевой функции  f,  которое 
является простейшим случаем метамодели высшего ранга. 
Аналогичные методы можно применить при верификации графсхем алгоритмов, конечных автоматов (абстрактных и структурных), 
многовыходных последовательностных схем и ПО. 
На рис.  29  один и тот же вычислительный процесс реализован
 
двумя различными способами. На схеме показано, что на основании 
технических заданий (ТЗ) или разработанных программ, строятся 
ГАМ и комплексные покрытия двух рассматриваемых вычислительных процессов. Из них методом алгебро-топологического вычитания 
исключаются значения, на которых функция не определена  (don't  
care), и строятся контролирующие тесты.  
 
 
Рис. 29. Общая схема процесса верификации вычислительных 
процессов
 

104 
Предложены два способа верификации этих процессов: 
 метод алгебро-топологического вычитания покрытий каждого 
из каждого. При условии пустого значения результата делается заключение о эквивалентности данных вычислительных процессов; 
 метод построения тестовых наборов по комплексным покрытиям путем пересечения кубов из интервальных частей покрытий и 
перекрестное тестирование, по результатам которого делается
 заключение о результатах верификации. 
Рассмотрим пример верификации ациклического процесса. 
Пусть задана некоторая интервальная формула: 
 
 
 
реализующая вычисления некоторой переменной  r  по различным 
формулам:  FR1,  FR2  и  FR3  произвольного вида в зависимости от 
двух булевых переменных, задающих некоторые условия-предикаты 
в виде неравенств: a: x ≤ k1 и b: x ≥ k2. 
Переход от неравенств к булевым переменным при проектиро
вании вычислительного процесса позволяет абстрагироваться от конкретного смысла неравенств и им соответствующих условийпредикатов и рассмотреть решение задачи верификации в общем виде. 
ГАМ вычисления переменной   r   приведены на рис.   30.   На 
рис. 30,
а показана функциональная декомпозиция булевой функции f 
=  f(a,b)  с начальной вершиной условия-предиката а (ГАМ  1),  а на 
рис. 30,
б – с начальной вершиной b (ГАМ 2). 
Построим комплексные кубические покрытия C
1
(r) и C
2
(r) для 
вычисляемой переменной r по ГАМ 1 и ГАМ 2: 
 
 

105 
   
 
   
а)        б) 
Рис. 30. ГАМ вычисления интервальной формулы 
 
По покрытиям C
1
(r) и C
2
(r) построим тесты Т
1
(r) и Т
2
(r) путем 
пересечения кубов из интервальных частей покрытий C
1
(r) и C
2
(r), 
соответственно. Получим тесты: 
 
 

106 
 
 
Для формул должны выполняться условия: /FR1/ ≠ /FR2/≠ /FR3/ 
≠  p,  т.е. вычисляемые и хранимые значения должны различаться на 
разных наборах теста. Штрихами в тестах отмечены значения активно изменяемых условий-предикатов. 
С учетом удаления  ab=11  верификация по покрытиям дает C
1
  #  
C
2
  =  ∅ и C
2
#  C
1
  =  ∅, что и свидетельствует об эквивалентности вычислительных процессов. Это наглядно можно наблюдать на картах 
Карно приведенных на рис. 30. 
Перекрестное тестирование дает следующий результат: 
R
1
(T
1
)=R
2
(T
1
) и R
1
(T
2
)=R
2
(T
2
), что также подтверждает эквивалентность вычислительных процессов. Если переменную  r  вычислять по 
разным упрощенным формулам  FR1,  FR2  и  FR3,  тогда метод перекрестного тестирования является предпочтительным, так как не требует приведения выражений формул к каноническому виду. 
Далее приводятся машинно-ориентированные алгоритмы реализации основных операций по вычислению комплексных кубических 
покрытий. Алгоритм построения комплексного 
кубического покрытия представлен на рис. 31. 

107 
 
Рис. 31. Алгоритм построения комплексного кубического покрытия 
 
 
3.3. Совершенствования верификации симуляций между 
моделями программ 
 
 
Решается задача создания универсальной среды проверки симуляций между моделями программ, заданными конечными структурами Крипке. 
Определение   2.1. Структура Крипке задаётся пятёркой ܵۦ, 
ݏ
0
,ܴ,, ۧܮ, где ܵ – конечное множество состояний, ݏ
0
 ∈ ܵ – начальное 

108 
состояние, ܴ ⊆ ܵ×ܵ  –  отношение переходов,   –  множество атомарных переменных, ܮ: ܵ→2Σ – функция разметки состояний. 
Для задания спецификаций поведения программ наиболее часто 
используется темпоральная логика ветвящегося времени ܮܶܥ* и её 
фрагменты ܮܶܮ, ܮܶܥܣ*, ܮܶܥ*
ܺ
 и ܮܶܥܣ*
ܺ
. Эти логики имеют различные выразительные способности и области применения. Так, ܮܶܥ* и 
ܮܶܥܣ* позволяют описывает свойства деревьев вычислений, а ܮܶܮ — 
свойства отдельных вычислений. В логиках ܮܶܥ*
ܺ
, ܮܶܥܣ*
ܺ
 и ܮܶܮ
ܺ
 
отсутствует оператор ܺ. Данный оператор используется для задания 
свойств, которые должны выполняться в следующем состоянии вычисления. Поэтому он не применяется для описания свойств параллельных асинхронных систем, поскольку порядок выполненияпроцессов в таких системах недетерменирован. 
Бинарное отношение ⪯ на множестве структур Крипке сохраняет выполнимость формул логики , если 
для любой формулы ∈ и 
любых структур Крипке ܯ
1
 и ܯ
2
 таких, что ܯ
1
 ⪯ ܯ
2
, из ܯ
2
 |=  следует ܯ
1
 |= . 
Отношения симуляции  –  это специальная разновидность бинарных отношений на множестве моделей программ; говоря неформально, модель ܯ
2
 симулирует модель ܯ
1
, если дерево вычислений, порождённое моделью ܯ
1
, подобно некоторому фрагменту дерева вычислений, порождённому моделью ܯ
2
. Определяя по-разному подобие деревьев вычислений, можно получить большое разнообразие отношений симуляции (строгую симуляцию, прореженную симуляцию, 
...). Наибольший интерес представляют отношения симуляции, сохраняющие выполнимость формул различных темпоральных логик. 
Определение 2.2 (Строгая симуляция). Пусть даны две структуры Крипке ܯ
1
 и ܯ
2
, где ܯ
݅
 = ܵۦ
݅
, ݏ
݅
0
,ܴ
݅
,
݅
, ܮ
݅
ۧ, ݅ = 1, 2, и 
1
 = 
2
. Будем 
говорить, что между ܯ
1
 и ܯ
2
 выполняется строгая симуляция (обозначается ܯ
1
 ⪯ ܯ
2
), если существует такое ܪ ⊆ ܵ
1
 × ܵ
2
, что (ݏ
10
, ݏ
20
) ∈ 
ܪ и для любой пары (ݏ
1
, ݏ
2
)ܪ∈ выполняется: 
1. ܮ
1
(ݏ
1
) = ܮ
2
(ݏ
2
). 
2. Если (ݏ
1
, ݏ′
1
) ∈ ܴ
1
, то существует такое состояние ݏ′
2
 ∈ ܵ
2
, что 
(ݏ
2
, ݏ′
2
) ܴ∈
2
 и (ݏ′
1
, ݏ′
2
) ∈ ܪ. 
Будем говорить, что между ܯ
1
 и ܯ
2
 выполняется строгая бисимуляция, если в 
определении  2.2 отношение ܪ является симметричным (т. е. ܪ = ܪ − 1). 

109 
Определение прореженной симуляции отличается от определения строгой симуляции тем, что каждому переходу (ݏ
1
, ݏ′
1
) ∈ ܴ
1
 может соответствовать последовательность переходов ݐ
0
, ݐ
1
,  .  .  .  ݐ
݊
 (݊ ≥ 
0) в ܴ
2
, такая, что ݐ
0
=ݏ
2
,(ݏ′
1
,ݐ
݊
)ܪ∈ и для всех ݅ < ݊ выполняется (ݐ
݅
, ݐ
݅
+1
) 
∈ ܴ
2
 и (ݏ
1
, ݐ
݅
) ∈ ܪ. 
Если добавить к этому определению требование симметричности, то мы придём к определению прореженной бисимуляции. 
Строгая симуляция сохраняет выполнимость формул ܮܶܥܣ*, 
строгая бисимуляция  –  выполнимость формул ܮܶܥ*, прореженная 
симуляция  —  выполнимость формул ܮܶܥܣ*
ܺ
, прореженная бисимуляция — выполнимость формул ܮܶܥ*
ܺ
. 
Здесь преследуется цель разработки универсальной программноинструментальной среды проверки симуляций. Разрабатываемая 
среда должна состоять из двух компонент: формального языка, позволяющего описывать различные симуляции, и программноинструментального средства, которое по двум размеченным системам 
переходов и описанию симуляции проверяет, выполняется ли заданная симуляция между этими системами переходов. 
В основу универсального 
средства описания и проверки симуляций целесообразно положить теоретико-игровой подход. Этот подход годится для проверки всех известных отношений симуляции, и 
более того, во многих случаях его использование даёт оптимальные 
по сложности алгоритмы проверки симуляций. 
В теоретико-игровом подходе задача проверки симуляции сводится к задаче нахождения выигрышной стратегии в
 антагонистической игре двух игроков Spoiler и Duplicator (или для краткости ܵ и ܦ). 
Формально такая игра задаётся пятёркой ܸۦ
ܵ
, ܸ
ܦ
,ܧ
ܵ
,ܧ
ܦ
, ݒ
0
ۧ, где 
ܸ
ܵ
 и ܸ
ܦ
  –  множества состояний игроков  Spoiler  и  Duplicator  соответственно,ܧ
ܵ
 ܸ⊆
ܵ
×ܸ
ܦ
 и ܧ
ܦ
 ⊆ ܸ
ܦ
×ܸ
ܵ
 – множества допустимых ходов, ݒ
0
 
∈ ܸ
ܵ
  –  начальное состояние. История игры  –  это такая конечная или 
бесконечная последовательность игровых состояний (ݒ
0
, ݒ
1
, ݒ
2
,  ...),  
что (ݒ
݅
, ݒ
݅
+1
) ∈ ܧ
ܵ
ܧ∪
ܦ
 для любого ݅ ≥ 0. Cтратегией игрока Duplicator – 
это функция ܹ : ܸ
ܦ
 → ܸ
ܵ
 ∪{ݐ݈݄ܽ}. 
История игры (ݒ
0
, ݒ
1
, ݒ
2
,  ...)  удовлетворяет стратегии ܹ игрока 
Duplicator, если для любого состояния ݒ
݅
 ∈ ܸ
ܦ
 из истории игры, за исключением, возможно, последнего, выполняется ݒ
݅
+1
  =  ܹ(ݒ
݅
), а для 
последнего состояния (если история игры конечна) выполняется 
ܹ(ݒ
݅
)  =  ݐ݈݄ܽ. Игрок  Duplicator  выигрывает в игре, если у него существует стратегия, для которой любая удовлетворяющая ей история 

110 
игры либо является бесконечной, либо завершается состоянием игрока  Spoiler.  Игры проверки симуляции проектируются таким образом, 
что выполнимость отношения симуляции равносильна существованию выигрышной стратегии игрока Duplicator в соответствующей игре проверки симуляции. 
Различные варианты игр для проверки многих отношений симуляции имеют много общего. В них всегда участвуют два игрока и 
условия
 выигрыша совпадают (один игрок выигрывает, если другой 
игрок не может сделать ход). Игровые состояния представляются 
кортежами, компонентами которых являются компоненты моделей. 
Множества допустимых ходов могут быть описаны булевыми формулами над фиксированной сигнатурой. Это наблюдение было использовано для создания теоретико-игрового языка задания симуляций. 
Определение некоторого отношения на этом 
языке представляет собой описание правил игры для проверки этого отношения и включает 
в себя описание устройства игровых состояний и правил, по которым 
игроки совершают свои ходы. 
Самый простой вид имеет определение правил игры проверки 
строгой симуляции. Предположим, что необходимо проверить симуляцию между ܯ
1
 и ܯ
2
, где ܯ
݅
  =  ܵۦ
݅
, ݏ
݅
0
,ܴ
݅
,
݅
, ܮ
݅
ۧ. Состояния игроков 
Spoiler и  Duplicator  в этой игре представляются кортежами, состоящими из одного состояния из ܵ
1
 и одного состояния из ܵ
2
, т. е. ܸ
ܵ
 = ܸ
ܦ
 
= {(ݏ
1
, ݏ
2
)|ݏ
1
 ∈ ܵ
1
ݏ∧
2
 ∈ ܵ
2
)}. Если состояния игрока ܲ описывается парой значений типизированных переменных ݔ
1
ܲ
 и ݔ
2
ܲ
 (ݔ
ܲ݅
 принимает 
значения из ܵ
݅
), то допустимые переходы игроков описываются формулами 
 
Поэтому множества ходов будут иметь следующий вид: 
ܧ
ܵ
 = {((ݏ
1
, ݏ
2
), (ݏ′
1
, ݏ
2
))|(ݏ
1
, ݏ′
1
) ∈ ܴ
1
} и ܧ
ܦ
 = {((ݏ
1
, ݏ
2
), (ݏ
1
, ݏ′
2
))|(ݏ
1
, 
ݏ′
2
) ܴ∈
2
 ∧ ܮ(ݏ
1
)  =  ܮ(ݏ′
2
)}. Начальное игровое состояние полагается 
равным ݒ
0
 =(ݏ
10
, ݏ
20
). 
Всего на разработанном языке были записаны правила проверки 
следующий отношений: строгой симуляции и бисимуляции, прореженной симуляции и бисимуляции, слабой симуляции (сохраняющей 
выполнимость формул ܮܶܮ
ܺ
), ݇
2
 симуляции (сохраняющей выполнимость формул ܮܶܮ). В работе доказана корректность игр для проверки 

111 
прореженной симуляции и бисимуляции, корректность игр для проверки остальных симуляций была доказана ранее в литературе. 
Алгоритм проверки симуляций реализован по двум конечным 
структурам Крипке и по отношению симуляции, заданном на разработанном языке, проверяет выполнимость этого отношения между 
этими моделями. В алгоритме последовательно проводится построение множества достижимых состояний игры
, построение множества 
выигрышных для игрока Spoiler состояний и проверка начального состояния на принадлежность этому множеству. Разработанный алгоритм является символьным, т.е. для повышения эффективности в нём 
проводятся операции над формулами, характеризующими множества, 
а не над отдельными элементами этих множеств. Доказана корректность приведённого алгоритма. 
Разработано универсальное программно-инструментальное 
средство 
проверки симуляций между парами структур Крипке. Данное средство реализовано на языке  Python.  В качестве языка задания 
моделей используется язык широко используемого верификатора 
NuSMV. Для представления формул в символьном алгоритме были 
использованы упорядоченные двоичные разрешающие диаграммы 
(OBDD). В равной мере для символьного представления моделей и 
игры могут быть использованы и другие математические конструк
ции: регулярные выражения, прямое формульное представление и др. 
OBDD были выбраны ввиду широкой распространённости библиотек 
для манипуляции с ними. В качестве библиотеки работы с OBDD используется библиотека Cudd. 
В инкрементальном методе последовательно строятся модели 
ܯ
1
,  ...,  ܯ
݊
 так, что каждая следующая модель является уточнением 
предыдущей модели и содержит больше подробностей о конструируемой программе. Такой способ построения помогает избежать ошибок при построении моделей. Чтобы убедиться, что ܯ
݅
+1
 уточняет ܯ
݅
, 
достаточно проверить, что между этими моделями выполняется некоторое отношение симуляции (которое выбирается исходя из характера отличий между ܯ
݅
+1
 и ܯ
݅
). Если же это отношение симуляции не 
выполняется, то контрпример, выданный средством проверки симуляций, поможет найти ошибку в модели ܯ
݅
+1
. 
Инкрементальный подход был применён для решения задачи 
справедливого разделения ресурсов в системе асинхронных взаимодействующих процессов (задача “обедающих философов”). Всего 
были построены три модели. В модели ܯ
1
 не накладывалось никаких 

112 
ограничений на действия процессов (философов). В модели ܯ
2
 появляется маркер; каждый философ может получить маркер только когда 
вилки слева и справа от него лежат на столе. После того, как философ 
получил маркер, он может взять вилки и начать есть; после того как 
он закончил есть, он освобождает маркер. В окончательной модели 
ܯ
3
 маркер движется строго по кругу, и каждый философ обязан закончить есть прежде, чем он передаст маркер своему соседу. 
Исходя из характера отличий между моделями был сделан вывод о том, что между ܯ
2
 и ܯ
1
 должно выполнятся отношение строгой 
симуляции, а между ܯ
3
 и ܯ
2
  –  отношение прореженной симуляции. 
Справедливость этих отношений была проверена при помощи разработанного средства для систем с различным количеством обедающих 
философов. 
Далее решается задача разработки алгоритма проверки симуляции между временными игровыми автоматами. 
Будем использовать запись ࣜ(ܺ) для обозначения множества 
формул над множеством ܺ, удовлетворяющих грамматике ߶ ::= ݔ ∼ ݇ 
| ∧, где ݇ ∈ Z≥0, ܺ∈ݔ и ∼ ∈{<,≤,=, >, ≥}. Будем использовать запись 
ܺ
ܻ
 для обозначения множества всех отображений из множества ܺ в 
множество ܻ (это расходится с традиционной записью ܻ
ܺ
). Оценка 
переменных из ܺ  –  это элемент R
ܺ
≥0. Пусть ߜ ∈ R≥0, тогда будем 
обозначать ݒ  +  ߜ такую оценку, что для всех ݔ ∈ ܺ выполняется 
(ݒ+ߜ)(ݔ) = ݒ(ݔ)+ߜ. Пусть ܻ ⊆ ܺ, тогда будем использовать запись ݒ[ܻ 
] для обозначения оценки, сопоставляющей 0 всем ݔ ∈ ܻ , и ݒ(ݔ) всем 
ܻ∖ܺ∈ݔ . 
Определение 3.1. 
Временной автомат (timed automata, TA) – это 
шестёрка ܵۦ, ݏ
0
,ܺ,,ܴ,  Invۧ, где ܵ  –  конечное множество дискретных 
состоянияй, ݏ
0
ܵ∈  –  начальное дискретное состояние, ܺ  –  конечное 
множество вещественных переменных (таймеров),   –  множество 
пометок переходов (действий), включающее в себя так называемое 
невидимое действие ߬, ܵ⊆ܴ×ࣜ(ܺ)××℘(ܺ)×ܵ  –  конечное множество 
переходов (℘(ܺ) – множество всех подмножеств ܺ), Inv : ܵ → ࣜ(ܺ) — 
функция, сопоставляющая дискретным состояниям формулы (такие 
формулы называются
 инвариантами). 
Семантика временного автомата определяется размеченной системой переходов (ܳ, ݍ0,→), где ܳ = ܵ × R
ܺ
≥0, ݍ0 = (ݏ
0
,Ԧ0). Из состояния ݍ
1
 существует дискретный переход по действию ܽ в состояние ݍ
2
 
(обозначается                  ),                  если существует такой переход ݁ = (ݏ, ݃, ܽ, 

113 
ܻ, ݏ′) ∈ ܴ, что ݒ |= ݃, ݒ′ = ݒ[ܻ ] и ݒ′ |= Inv(ݏ′). Из состояния ݍ
1
 = (ݏ, ݒ) 
существует задержка по времени ߜ в состояние ݍ
2
 = (ݏ, ݒ′) (обозначается                 ),                 если ݒ′ = ݒ + ߜ и ݒ′ |= Inv(ݏ). 
Для простоты будем полагать, что временные автоматы детерменированы по действиям, т. е. для любой пары ݍ ∈ ܳ и ܽ ∈  существует не более одного такого ݍ′, что             .             Временной игровой автомат  (timed  game  automata,  TGA)  –  это временной 
автомат, в котором множество действий  разбито на множество контролируемых 
(
ܿ
) и множество неконтролируемых (
ݑ
) переходов. Стратегия с нулевой памятью контроллера (соответственно, среды) – это функция ݂, 
определённая на множестве состояний ܳ, и возвращающая некоторый 
элемент множества (R≥0×
ܿ
) (соответственно, (R≥0 × 
ݑ
)). 
Определение  3.5. Пусть дан  TGA  ܵۦ, ݈
0
,,ܺ,ܴ, Invۧ, и пусть (ߜ
ܿ
, 
ܽ
ܿ
) и (ߜ
ݑ
, ܽ
ݑ
)  –  некоторые стратегии контроллера и среды соответственно. Вычисление  
 
будем называть порождённым этими стратегиями, если для любого ∈݅N выполняется 
݅ߜ
 = min(ߜ
ܿ
(ݍ
2
݅
), ߜ
ݑ
(ݍ
2
݅
)) и: 
 
Аналогично определяются понятие стратегии для недетерменированных по действиям временных игровых автоматов, в этом случае 
стратегия будет возвращать не пометки, а переходы. 
Определена логика ATCTL, используемая для описания свойств 
временных игровых автоматов. Эта логика состоит из формул вида 
ߪܣ
1
ܷ
ݐ
ߪ
2
 и ߪܣ
1
ܹ
ݐ
ߪ
2
, где ∈ݐZ≥0 ∪ {+
∞}, а 
ߪ
1
 и ߪ
2
 – некоторые множества видимых действий. Будем говорить, что вычисление ߨ временного автомата ܯ удовлетворяет формуле ߪ
1
ܷ
ݐ
ߪ
2
, если существует такой префикс этого вычисления ߨ′, что все видимые действия ߨ′ лежат 
в множестве ߪ
1
, последнее действие ߨ′ лежит в ߪ
2
 и длительность ߨ′ 
не превышает ݐ. Вычисление ߨ временного автомата ܯ удовлетворяет 
формуле ߪ
1
ܹ
ݐ
ߪ
2
, если это вычисление удовлетворяет формуле ߪ
1
ܷ
ݐ
ߪ
2
, 
или все видимые действия ߨ принадлежат множеству ߪ
1
. Будем говорить, что формула ܣ логики ܮܶܥܶܣ выполняется на  TGA  ܯ, если 
существует такая стратегия контроллера ݂
ܿ
, что для любой стратегии 

114 
среды ݂
ݑ
 формула  выполняется на вычислении, порождённом стратегиями ݂
ܿ
 и ݂
ݑ
. 
Задача, которая решается в данной главе, заключается в определении отношения ⪯, сохраняющего выполнимость формул логики 
ܮܶܥܶܣ, и разработке алгоритма проверки этого отношения. На основании обзора сделан вывод о том, что в качестве искомого отношения 
следует использовать “комбинацию” определений временной, игровой и ослабленной отношений симуляции, описанных ранее в 
литературе. 
Определение 3.7 (twa-симуляция). Пусть даны два TGA ܯ
1
 и ܯ
2
 
с множествами состояний ܳ
1
 и ܳ
2
, где ܯ
݅
  =  ܵۦ
݅
, ݏ
݅
0
,ܺ
݅
,
݅
,ܴ
݅
,  Inv
݅
ۧ. Будем говорить, что между ܯ
1
 и ܯ
2
 выполняется отношение слабой 
альтернирующей временной  (timed  weak  alternating,  twa)  симуляции, 
если существует такое отношение ܪ ⊆ ܳ
1
 ×ܳ
2
, что пара начальных 
состояний (ݍ
10
, ݍ
20
) находится в этом отношении и для любой пары 
(ݍ
1
, ݍ
2
) ∈ ܪ и для любых ݍ′
1
 ∈ ܳ
1
, ݍ′
2
 ∈ ܳ
2
, ߜ ∈ R≥0,ܽ ∈ ∖{߬} выполняются следующие требования: 
1. Если                     ,                     то существует такое ݊≥1 и такая последовательность состояний  автомата ܯ
1
, что 
,                                                      и при этом для всех ݅  =  
2..݊−1 выполняется  и                        .                        
2. Если                    ,                    то существует такое ݊≥1 и такая последовательность состояний  автомата ܯ
2
, что 
,                                                        и при этом для всех 
݅=2..݊−1 выполняется                           .                           
3. Если                 ,                 то (ݍ
1
, ݍ′
2
) ∈ ܪ. 
4. Если                 ,                 то (ݍ′
1
, ݍ
2
) ∈ ܪ. 
5. Если               ,               то существует такое ݍ′′
1
 ∈ ܳ
1
, что  и 
(ݍ′′
1
,ݍ′
2
)ܪ∈ 
Ранее доказано, что введённое отношение twa-симуляции сохраняет выполнимость формул логики ܮܶܥܶܣ. 

115 
Разработан теоретико-игровой алгоритм проверки     twaсимуляции и доказана его корректность. Поскольку в общем случае 
множество состояний временных автоматов бесконечно, то бесконечна и игра проверки симуляции. Поэтому в разработанном алгоритме 
ведётся работа не над отдельными игровыми состояниями, а над 
формулами, описывающими потенциально бесконечные множества 
состояний. Для операций над такими формулами используется
 аппарат матриц ограниченных разностей (difference bounded matrixes). 
Осуществлено экспериментальное исследование реализации 
разработанного алгоритма twa-симуляции для решения задачи синтеза алгоритма работы контроллера в системе автоматического управления. 
Рассмотрим следующий пример. Пусть имеется движущийся 
конвейер, на который ставится изделие. Затем изделие движется по 
конвейеру и последовательно проходит ܰ этапов обработки, каждый 
этап занимает 
от 1 до 2 единиц времени. Задача контроллера – после 
завершения последнего этапа переместить готовое изделие с конвейера в коробку. Если этого не произойдёт в течение 2ܰ +2 единиц времени с начала работы конвейера, то изделие будет потеряно, и, таким 
образом, задача контроллера не будет выполнена. Данная система 
описывается TGA S, изображённом на рис. 32 слева
. Сплошными дугами обозначены контролируемые переходы, а прерывистыми  –  неконтролируемые. 
 
 
Рис. 32. Временные автоматы, на которых проводилось 
экспериментальное исследование разработанного алгоритма 
 
Задача контроллера в автомате S – перевести автомат в дискретное состояние ܹ݊݅, т. е. обеспечить выполнимость формулы 

116 
ܣ{ݐݔ݁݊}ܷ{݇ܿ݅݇}. Одна из возможных выигрышных стратегий контроллера ݂
ܿ
 – подождать, пока автомат перейдёт в дискретное состояние ݕܴ݀ܽ݁, а затем выполнить переход в состояние ܹ݊݅. Предположим теперь, что в реальной ситуации контроллеру неизвестно текущее положение изделие на конвейере. Тогда стратегия ݂
ܿ
 не может 
использоваться в моделируемой (реальной) ситуации. 
Поэтому была построена другая модель A, изображённая на рис. 
13 справа. Эта модель уже не содержит невидимую контроллеру информацию, и для неё у контроллера существует выигрышная стратегия (её можно автоматически построить при помощи средства 
UPPAAL Tiga). Для того, чтобы проверить, что та же стратегия 
будет 
выигрышной и для исходной модели, достаточно проверить существование twa-симуляции между S и A. Корректность такого сведения 
была доказана в теореме. Существование twa-симуляции между S и A 
было проверено для нескольких значений ܰ. 
Взаимное исключение с помощью мьютекса. Мьютекс (одноместный семафор) является одним из наиболее часто используемых 
на практике примитивов синхронизации, позволяющим обеспечивать
 
монопольный доступ клиентов к разделяемому ресурсу. Приводится 
представленное ниже описание модели мьютекса на языке Promela. 
 
Пусть требуется проверить, позволяет ли данная структура гарантировать каждому клиенту доступ к разделяемому ресурсу. Более 
формально: необходимо установить выполнимость свойства «каждый 
клиент рано или поздно получит доступ к ресурсу, защищенному 
мьютексом». 

117 
Предложенная задача может быть решена в ИС SPIN путем проверки достижимости циклов без прогресса. Для верификации использовалась следующая последовательность команд. 
 
Результат верификации представлен на рис. 33. 
 
 
Рис. 33. Результат верификации в ИТС SPIN 
 
По описанию на языке  Promela  была построена эквивалентная 
структура Крипке, изображенная на рис.  34.  Атомарным предикатом 
a отмечено состояние, в котором доступ к ресурсу получает третий 
процесс. 
Желаемое поведение описывается   LTL-формулой 
Fa (когданибудь в будущем третий клиентский процесс обязательно получит 
доступ к ресурсу). Невыполнение спецификации будет означать, что 
существует как минимум одна последовательность состояний, на которой требуемое событие не происходит. И если такая траектория 
существует, то, следовательно, и существуют аналогичные траектории, на которых доступ к ресурсу не получают первый 
и второй процессы. 

118 
 
Рис. 34. Эквивалентная описанию структура Крипке 
 
Сформированная на основе структуры Крипке и спецификации 
база знаний подавалась на вход программной реализации МЛВ. Полученные результаты представлены на рис. 35. 
Применение как ИС SPIN, так и предлагаемого в работе подхода 
показали несоответствие модели и спецификации. Таким образом, 
может быть сделан вывод о том, что исследуемая 
реализация мьютекса не позволяет гарантировать клиентам доступ к ресурсу. Для устранения ошибки необходимо ввести дополнительную  FIFO-подобную 
структуру для размещения запросов от клиентских процессов. 
Алгоритм работы сетевого генератора данных. Используется 
модель алгоритма, циклически генерирующего через фиксированный 
временной промежуток сообщение одного из двух возможных типов 
и отправляющего данное сообщение получателю через
 буферизированный канал. 

119 
 
Рис. 35. Результат верификации с помощью МЛВ 
 
Описание модели на языке Promela представлено ниже. 
 
Нежелательным поведением генератора является ситуация, при 
которой канал оказывается заполнен сообщениями первого типа. То 
есть, корректное поведение предполагает, что рано или поздно генератор отправит сообщение второго типа, а переменная  x  примет истинное значение. Для верификации в ИС
  SPIN  применялась следующая последовательность команд. 

120 
 
Результат верификации представлен на рис. 36. 
 
 
Рис. 36. Результат верификации в ИТС SPIN 
 
Эквивалентная описанию на языке  Promela  структура Крипке 
изображена на рис. 37. 
Как и в предыдущем примере, корректное поведение описывается LTL-формулой 
Fx. Сформированная на основе структуры Крипке и 
спецификации база знаний подавалась на вход программной реализации МЛВ. 
Полученные результаты представлены на рис. 38. 
ИТС SPIN и предлагаемый логический подход показали, что модель не соответствует спецификации. 
 

121 
 
Рис. 37. Эквивалентная описанию структура Крипке 
 
 
Рис. 38. Результат верификации с помощью МЛВ 
 

122 
Алгоритм планирования  sleep-wakeup. В работе рассматриваются реализации нескольких процедур ядра распределенной операционной системы  UTS.  Предложено представленное ниже описание 
модели алгоритма работы планировщика этой операционной системы. 
 
 

123 
 
Одним из основных требований, предъявляемых к планировщику, является недостижимость ситуации голодания, при которой клиентский процесс всегда будет находиться в состоянии 
Wakeme. Для 
верификации в ИС SPIN применялась следующая последовательность 
команд, рис. 39. 
 
 
 
Рис. 39. Результат верификации в ИС SPIN 
 
По описанию алгоритмов работы процессов 
Client и Server были 
построены изображенные на рис.  40  структуры Крипке. Атомарным 
предикатом  a  отмечены состояния клиентского процесса, в которых 
выполняется условие State == Wakeme. 

124 
 
Рис. 40. Эквивалентные процессам структуры Крипке 
 
Модель, соответствующая исследуемому алгоритму планирования, была сформирована путем построения асинхронной композиции 
представленных структур и последующего исключения недостижимых состояний. Граф полученной структуры Крипке содержит  83  
вершины. 
Предъявляемое требование может быть выражено с помощью 
LTL-формулы 
GFa (для каждого состояния модели всегда в будущем будет достижимо состояние, в котором клиентский процесс 
функционирует). На рис.  41  представлены результаты верификации 
алгоритма с помощью МВОЭ. 
 

125 
 
Рис. 41. Верификация с помощью МЛВ 
 
Результаты, полученные в ИС SPIN и в программной реализации 
МЛВ, совпали с точностью до контрпримера. Исследуемый алгоритм 
не отвечает предъявляемому требованию  –  возможна ситуация, при 
которой клиентский процесс перейдет в состояние Wakeme и не выйдет из этого состояния в дальнейшем. Для устранения ошибки необходимо обеспечить атомарное 
выполнение смены состояния клиентского процесса и установки флага запроса на пробуждение. 
 
  

126 
4. АВТОМАТИЧЕСКИЙ АНАЛИЗ БЕЗОПАСНОСТИ 
ПЛАТЕЖНЫХ ПРОТОКОЛОВ 
 
4.1. Протоколы бесконтактных платежей по банковским 
картам 
 
В последние годы бесконтактные банковские карты получили в 
мире широкое распространение. По оценкам Всемирного банка, к 
концу  2020  года было задействовано около  900  миллионов бесконтактных кредитных карт и  1300000  бесконтактных считывающих 
устройств. Однако не все платежные протоколы, используемые этими 
банковскими картами, являются безопасными. В независимом исследовании [54] был изучен набор из 20 бесконтактных 
банковских карт 
от нескольких платежных организаций и   111   крупных банковэмитентов в США. Исследование обнаружило уязвимости безопасности разной степени во всех 20 картах. 
Эксперимент Хейдта-Бенджамина и др.  [43]  проводился со считывающими устройствами банковских карт от двух независимых 
производителей. Бесконтактные карты связываются со считывающими устройствами через транспортный уровень IS014443-B [58]. Электронные данные
 карты были захвачены, и сообщения, передаваемые 
между картой и считывателем, были получены из последовательного 
порта считывателей. Затем выходные данные были визуализированы 
в формате магнитной полосы  IS07813  [59],  а протоколы оплаты, используемые банковскими картами, были преобразованы в обратную 
инженерию. 
На основании полученных данных протоколы, используемые 20 
банковскими картами, были разделены на четыре категории. 
Далее 
формально смоделируем два из них и покажем выполнение этих двух 
протоколов и их атак. 
Протокол оплаты банковской картой запускается, когда бесконтактная банковская карта касается считывающего устройства. Считыватель пересылает информацию о карте и строку описания транзакции  M  на внутренний сервер, который затем проверяет согласованность информации и, если он
 удовлетворен, сообщает шлюзу биллинга. Поскольку считыватель и внутренний сервер часто совместно используют безопасный канал связи, такой как TLS [57], а считыватель 
просто пересылает полученную информацию, то опустим явное мо
127 
делирование считывателя. Вместо этого предполагаем, что бесконтактная банковская карта напрямую взаимодействует с платежным 
сервером с 
M как часть передачи сообщения. Принимая это упрощение, теперь предоставляем высокоуровневые описания двух протоколов бесконтактных платежей, типа 
A и типа B, из [54]. 
I. Протокол карты 
A: этот тип карты всегда отправляет считывающему устройству набор статической информации, которая содержит его основной номер счета (PAN), имя держателя карты и дату истечения срока действия. Пример последовательного вывода коммерческого считывателя с этим типом карты: 
 
Bxxxxxx7532xxxxxx^Erok/Victor ^2106101000000000000000000000000000858000000 
xxxxxx7532xxxxxx=21061010000085800000 
 
Первая строка  –  это сообщение, содержащееся на основной памяти карты; вторая строка содержит почти ту же информацию и 
представляет собой вторую запись в дополнительной памяти карты. 
Здесь  «xxxxxx7532xxxxxx»  –  это номер  PAN,  «
Erok/Victor»  –  имя 
держателя карты, а «2106» – срок действия. Пусть данные владельца 
карты (ДВК) будет термином, который представляет собой комбинацию  PAN,  имени держателя карты и даты истечения срока действия. 
Предполагаем, что оставшаяся строка является подписью банкаэмитента над всеми данными держателя карты. Делаем упрощающее 
предположение, что платежный сервер 
Se отвечает за выпуск банковских карт. У 
Se имеется открытый и закрытый ключи {k
se.open
, k
se.lock
}. 
Формализация нашего сообщения следующее: 
 
M.ДВК.r
v
((ДВК), Se), 
 
где 
r
v 
– симметричное шифрование; (ДВК)  –  краткое сообщение на 
основе хеширования. 
Короткое сообщения: (ДВК). Пусть переменная ДВК представляет сообщение. Определите функцию (ДВК) как короткое сообщения ДВК, вычисленный с использованием криптографической хэшфункции [55, 56]. Предполагаем, что платежный терминал использует 
идеальное хеширование: 
1. Если (ДВК
1
  ДВК
2
), тогда ((ДВК
1
)  (ДВК
2
)). 
2. Учитывая (ДВК), невозможно восстановить ДВК, 

128 
3.  Пусть f – любая функция, тогда, если (ДВК  f (ДВК)), тогда 
((ДВК)  ( 
f (ДВК))). 
M.ДВК.r
v
((ДВК), Se) представляет собой объединение простого 
текста ДВК и подписи его хеша. Поскольку ДВК передается в открытом виде, этот протокол явно подвержен атаке с перехватом. Более 
того, у этого типа карт нет компонента изменчивости – он всегда отправляет одну и ту же строку при общении со считывателем. Следовательно, он также 
подвержен атаке повторного воспроизведения. 
Наконец, 
M не подписан, поэтому протокол уязвим для атак вырезания и вставки. 
II. Протокол карты 
B: 
Этот тип карты по-прежнему отправляет данные владельца карты (ДВК) в открытом виде. Тем не менее, он значительно повысил 
свою безопасность, сохраняя значение счетчика, которое монотонно 
увеличивается при каждом нажатии. Пример последовательного вывода для этого типа карты при обмене данными со считывателем: 
 
Bxxxxxx3272xxxxxx^ Erok/Victor ^2106101100000000000100000000000 
xxxxxx3272xxxxxx=21061011000001800431 
 
В этом примере выходных данных «
0043»  –  это значение счетчика, которое увеличивается при каждой банковской транзакции. Это 
обеспечивает изменчивость каждого сообщения о транзакции. Три 
предшествующие цифры «018» изменяются при каждой транзакции 
(пин код, получаемый от банка), и предполагается, что они являются 
подписью над ДВК и значением счетчика. В этом случае предполагаем, что платежный сервер сохраняет
 сопоставление каждого ДВК с 
его последним значением счетчика, которое видел сервер. Более того, 
платежный сервер использует уникальный симметричный ключ  k  с 
каждой картой, которая идентифицируется ДВК. Формализованное 
сообщение: 
 
M.ДВК.C.w(ДВК.C, k) 
 
где 
C  –  конкретное значение счетчика, а w(ДВК.C, k)  –  код аутентификации сообщений на основе хеша через ДВК.
C с использованием 
ключа 
k. 
Поскольку протокол карты 
A всегда отправляет одно и то же 
статическое сообщение, он уязвим для атак повторного воспроизве
129 
дения. Один из шагов, предпринимаемых платежным сервером после 
получения сообщения от бесконтактной карты и специфической для 
транзакции полезной нагрузки 
M, – это проверка этой информации на 
актуальность и согласованность. В этом протоколе имеется три принципала: банковская карта (
Bc), платежный сервер (Se) и биллинговый 
шлюз (
Bi), который обрабатывает транзакции для выставления счетов. Предполагаем, что канал между 
Se и Bi безопасен, и тем самым 
опускаем моделирование бесконтактного считывателя, поскольку он 
только добавляет информацию описания транзакции 
M и отправляет 
все на платежный сервер. Диаграмма последовательности  UML  протокола карты типа 
A представлена на рис. 42. 
 
 
Рис. 42.
 Схема последовательности UML для протокола 
бесконтактных платежей типа A 
 
Первоначальные предположения  -  это признание того, что 
Se 
имеет собственные открытые и закрытые ключи. 
Se моделируются в 
виде двух формул: 
 
Se  (Se, k
se.open
); 
Se  (Se, k
se.lock
), 
 
где (
Se, k
se.open
) – k
se.open
 является открытым ключом Se; (Se, k
se.lock
) – 
k
se.lock
 является закрытым ключом Se. 
Набор предварительных условий     –     это набор целей 
безопасности, которые, как ожидается, будут достигнуты перед 
каждым этапом обмена сообщениями. Приведем возможный список 
целей и кратко обсудим, как их можно формализовать. Рассмотрим 
совокупность предварительных условий, которые 
Se устанавливает 
перед взаимодействием с биллинговым шлюзом 
Bi. Предположим, Se 
получил 
M.ДВК.r
v
((ДВК), Se). Прежде чем Se отправит сообщение 
на сервер биллинга, необходимо выполнить ряд требований 
безопасности. 

130 
1а. Se должен полагать, что ДВК представляет собой 
информацию о карте, выпущенной 
Se. Мы моделируем это, заявляя, 
что 
Se однажды изготовил ДВК: 
 
Se  G(ДВК, Se), 
 
где G (ДВК, 
Se) – Se один раз произнес (изготовил) ДВК. 
 
2а. 
Se необходимо убедиться, что ДВК не поврежден, поскольку 
он был изготовлен 
Se. Именно этот ДВК изготовил Se: 
 
Se  (ДВК, Se), 
 
где  – целостность сообщения. 
 
3а. 
Se необходимо убедиться, что транзакция  M.ДВК должна 
была быть совершена 
Bc. Сделка, представленная приобретенными 
товарами 
M и финансовым инструментом, используемым для оплаты 
ДВК, была инициирована 
Bc, а не каким-либо другим принципалом:  
 
Se  G(M.ДВК, Bc). 
 
То есть 
M.ДВК произнес Bc. 
4а. Запрашивается именно эта транзакция  M.ДВК, а не какойлибо другой 
M.ДВК: 
 
Se  (M.ДВК, Bc). 
 
5а. 
Se необходимо убедиться, что запрос транзакции был 
последним. 
Se должен быть в состоянии исключить любую атаку 
повторного воспроизведения, в которой старый запрос транзакции 
был записан в атаке подслушивания и повторно отображен здесь. 
Формализуем это требование как следующее убеждение 
Se: 
 
Se  #(M.ДВК), 
 
где # – изменение (#(
M.ДВК) – изменение M.ДВК). 
 

131 
Здесь для простоты опускаем постусловия, которые обычно 
включают требования к оплате, такие как неотказ от авторства. 
Протокол бесконтактных платежей типа 
A, представленный на 
рис.  42,  позволяет надежно реализовать только первый и второй 
пункты безопасности (смотри выше:  1а,  2а). Третий, четвертый и 
пятый пункты безопасности  (3а,  4а,  5а) не могут быть надежно 
реализованы по протоколу 
А. В частности, третий    (3а) не 
выполняется, потому что сообщение 
M.ДВК не было подписано Bc; 
четвертый  (4а) не работает по той же причине; и пятый  (5а) не 
функционирует, потому что в 
M.ДВК нет компонента изменчивости. 
Протокол для банковской карты типа 
B использует счетчик C и 
симметричное шифрование, а также код аутентификации сообщений 
на основе хеша. Предполагаем, что 
Se знает последнее значение 
счетчика, связанного с данной банковской картой. Диаграмма 
последовательности UML этого протокола представлена на рис. 43: 
 
 
Рис. 43. Схема последовательности UML для протокола 
бесконтактных платежей типа B 
 
Предположим, что 
Bc имеет общий симметричный ключ k с Se. 
Ключ 
k уникален для Bc и Se, и ни Bc, ни Se не используют тот же k 
для других приложений. Более того, 
Se знает, является ли значение 
счетчика 
C, отправленное Bc, новым, поскольку Se отслеживает 
последнее значение счетчика 
Bc. Наконец, Se считает, что он никогда 
не создавал код аутентификации сообщений на основе хеша 
w(ДВК.C, k), поэтому Bc не может его воспроизвести. Только Se и Bc, 
которые являются единственными принципалами, обладающими 
k, 
могут построить этот код аутентификации сообщений на основе 
хеша. 
Se считает, что ключи надежно хранятся и извлекаются на всех 
картах. Только протокол, работающий на 
Bc, может иметь доступ к k 
в соответствии с конструкцией аппаратной защиты. 
Следовательно, если 
Se считает, что он никогда не раскрывал 
w(ДВК.C, k), тогда Se знает, что код аутентификации сообщений на 

132 
основе хеша является непередаваемым доказательством 
аутентификации 
Bc (он должен быть сгенерирован Bc). Таким 
образом, нам потребуется следующий набор исходных 
предположений: 
1. Предположение утверждает, что 
Bc знает симметричный 
ключ: 
 
Bc   y
K
(k,  Bc, Se), 
 
где 
y
K
(k,  Bc, Se) – симметричный ключ k между Bc и Se. 
2. Предположение утверждает, что 
Se знает симметричный 
ключ: 
 
Se  y
K
(k,  Bc, Se). 
 
3. Предположение утверждает, что 
Se знает, что C изменился 
 
Se #(C). 
 
4. Предположение утверждает, что 
Se никогда не генерировал 
код аутентификации сообщений на основе хеша. 
 
Se  G
lock
 (w(ДВК.C,  k),  Se), 
 
где 
G
lock
 (w(ДВК.C,  k),  Se) – Se никогда не генерировал w(ДВК.C,  k). 
Теперь перечислим возможный набор предварительных и 
дополнительных условий. Нам не нужны предварительные условия 
для сообщения номер один от 
Bc до Se на рис.   43.   Набор 
предварительных условий указан для второго сообщения, прежде чем 
Se сообщит Bi: 
1б. 
Se необходимо сделать вывод, что информация о банковской 
карте ДВК.
C отправляется Bc, а не какой-либо другой банковской 
картой 
Bc'. Это требование моделируется следующим образом: 
 
Se  G(ДВК.C,  Bc). 
 
2б. 
Se необходимо получить уверенность в том, что ДВК.C не 
поврежден, поскольку 
Bc произнес (сгенерировал) его: 
 

133 
Se  (ДВК.C, Bc). 
 
3б. 
Se необходимо убедиться, что M.ДВК.C изменился: 
 
Se  #(M.ДВК.C). 
 
4б. 
Se необходимо убедиться, что именно Bc запросил 
транзакцию 
M.ДВК.C: 
 
Se  G(M.ДВК.C,  Bc). 
 
5б. 
Se необходимо убедиться, что запрос транзакции M.ДВК.C 
не поврежден, поскольку он был передан 
Bc: 
 
Se  (M.ДВК.C,  Bc). 
 
6б. Укажем одно постусловие неотказуемости. То есть 
Se 
считает, что может доказать, что транзакция (включая описание 
товаров, дату, дату и платежный инструмент) была запрошена 
Bc. Это 
утверждение моделируется в виде: 
 
Se  (Se, G(M.ДВК.C,  Bc)). 
 
При программной реализации этой спецификации протокола 
были получены следующие результаты. Первое, второе и третье 
предварительные условия (смотри выше:    1б,    2б,    3б) были 
подтверждены. Они имеются, 
Se считает, что Bc сказал ДВК.C; Se 
верит в целостность ДВК.
C; и Se считает, что ДВК.C изменился. 
Однако протокол не смог надежно отработать четвертое и пятое 
условие (4б, 5б). Это означает, что намерение 
Bc послать M не может 
быть доказано. 
M не подписано Bc. Заключаем, что этот протокол не 
является корректным в отношении указанных исходных 
предположений, предварительных и постусловий. Обратите 
внимание, что не проверятся постусловие 6б. Это связано с тем, что 
отказов любых предварительных условий достаточно, чтобы сделать 
протокол-кандидат недействительным. 
Упростим условие моделирования, отбросим два 
предварительных условия 4б и 5б, а также постусловие 6
б. 
Сравниваем исходную спецификацию протокола с этим набором 

134 
смягченных предварительных и постусловий и обнаруживаем, что 
теперь это корректно для функционирования банковских карт. Теперь 
перейдем к этому набору упрощенных предварительных и 
постусловий. 
Исходный протокол для карты типа 
B состоит из двух передач 
сообщений: 
 
Bc  Se:M.ДВК.C.w(ДВК.C,  k); 
 
Se  Bi:M.ДВК, 
 
где  – заслуживает доверие. 
Поскольку предполагается, что вторая передача осуществляется 
по защищенному каналу, сосредоточимся на атаке, которая изменяет 
первую передачу. Используя стратегию модификации, можем 
заменить 
M.ДВК.C.w(ДВК.C, k) на путь, который начинается с Bc и 
заканчивается в 
Se через принципала-нарушителя Н* модели 
злоумышленника   Dolev-Yao.   Конкретно, если позволим 
Н* быть 
злоумышленником модели  Dolev-Yao,  первая передача может быть 
заменена следующим путем: 
 
Bc  Н*:M.ДВК.C.w(ДВК.C,  k), 
 
где 
 
Н*  Se:M.ДВК.C.w(ДВК.C,  k). 
 
Такой путь можно рассматривать как атаку с подслушиванием, 
которая незаметно прослушивает канал связи между 
Bc и Se. 
Поскольку нет никаких модификаций содержимого сообщения, т.е. 
никакие существующие предварительные условия или постусловия 
не изменяются. Однако для передачи сообщения добавляется пустой 
набор предварительных условий (
Н*  Se:M.ДВК.C.w(ДВК.C,    k)). 
Набор предварительных условий для передачи сообщения 
(
Bc  Н*:M.ДВК.C.w(ДВК.C, k)) остается пустым набором, а 
предварительные условия для (
Se  Bi:M.ДВК) состоят из:  1б,  2б и 
3б. 
Утверждение злоумышленника, которое моделируется, касается 
секретности информации о банковской карте ДВК. Поскольку 

135 
передачи между бесконтактными банковскими картами и 
считывателями транслируются, их может прочитать любой, кто их 
подслушивает. В этом случае необходимо, чтобы злоумышленникперехватчик 
Н* не мог получить финансовую информацию ДВК в 
открытом виде. Формально такое утверждение злоумышленника 
имеет вид: 
 

Н*  (Н*, ДВК), 
 
где  – отрицание; (
Н*, ДВК) – Н* может восстановить ДВК. 
То есть злоумышленник 
Н* не верит, что может 
реконструировать ДВК. 
При программной реализации этой спецификации протокола 
протокол успешно отработал до конца. В этом протоколе атаки не 
было постусловия для проверки. Однако было обнаружено, что 
утверждение злоумышленника неверно. Наша программная 
реализация правильно вычислила 
Н*  (Н*, ДВК) как 
действительную формулу. То есть злоумышленник 
Н* действительно 
может реконструировать ДВК, потому что ДВК был отправлен в 
открытом виде от 
Bc до Se. Заключаем, что исходный протокол 
неверен при столкновении с этой специфической атакой секретности. 
Вывод. Выявили ряд недостатков в вышеописанных 
протоколах. В частности, протоколу типа 
A не удалось убедить Se в 
том, что транзакция была недавно инициирована 
Bc и содержимое 
транзакции было повреждено. Протокол типа 
B не смог учесть 
намерение 
Bc провести транзакцию для определенного M. Протокол 
уязвим для атаки методом «вырезать и вставить» на 
M и нарушает 
требование секретности данных ДВК держателя банковской карты. 
EMV  [47,  48]  –  ведущий стандарт оплаты, администрируемый 
EMVCo  (http://www.emvco.com).  EMV  не является спецификацией 
для одного протокола. Он состоит из нескольких легко 
настраиваемых модулей, предназначенных для различных 
компонентов платежных протоколов. Далее формализуем 
аутентификационную часть протокола EMV и проведем его анализ. 
Протокол аутентификации, используемый в    EMV,    можно 
смоделировать с использованием 
двух принципалов: считывателя Re 
и банковской карты 
Bc. Мы предполагаем, что все банковские карты 
выпущены доверенным третьим принципалом 
N. Принципал N имеет 
пару открытого и закрытого ключей {
k
N.open
, k
N.lock
}. Закрытый ключ 

136 
k
N.lock
 принципала N хранится в секрете, а открытый ключ k
N.open
 
известен всем считывающим устройствам. Предполагаем, что каждая 
банковская карта надежно хранит свои личные ключи 
k
Bc.lock
. 
На этапе инициализации 
Bc и Re обмениваются 
последовательностью сообщений подтверждения для настройки 
протокола (эти шаги не моделируем). В конце инициализации 
Bc 
отправляет свой ДВК, включая дату истечения срока,   PAN   и 
некоторую вспомогательную информацию, такую как список 
объектов данных управления рисками карты  (Card  Risk  Management  
Data   Object   List,   CDOL),   в 
Re. Теперь протокол   EMV   готов к 
аутентификации карты. 
Цель аутентификации    –    проверить целостность ДВК и 
проверить, действительно ли он исходит от заявленного 
Bc. 
Спецификация       EMV       предоставляет три типа методов 
аутентификации: статическая аутентификация данных (САД), 
динамическая аутентификация данных (ДАД) и комбинированная 
аутентификация данных (КАД). КАД похож на ДАД, но с 
дополнительной транзакционной информацией, включенной в 
сообщения аутентификации. Далее проведем формализацию 
протокола аутентификации САД и ДАД, а затем выполним их анализ. 
В САД карта возвращает подпись 
хеш-кода ДВК, подписанную 
эмитентом карты 
N. Эта подпись была предварительно вычислена во 
время производства и хранится на карте. Протокол аутентификации 
САД можно формализовать как передачу следующего сообщения: 
 
Bc  Re:ДВК.r
v
((ДВК), N). 
 
Первоначальные предположения   –   это создание ключей до 
аутентификации. Формально имеем: 
1. Принципал 
N считает, что ему принадлежит открытый ключ 
k
N.open
: 
 
N  (N, k
N.open
). 
 
2. Принципал 
N считает, что ему принадлежит закрытый ключ 
k
N.lock
: 
 
N  (N, k
N.lock
). 
 

137 
3. Re считает открытый ключ k
N.open
 принадлежит N: 
 
Re  (N, k
N.open
). 
 
4. 
Re считает, что N заслуживает доверия: 
 
Re  N  trustworthy. 
 
Bc не предъявляет никаких предварительных условий перед 
отправкой этого сообщения. Таким образом, предварительным 
условием для САД является пустой набор. 
Набор требуемых 
Re постусловий формализуется следующим 
образом: 
1в. 
Re считает, что ДВК был выпущен N: 
 
Re G(ДВК, N). 
 
2в. 
Re верит в целостность ДВК от N. Именно ДВК выдал N: 
 
Re (ДВК, N). 
 
3в. 
Re считает, что этот запрос на транзакцию отправил Bc: 
 
Re G(ДВК, Bc). 
 
4в. 
Re считает, что ДВК был недавно отправлен Bc и не является 
повтором. Моделируя это требование, утверждаем 
 
Re #(ДВК). 
 
5в. 
Re считает целостность ДВК от Bc: 
 
Re (ДВК, Bc). 
 
Выполнив программную реализацию этой спецификации 
протокола, обнаружили, что последние три постусловия 3в,  4в и 5в 
недействительны. Использование САД оставляет злоумышленникам 
возможность воспроизвести некоторые 
r
v
((ДВК), N) в Re. Re может 
проверить, действительно ли ДВК был выдан 
N. Однако Re не может 

138 
доказать, что это был конкретный Bc, который недавно отправил 
ДВК, или что ДВК не поврежден, поскольку он был отправлен этим 
Bc. 
Заключаем, что аутентификация САД не является корректной в 
отношении указанного набора исходных предположений, 
предварительных и последующих условий. Обратите внимание, что 
EMV понимает эти ограничения и рекомендует использовать САД 
только в условиях ограниченного и низкого риска. 
Некоторые ограничения САД устраняются ДАД. В ДАД 
аутентификация карты осуществляется случайным вызовом и 
применением цифровой подписи
. Карта также может 
аутентифицировать считыватель; мы не будем это моделировать. 
Bc 
сначала отправляет ДВК и его сертификат 
Re. Сертификат не 
является стандартным сертификатом  X.509  [53].  Сертификат может 
быть оформлен в виде подписи с отметкой времени истечения срока 
действия, открытого ключа 
Bc и хеша ДВК, подписанного N 
закрытым ключом k
N.lock
: 
 
Bc  Re:ДВК.r
v
(*(T
exp
).(Bc,  k
Bc.open
).(ДВК), N), 
 
где *– отметка времени истечения срока. 
Далее 
Re отправляет объект данных динамической 
аутентификации данных  (Dynamic  Data  Authentication  Data  Object,  
DDOL) в 
Bc.   DDOL   содержит сгенерированный считывателем 
одноразовый номер 
N
Re
, который, как известно Re, является 
измененным, и дополнительно содержит некоторую информация, 
которую мы не будем моделировать. 
 
Re  Bc:(N
Re
), 
 
где  – в данное время (в режиме реального времени). 
Получив 
N
Re
, Bc создает объект динамических данных   ICC   
(ICCDDO,  ICC  Dynamic  Data  Object),  который состоит из только что 
сгенерированного одноразового номера 
N
Bc
. Затем Bc возвращает 
свою подпись над ICCDDO и хеш-значениями ICCDDO и DDOL. 
 
Bc  Re:r
v
((N
Bc
).((N
Bc
).(N
Re
)), Bc). 
 

139 
Сертификат в Bc  Re:ДВК.r
v
(*(T
exp
).(Bc,    k
Bc.open
).(ДВК), N) 
подписан эмитентом карты 
R. Он распознает, что открытый ключ 
k
Bc.open
 связан с ДВК. Таким образом, ДВК ассоциируется с любым, 
кто может продемонстрировать владение соответствующим 
закрытым ключом. В 
Re  Bc:(N
Re
) новый вызов отправляется Bc. В 
Bc  Re:r
v
((N
Bc
).((N
Bc
).(N
Re
)), Bc) Bc предоставляет подпись над 
этим одноразовым номером и демонстрирует, что он имеет 
соответствующий закрытый ключ, и, следовательно, 
аутентифицируется в 
Re. Опишем формализации исходных 
предположений. 
Исходные предположения. 
1. Эмитент банковской карты 
N знает ее открытый и закрытый 
ключи: 
 
N  (N, k
N.open
); 
 
N  (N, k
N.lock
). 
 
2. 
Re знает открытый ключ, принадлежащий N: 
 
Re  (N, k
N.open
). 
 
3. 
Bc знает, что N
Bc
 изменился, а Re знает, что N
Re
 изменился: 
 
Bc  #((N
Bc
)); 
 
Re  #((N
Re
)). 
 
4. 
Re знает, что метка времени *(T
exp
) еще не истекла: 
 
Re  (*(
T
exp
)), 
 
где  – изменился или срок годности не истек. 
5. 
Re считает, что эмитент банковской карты N заслуживает 
доверия: 
 
Re  N  trustworthy. 
 

140 
Три предварительных условия для первого, второго и третьего 
сообщения соответственно: 
1. Нуль      0      (пустой набор): 
Bc всегда запускает 
аутентификационную часть протокола ДАД. 
2. После получения первого сообщения и до второго сообщения 
Re должен поверить, что ДВК был объявлен N, не поврежден и все 
еще действителен. 
Re также должен верить, что открытый ключ Bc – 
это 
k
Bc.open
: 
 
Re  G(ДВК, N); 
 
Re  (ДВК, N); 
 
Re  (Bc, k
Bc.open
). 
 
3. Нуль 0 (пустой набор): 
Bc всегда отвечает на DDOL. 
 
В конце протокола 
Re должен полагать, что ответ от Bc был 
недавно сгенерирован с использованием закрытого ключа, 
соответствующего открытому ключу 
k
Bc.open
. Если это предположение 
может быть подтверждено, то 
Re считает, что Bc владеет закрытым 
ключом, который соответствует 
k
Bc.open
. Следовательно, Bc 
аутентифицирован. В этом случае постусловие имеет следующее 
утверждение: 
 
Re  G((N
Re
), Bc). 
 
То есть 
Bc аутентифицирует себя и подтверждает в данный 
момент времени сгенерированный одноразовый номер 
N
Re
. 
Программная реализация этой спецификации протокола и 
успешно завершилась. Все постусловия действительны. Заключаем, 
что протокол является корректным. 
  

141 
4.2. Протоколы оплаты с использованием мобильных 
устройств 
 
В этом параграфе рассматривается мобильный протокол 
бесконтактных платежей, который обеспечивает высокий уровень 
безопасности, а также дополнительные функции, такие как 
предотвращение отказа от авторства. Обсуждается его формализация 
и анализ. 
Рассматриваемый протокол мобильных платежей позволяет 
мобильному телефону с поддержкой  NFC  производить оплату через 
считывающее устройство  NFC,  которое надежно подключается к 
шлюзу обработки платежей. В 
этой главе мы подробно рассмотрим 
первый тип протокола мобильных платежей и его анализ. 
Протокол оплаты с использованием мобильного устройства, 
обозначаемый как 
P
D
, позволяет мобильному телефону с поддержкой 
NFC взаимодействовать с устройством чтения  NFC  для совершения 
транзакции через   NFCIPI   (NFC-LLCP)   [71].   Предполагаем, что 
считыватель   NFC   заслуживает доверия (заслуживающий доверия 
принципал обслуживается и использует правильный и 
аутентифицированный протокол) и подключен к платежному серверу 
через безопасный канал  TLS  [57,  55].  Предполагается, что связь 
между считывателем  NFC  и сервером безопасна и выходит за рамки 
этого анализа
. Платежный сервер отвечает за сбор доказательств 
транзакций и выполнение таких операций, как выставление счетов и 
аудит. Мы будем использовать атомарные переменные 
Ph для 
обозначения телефона, 
Re для обозначения считывающего устройства 
и 
N для обозначения центра сертификации, который выдает 
сертификаты и управляет ими. 
Обозначим (
Ph, (ID
Ph
), (T
1Ph
, T
2Ph
), k
ph.open
, N) как сертификат, 
выданный 
Ph. Обозначим (Re, (ID
Re
), (T
1Re
, T
2Re
), k
Re.open
, N) как 
сертификат, выданный 
Re. Далее будем использовать (P) в качестве 
сокращенного обозначения для обозначения полного сертификата 
X.509 принципала 
P. 
Телефон с функцией  NFC  не поддерживает конечный автомат 
для платежной информации, такой как баланс. Вместо этого эта 
информация хранится на платежном сервере. Телефон 
идентифицируется по сертификату и некоторой вспомогательной 

142 
информации, такой как связанный с ним постоянный номер счета 
(Permanent Account Number, PAN). 
На телефоне с функцией NFC и считывателе имеются элементы 
защиты  [63,  44,  38,  64,  65,  39,  68,  67,  45].  Встроенный элемент 
безопасности хранит закрытый ключ, а также любые секреты, 
которые могут быть удаленно переданы оператором на телефон или 
считывающее устройство. Секреты состоят как из недолговечных 
симметричных ключей, так и из протокольных 
программ. 
Невозможно прочитать или изменить содержимое за пределами 
защищенного элемента, и только аутентифицированные программы 
могут получить доступ к его соответствующим ключам или секретам. 
Предполагаем, что существует один платежный сервер и много 
аутентифицированных считывателей и телефонов. Кроме того, 
предполагаем, что один 
Re может обслуживать только одного Ph в 
любое время, согласование версии и согласование были успешно 
выполнены, и 
Ph и Re согласовали протокол связи. Рассмотрение 
этой процедуры выходят за рамки нашего анализа. 
Исходное предположение  –  это набор обоснованных формул, 
которые считаются действительными до запуска протокола. 
Закрытые ключи 
Ph и Re генерируются внутри защищенных 
элементов. После создания они никогда не покидают защищенные 
элементы, и соответствующие открытые ключи отправляются на 
N 
для сертификации. Предполагаем, что сертификаты были подписаны 
N, а затем переданы Ph и Re до начала сеанса отработки протокола. 
Дополнительно предполагаем: 
1. 
Ph и Re знают открытый ключ центра сертификации N: 
 
Ph  (
N, k
N.open
); 
 
Re  (
N, k
N.open
). 
 
2. И 
Ph, и Re считают, что N заслуживает доверия. Ph считает, 
что 
Re заслуживает доверия: 
 
Ph  N  trustworthy; 
 
Re N  trustworthy; 
 
Ph  Re  trustworthy. 

143 
3. Ph и Re имеют доступ к своим закрытым и открытым ключам: 
 
Ph  (Ph, k
ph.open
); 
 
Re  (Re, k
Re.open
); 
 
Ph  (Ph, k
ph.lock
); 
 
Re  (Re, k
Re.lock
). 
 
4. 
ID
Ph
 и ID
Re
 не включены в список аннулированных 
сертификатов, а отметки времени на сертификатах 
Ph и Re 
соответствуют текущему времени: 
 
Ph  ((ID
Re
)); 
 
Re  ((ID
Ph
)); 
 
Ph   ((T
1Re
, T
2Re
)); 
 
Re  ((T
1Ph
, T
2Ph
)), 
 
где  – идентичность. 
 
5. 
Re может восстановить сообщение   server-hello,   которое 
должно быть сгенерировано им самим в сообщении 2 (второе сверху) 
на рис. 44: 
 
Re  (Re, (N
Re
).(T
Re
).D
Tran
), 
 
где 
D
Tran
   –   дескриптор (описание) транзакции, которое может 
включать финансовую информацию о взимаемой сумме, продавце, 
местонахождении и т.д. 
 
6. 
Ph может реконструировать D
Ph
 сообщения, который должен 
быть сгенерирован сам по себе в сообщении  3  (третье сверху) на 
рис. 44: 
 

144 
Ph  (Ph, D
Ph
). 
 
7. 
Re и Ph считают, что метка времени (T
Re
) изменилась: 
 
Re  #((
T
Re
)); 
 
Ph  #((
T
Re
)). 
 
8. 
Re считает генерируемый им в данное время (N
Re
) 
поменялся: 
 
 
 
Рис. 44. Схема последовательности UML для протокола 
P
D
 оплаты с 
использованием мобильных устройств на основе NFC  
 
Ниже приводится пошаговое описание протокола 
P
D
. 
Шаг 1  (Client  Hello).  
Ph сначала отправляет свой сертификат в 
качестве приветствия клиента 
Re. 
 
Ph  Re:(Ph). 
 
Перед выполнением шага  2  необходимо выполнить повторную 
проверку сертификата 
Ph. Важным в этом процессе является 
обеспечение истечения срока действия сертификата и его отзыв. 
Проверка должна быть успешной, и поэтому 
Re может получить 
открытый ключ 
Ph: 
 
Re  (Ph, k
Ph.open
). 
 

145 
Шаг 2  (Server  Hello).  После получения приветствия клиента от 
Ph, Re создает запрос M, состоящий из нового (измененного) 
одноразового номера (
N
Re
), метки времени T
Re
, принадлежащей Re, 
описания транзакции 
D
Tran
 и идентификатор получателя (ID
Ph
), 
который 
Re получает из (Ph), полученного на предыдущем этапе. M 
оформляется в виде: 
 
M = (N
Re
).(T
Re
).D
Tran
.(ID
Ph
). 
 
Re имеет требование конфиденциальности по M, поскольку D
Tran
 
содержит транзакционную информацию, которую нельзя раскрыть. 
Затем 
Re отправляет свой сертификат и шифрованный текст, 
зашифрованный с использованием открытого ключа 
Ph, на Ph: 
 
Re  Ph:(Re).r
p
(M.r
v
((M), Re), Ph). 
 
До реализации шага  3  
Ph должен подтвердить сертификат Re. 
Он также проверяет целостность, актуальность и является ли сервер 
предполагаемым получателем (если его идентификатор 
подтвержден). Он также может выполнять некоторые семантические 
проверки, зависящие от протокола транзакции. Например, он 
проверяет, является ли пакет запроса транзакции 
D
Tran
 правильным и 
ожидаемым. Поскольку они не имеют непосредственного отношения 
к модели безопасности, не будем их включать в предварительные 
условия. Однако их легко добавить. Таким образом, 
предварительными условиями для этой передачи являются: 
1. 
Ph считает, что открытый ключ принадлежит Re: 
 
Ph  (Re, k
Re.open
). 
 
2. 
Ph считает, что M происходит от Re: 
 
Ph  G(M, Re) 
 
3. 
Ph считает M измененным: 
 
Ph  #(
M). 
 

146 
4. Ph считает, что М не повреждено с тех пор, как произнесено 
Re: 
 
Ph  (M, Re). 
 
5. 
Ph считает, что это предполагаемое считывающее устройство 
для 
M, и что M подтверждает свой идентификатор: 
 
Ph  (M, Ph); 
 
Ph  w
P
(M, (ID
Ph
)), 
 
где 
w
P
(M, (ID
Ph
))  –  (ID
Ph
) является частью M; (M, Ph)  –  Ph 
является получателем от 
M. 
(
ID
Ph
) в Ph  w
P
(M, (ID
Ph
)) является идентификатором Ph, 
содержащийся в (
Ph). Это подтверждение моделирует проверку, 
которую выполняет 
Ph. Если личность, подтвержденная Re, 
отличается от (
ID
Ph
), тогда Ph знает, что транзакция 
фальсифицирована. 
Шаг 3 (привязка телефона, Phone Binding). Затем 
Ph строит свое 
описательное сообщение 
D
Ph
. D
Ph
 будет содержать любую 
дополнительную информацию, которую 
Ph должен предоставить для 
завершения этой транзакции, например, ДВК. Затем 
Ph производит 
подпись 
S
Ph
. Подпись верифицирует M.D
Ph
 в Ph. 
 
S
Ph
  = r
v
((M.D
Ph
), Ph). 
 
После этого 
Ph шифрует D
ph
 и подпись, используя открытый 
ключ, принадлежащий 
Re, и отправляет шифрованное сообщение Re. 
 
Ph  Re:r
p
(D
Ph
.S
ph
,  Re). 
 
До реализации шага    4    необходимо провести повторную 
проверку целостности, и подлинности сообщения. Кроме того, 
Re 
проверяет, подтверждает ли 
Ph правильный M (M, созданный Re, а не 
отправленный 
Ph). Предварительные условия на этом этапе: 
1. 
Re считает, что Ph прислала подтверждение транзакции в лице 
M.D
Ph
: 
 

147 
Re  G(M.D
Ph
, Ph). 
 
2. 
Re считает, что M.D
Ph
  –  это только что сгенерированная 
транзакция, а не её повтор: 
 
Re  #(M.D
Ph
). 
 
3. 
Re считает, что M.D
ph
 не поврежден, так как он был 
сгенерирован 
Ph: 
 
Re  (M.D
Ph
, Ph). 
 
Шаг 4 (Получение,  Receipt).  После получения 
D
ph
 и проверки 
его целостности и подлинности 
Re генерирует квитанцию и передает 
ее 
Ph. Квитанция, обозначаемая как D
Re
, представляет собой 
композицию запроса транзакции 
D
Tran
 и ответа D
ph
 плательщика, а 
также распознавания считывающим устройством двойной привязки. 
Пусть 
R
Ph.Re
 обозначает квитанцию, сгенерированную Re для 
отправки в 
Ph: 
 
R
Ph.Re
 = D
Re
.r
v
((D
Ph
.M.D
Re
), Re). 
 
Наконец, 
R
Ph.Re
 зашифровывается и отправляется Ph. Таким 
образом, имеем 
 
Re  Ph:r
p
(R
Ph.Re
, Ph). 
 
Постусловия: 
А. 
Ph проверяет: подтверждает ли Re правильный D
ph
 (Ph 
недавно отправил 
D
ph
) и что D
Ph
.M.D
Re
 от Re, изменился и 
неповрежденный. 
 
Ph  G(D
Ph
.M.D
Re
,  Re); 
 
Ph  #(D
Ph
.M.D
Re
); 
 
Ph  (D
Ph
.M.D
Re
,  Re) 
 

148 
Б. Неопровержимый запрос от Re: Ph содержит 
неопровержимые и неповрежденные доказательства того, что 
Re 
запросил платеж (в определенной сумме в определенное время, в 
определенном месте и т.д.). Если 
Re опровергает платеж, Ph может 
предъявить подлежащее передаче доказательство арбитру: 
- обеспечение защиты авторства в отношении контента: 
 
Ph  (Ph, G(M, Re)); 
 
- обеспечение фиксации авторства в отношении целостности 
контента: 
 
Ph  (Ph, (M, Re)). 
 
В.
 Неопровержимый платеж от Ph: Ph санкционировал платеж в 
ответ на запрос 
Re. Ph предоставил такую информацию, как номер 
PAN и сумму, которую он разрешил выплатить, а также свою 
готовность связать этот платеж с запросом 
Re. Re хранит это 
неопровержимое доказательство. Если 
Ph опровергает какие-либо 
сведения о сумме, PAN, продавце, времени и месте платежа, тогда 
Re 
может предоставить передаваемое доказательство честности 
перевода: 
 
Re  (Re, G(M.D
Ph
,  Ph)); 
 
Re  (Re, (M.D
Ph
,  Ph)). 
 
Г.
 Неопровержимое подтверждение платежа: Кроме того, Re не 
может позже опровергнуть тот факт, что он не получил приемлемый 
платеж от 
Ph. Ph может предъявить передаваемое доказательство 
арбитру о принятии 
Re оплаты от Ph: 
 
Ph  (Ph, G(D
Ph
.M.D
Re
,  Re)); 
 
Ph  (Ph, (D
Ph
.M.D
Re
,  Re)). 
 
Программная реализация этого алгоритма показала, что 
протокол успешно завершился. По завершении выполнения 
алгоритма все постусловия выполняются. Таким образом, мы 

149 
заключаем, что P
D
 является корректным. Это означает, что протокол 
P
D
 выполняет набор требований безопасности, отраженных в 
указанных предварительных условиях и постусловиях. 
Далее рассмотрим две атаки, полученные путем применения 
функции преобразования 
F
A
 на P
D
. 
Далее рассмотрим подслушивающего злоумышленника, 
который прослушивает все передачи между 
Re и Ph, не внося 
никаких изменений в передаваемые сообщения. Эта атака на 
P
D
 
обозначается как 
P
D.attack
 – протокол атаки на протокол P
D
. Наша цель 
– убедиться, что соблюдены требования к секретности 
конфиденциальной информации. Диаграмма последовательности 
P
D.attack
 представлена на рис. 45. 
 
 
Рис. 45. Схема последовательности UML для протокола атаки 
P
D.attack
. 
 
Набор исходных предположений такой же, как и для 
P
D
, за 
исключением того, что злоумышленник, обозначенный как 
H*, знает 
открытые ключи центра сертификации 
N, Re и Ph. Таким образом, 
имеем  
H*  (N, k
N.open
),  
 
H*  (Ph, k
ph.open
),  
H*  (Re, k
Re.open
).  
 
Кроме того, предполагаем, что 
N и Re заслуживают доверия для 
злоумышленника:  
 

150 
H*  N  trustworthy;  
 
H*  Re  trustworthy. 
 
Постусловия для атаки злоумышленника на 
P
D
 такие же, как для 
P
D
, поскольку H* не изменяет никакие передачи, и все участники P
D
 
полностью участвуют в 
P
D.attack
. Последовательность передач 
транзакций и предварительные условия представлены в табл. 16. 
 
Таблица 16 
Предварительные условия и обмен сообщениями при атаке 
P
D.attack
 
Последовательность 
Предварительные 
условия 
Обмен сообщениями 
1 Нет 
Ph  H*: (Ph) 
2 Нет 
H*  Re: (Ph) 
3 
Re  (Ph, k
Ph.open
) Re  H*:(Re).r
p
(M.r
v
((M),Re),Ph) 
4 Нет 
H*  Ph:(Re).r
p
(M.r
v
((M),Re),Ph) 
5 
Ph  (Re, k
Re.open
), 
Ph  G(M, Re), 
Ph  #(M), 
Ph  (M, Re), 
Ph  (M, Ph), 
Ph  w
p
(M, (ID
Ph
))
Ph  H*:r
p
(D
Ph
.r
v
((M.D
Ph
),Ph),Re) 
6 Нет 
H*  Re:r
p
(D
Ph
.r
v
((M.D
Ph
),Ph),Re) 
7 
Re  G(M.D
Ph
, Ph), 
Re  #(M.D
Ph
), 
Re  (
M.D
Ph
, Ph) 
Re  H*:r
p
(D
Re
.r
v
((D
Ph
.M.D
Re
),Re),Ph) 
8 Нет 
H*  Ph:r
p
(D
Re
.r
v
((D
Ph
.M.D
Re
),Re),Ph) 
 
Набор утверждений злоумышленников моделирует секретность 
с помощью отрицаний трех формул. Они утверждают, что 
злоумышленник не может восстановить 
M, D
Re
 или D
Ph
: 

151 
1. Злоумышленник H* не может восстановить сообщение 
транзакционного запроса 
M (секретность M) 
 

H*  (H*, M). 
 
2. Злоумышленник 
H* не может восстановить сообщение 
подтверждения транзакции 
D
Ph
 (секретность на D
Ph
). 
 

H*  (H*, D
Ph
). 
 
3. Злоумышленник 
H* не может восстановить сообщение D
Re
 
(Секретность на 
D
Re
) 
 

H*  (H*, D
Re
). 
 
При программной реализации атаки для протокола 
P
D.attack
. 
Протокол был доведен до конца, и все пост-условия и утверждения 
злоумышленников были действительны. Алгоритм возвращает 
истину и, следовательно, P
D
 является правильным при атаке P
D.attack
. 
В 
P
D.attack
 мы вставили злоумышленника, который прослушивал 
все сообщения, которыми обменивались 
Re и Ph. Программная 
реализация протокола 
P
D
 показала, что злоумышленник не смог 
раскрыть текстовые сообщения 
M, D
Re
 или D
Ph
. При этом атака не 
была обнаружена, а все постусловия и утверждения 
злоумышленников были выполнены. Это означает, что исходный 
протокол 
P
D
 защищен от этого специфического типа атак с 
перехватом, поскольку обеспечивает секретность передаваемой 
транзакционной информации. 
Теперь смоделируем другую атаку, в которой злоумышленник 
H* пытается выдать себя за Ph, воспроизводя его сертификат и 
некоторые из старых сообщений 
H*, перехваченных в предыдущем 
сообщении (
M ), аналогичном P
D.attack
. Обозначим атаку как P
D2.attack
. 
Последовательность передачи сообщений на языке      UML      
представлена на рис. 46. 
В этом протоколе 
Re предполагает, что разговаривает с Ph. 
Вместо этого 
Re взаимодействует с злоумышленником H*, при этом 
Ph заблокирован от получения каких-либо сообщений. После 
получения сигнала  client-hello,  воспроизведения сертификата 
Ph от 
H*, Re возвращает свой сертификат, а также r
p
(M.r
v
((M), Re), Ph). 

152 
Поскольку H* не знает закрытый ключ Ph, H* не может управлять 
этим сообщением, а 
H* не может видеть его содержимое. Вместо 
этого 
H* отправляет повтор третьей передачи в предыдущем прогоне 
P
D
 между Re и Ph, обозначенный как r
p
(D
Ph
.r
v
((M'.D
Ph
), Ph), Re), где 
M' отличается от M, т.к. М изменился, и D
Ph
 использовалась в 
качестве платежной информации, которую использовал 
Ph, в 
надежде, что 
Re примет платежную информацию. Если протокол 
завершается, 
Re отправляет свою подпись через D
Ph
.M.D
Re
, где D
Ph
 
был получен 
Re; M и D
Re
 были построены Re. 
 
 
Рис. 46. Схема последовательности UML для протокола атаки 
P
D2.attack
 
 
Исходные предположения такие же, как и для 
P
D.attack
. 
Предварительные условия и передача сообщений представлены в 
табл. 17. 
 
Таблица 17 
Протокол атаки 
P
D2.attack
 для протокола оплаты мобильного 
считывателя 
Последовательность 
Предварительные 
условия 
Обмен сообщениями 
1 Нет 
H*  Re:(Ph) 
2 
Re  (Ph, k
Ph.open
) Re  H*:(Re).r
p
(M.r
v
((M),Re),Ph) 
3 Нет 
H*  Re:r
p
(D
Ph
r
v
((M'.D
Ph
), Ph), Re) 
4 
Re  G(M.D
Ph
, Ph), 
Re  #(M.D
Ph
),  
Re  (M.DPh, Ph) 
Re  H*:r
p
(D
Re
.r
v
((D
Ph
.M.D
Re
),Re),Ph) 
 

153 
Все предварительные условия, связанные с Ph, удалены, 
поскольку 
Ph не участвовал в этом протоколе атаки. Все 
предварительные условия для передачи сообщений, в которых 
злоумышленник является отправителем, являются пустыми. Более 
того, три предварительных условия для сообщения    4    –    это 
утверждения о 
M, а не о M'. Это связано с тем, что эти утверждения 
являются признанием 
Ph элемента M, созданного Re, а не признанием 
M элемента Re, получаемого от Ph. Они утверждают, что на этом 
этапе протокола 
Re должен иметь возможность вывести уверенность 
в том, что 
M, построенное Re, является подтверждено Ph. Ph признаёт 
другой 
M' и не изменяет цель подтверждения, которую ищет Re. 
В этом случае имеет следующие постусловия: 
1. 
Re убежден в неопровержимых доказательствах 
подтверждения сделки 
Ph.M.D
Ph
: 
 
Re  (Re, G(M.D
Ph
, Ph)). 
 
2. 
Re убежден в целостность неопровержимых доказательств: 
 
Re  (Re, (M.D
Ph
, Ph)). 
 
Наконец, утверждения злоумышленника этого протокола атаки: 
 
1. Злоумышленник 
H* не может восстановить сообщение 
транзакционного запроса 
M (секретность M): 
 

H*  (H*, M). 
 
2. Злоумышленник    H*    не может восстановить D
Re
, т.е. 
квитанцию: 
 
H*  (H*, 
D
Re
). 
 
Эти утверждения злоумышленника отражают требования 
конфиденциальности, которые были наложены на платежную 
информацию 
M и D
Re
; два утверждения были построены и 
отправлены честным принципалам 
Re. 
Программная реализация алгоритма 
P
D2.attack
 показала, что 
протокол 
P
D
 остановлен после того, как Re получил 

154 
r
p
(D
Ph
.r
v
((M'.D
Ph
),Ph),Re) из-за нарушения предварительного условия 
Re  G(M.D
Ph
, Ph), где M сгенерирован в начале протокола и было 
вызовом 
Re. Более того, на момент нарушения утверждения 
злоумышленника были действительными. То есть злоумышленник не 
может восстановить 
M или D
Re
. Это означает, что исходный протокол 
может обнаруживать этот тип атаки, и на момент обнаружения 
никакие требования к секретности не были нарушены. 
Вывод: протокол 
P
D
 ведет себя корректно при атаке P
D2.attack
. 
В этом параграфе был представлен протокол бесконтактных 
платежей с помощью мобильного считывателя с высокой степенью 
защиты. Две ключевые особенности этого протокола, которых нет в 
EMV ДАД,  –  это секретность платежной информации (аналогичная 
ДВК в EMV) и обработка неотказуемости как для продавца, так и для 
клиента. Мы формализовали протокол 
P
D
 и показали, что он работает 
корректно. Были рассмотрены две формы атаки: одну на секретность 
(
P
D.attack
) и другую за выдачу себя за другое лицо (P
D2.attack
). Пришли к 
выводу, что протокол-кандидат 
P
D
 защищен от этих двух атак в 
отношении набора начальных предположений, а также 
предварительных и последующих условий. 
 
  

155 
4.3. Протоколы оплаты с использованием мобильных 
токенов  
 
В этом параграфе рассматривается мобильный протокол 
бесконтактных платежей, который обеспечивает высокий уровень 
безопасности, а также дополнительные функции, такие как 
предотвращение отказа от авторства. Обсуждается его формализация 
и анализ. 
Рассматриваемый протокол мобильных платежей позволяет 
NFC-телефону с возможностью подключения к серверу приобретать 
услуги или товары, идентифицируемые пассивными тегами (смарткартами). В отличие
 от протокола оплаты на основе считывателя 
(параграф   4.2),   телефон теперь отвечает за сбор доказательств 
транзакции, а также за их отправку на платежный сервер. 
Первоначально рассмотрим протокол мобильных платежей, 
который не использует  NFC-считыватель. Протокол, обозначенный 
как 
P
B
, позволяет  NFC-телефону с возможностью передачи данных 
сервера покупать услуги или товары, идентифицированные 
пассивными тегами (смарт-картами). В отличие от протокола оплаты 
на основе считывателя, телефон теперь отвечает за сбор 
доказательств транзакции, а также за их отправку на платежный 
сервер. Пассивные теги размещаются с описанием покупаемых услуг 
или товаров. Они обесточены 
и общаются с телефоном по схеме 
модуляции нагрузки. Популярными примерами являются умные 
плакаты, где на стене вешают пассивные теги для рекламы услуг, а 
также умные дисплеи в торговом центре, где покупатели могут 
нажать, чтобы заплатить за отображаемые товары. После этого 
покупатели могут забрать купленные товары при выходе из магазина 
или торгового
 центра. 
Основное различие между этим типом платежного протокола 
P
B
 
и протоколом на основе считывателя 
P
D
 заключается в том, что 
пассивные теги не могут представлять произвольные услуги или 
товары. Вместо этого они представляют собой фиксированный набор 
услуг или товаров. Преимущество состоит в том, что зачастую к 
продаваемым товарам не предъявляются требования 
конфиденциальности  –  каждый может их проверить. После того, как 
телефон коснется пассивной метки, метка представляет «меню» 
товаров или услуг для покупки. Такое же «меню» возвращается при 
каждом таком запросе. Единственное требование, которое 

156 
предъявляет платежный сервер,  –  это то, что идентифицированный 
телефон (необязательно с информацией о выбранном платежном 
инструменте) согласился приобрести определенную услугу в 
определенное время. 
Предполагаем, что пассивные теги могут выполнять 
примитивные криптографические операции, такие как шифрование и 
цифровая подпись. Кроме того, у тегов достаточно памяти для 
хранения своих сертификатов. Предполагается, что хранение 
закрытых
 ключей и секретов в этих тегах аналогично защищенному 
элементу, используемому в телефоне. Закрытые ключи и любые 
секреты не могут быть прочитаны или изменены злоумышленниками. 
В этом протоколе задействованы три типа принципалов: 
уникальный платежный сервер 
Se, количество действующих  NFCтелефонов 
Ph и количество действующих смарт-карт Sm. 
Предполагаем, что 
Se считается заслуживающим доверия как Ph, так 
и 
Sm. Ph и Sm не считаются заслуживающими доверия Se. 
Предположим, что выдающий орган управляет сертификатами для 
всех участников. 
Высокоуровневое описание протокола выглядит следующим 
образом: после того, как 
Se получает сигнал  client-hello  от Ph, Se 
генерирует запрос 
M
Se
  =  (N
Se
).(T
Se
).(ID
Ph
), где  (N
Se
)  –  глобально 
уникальный одноразовый номер, а (
T
Se
)   –   временная метка, 
сгенерированная сервером. Сообщение 
M
Se
 и его подтверждение 
происхождения затем отправляется в 
Ph. Ph затем пересылает то же 
сообщение 
Sm для подписи. После получения подписи от Sm, Ph 
выполняет вторую подпись под подписью, возвращенной 
Sm. 
Полученная в результате двойная подпись передается обратно в 
Se 
для проверки. Наконец, если все верно, квитанция возвращается 
Ph. 
Общая последовательность потока сообщений представлена на 
рис. 47. 
 

157 
 
Рис. 47. Схема последовательности UML для телефона NFC, 
протокол 
P
B
 оплаты смарт-картой  
 
Ниже представлена формализованная спецификация 
P
B
, включая 
исходные предположения, передачу сообщений, предварительные 
условия, а также постусловия. 
1. И 
Ph, и Sm считают, что Se заслуживает доверия. Ph, Sm и Se 
считают, что это транзакция заслуживает доверия. Таким образом: 
 
Ph  Se  trustworthy; 
 
Sm  
Se  trustworthy; 
 
Ph  N 
 trustworthy; 
 
Sm  N 
 trustworthy; 
 
Se  N 
 trustworthy. 
 
2. 
Ph, Sm и Se имеют доступ к своим личным и открытым 
ключам: 
 
Ph  (Ph, k
Ph.open
); 
 
Sm  (Sm, k
Sm.open
); 
 

158 
Se  (Se, k
Se.open
); 
 
Ph  (Ph, k
Ph.lock
); 
 
Sm  (Sm, k
Sm.lock
); 
 
Se  (Se, k
Se.lock
). 
 
3. Ph, Sm и Se имеют  root-сертификаты от центра сертификации и, 
следовательно, знают открытый ключ N: 
 
Ph  (N, k
N.open
); 
 
Sm  (N, k
N.open
); 
 
Se  (N, k
N.open
). 
 
4. ID
Ph
, ID
Se
, ID
Sm
 отсутствуют в списке аннулированных 
сертификатов, а отметки времени на сертификатах 
Ph, Se и Sm 
соответствуют текущему времени: 
 
Ph  ((ID
Se
)); 
 
Sm  ((ID
Se
)); 
 
Se  ((ID
Se
)); 
 
Se  ((ID
Ph
)); 
 
Sm  ((ID
Ph
)); 
 
Ph  ((ID
Ph
)); 
 
Se  ((ID
Sm
)); 
 
Ph  ((ID
Sm
)); 
 
Sm  ((ID
Sm
)); 
 

159 
Ph  ((T
1Se
, T
2Se
)); 
 
Sm  ((T
1Se
, T
2Se
)); 
 
Se  ((T
1Se
, T
2Se
)); 
 
Se  ((T
1Ph
, T
2Ph
)); 
 
Sm  ((T
1Ph
, T
2Ph
)); 
 
Ph  ((T
1Ph
, T
2Ph
)); 
 
Ph  ((T
1Sm
, T
2Sm
)); 
 
Se  ((T
1Sm
, T
2Sm
)); 
 
Sm  ((T
1Sm
, T
2Sm
)), 
 
где  – невозможность отзыва сертификата. 
 
5. 
Se может восстановить одноразовый номер и метку времени, 
сгенерированные им самим, (N
Se
).(T
Se
). Ph может восстановить 
сообщение 
M
Ph
, сгенерированное им самим: 
 
Se  (Se,(N
Se
). (T
Se
)); 
 
Ph  (Ph, M
Ph
). 
 
6. Se и Ph полагают, что (T
Se
), созданное Se, является новой отметкой 
времени: 
 
Se  ((T
Se
)); 
 
Ph  ((T
Se
)). 
 
7. Se считает, что в данный момент времени (N
Se
) изменился: 
 
Описание протокола 
P
B
: 

160 
Шаг 1. Предварительных нет условий. Ph отправляет свой 
сертификат 
Se: 
 
Ph  Se:(Ph). 
 
Шаг 2. Предварительное условие  –  
Se необходимо проверить 
сертификат 
Ph и тем самым получить открытый ключ Ph: 
 
Se  (Ph, k
Ph.open
). 
 
Se генерирует M
Se
, который состоит из одноразового номера 
(
N
Se
), отметки времени сервера (T
Se
), а также тега получателя 
(
ID
Ph
), который Se получает от (Ph), полученного в предыдущем 
сообщении. 
Se не требует конфиденциальности по отношению к M
Se
. 
Затем он отправляет свой сертификат (
Se), M
Se
 и свою подпись над 
хешем 
M
Se
 в Ph. Предполагаем, что Se отслеживает все M
Se
, которые 
он создает для определенного 
Ph: 
 
Se  Ph:(Se).M
Se
.r
v
((M
Se
),Se). 
 
Шаг 3. Предварительные три условия: 
1. 
Ph должен извлечь открытый ключ Se и убедиться, что M
Se
 
исходит от 
Se: 
 
Ph  (Se, k
Se.open
); 
 
Ph  G(M
Se
, Se). 
 
2. 
Ph должен гарантировать, что M
Se
 изменился и 
неповрежденный: 
 
Ph  #(M
Se
); 
 
Ph  (M
Se
, Se). 
 
3. 
Ph должен убедиться, что M
Se
 подтверждает ID, 
принадлежащий 
Ph, чтобы он был предназначен для Ph, а не для 
других 
Ph': 

161 
Ph  w
p
(M
Se
, (ID
Ph
)). 
 
Затем 
Ph отправляет хешированный M
Se
 в Sm: 
 
Ph  Sm:(M
Se
). 
 
Шаг 4. Предварительных нет условий. 
Sm вычисляет свою 
подпись по хешу 
M
Se
 и возвращает подпись, а также свой сертификат. 
 
Sm  Ph:(Sm).r
v
((M
Se
),Sm). 
 
Шаг 5. Предварительные два условия: 
1. 
Ph должен сначала проверить сертификат Sm (срок действия, 
срок действия, 
CRL и т.д.) И извлечь открытый ключ Sm. 
 
Ph  (Sm, k
Sm.open
). 
 
2. 
Ph должен проверить, что Sm подтвердил (произнес) M
Se
, 
чтобы исключить любую повторную атаку. 
Ph также проверяет, не 
повреждена ли 
M
Se
: 
 
Ph  G(M
Se
, Sm); 
 
Ph  (M
Se
, Sm). 
 
Пусть 
M
Sm
  r
v
((M
Se
),Sm); M
Sm
 можно рассматривать как 
недавно созданный и глобально уникальный платежный запрос, в 
котором услуга и продавец идентифицируются с помощью 
Sm, а 
время и покупатель идентифицируются с помощью 
M
Se
. Затем Ph 
готовит свои платежные реквизиты, такие как выбранный номер 
PAN, обозначаемый строкой 
M
Ph
. Ph подписывает хеш M
Ph
.M
Sm
 и тем 
самым эффективно связывает свое согласие с M
Ph
 и M
Sm
. Наконец, Ph 
передает сертификат 
Sm, зашифрованную строку через M
Ph
.M
Sm
 и 
подписанный хеш: 
 
Ph  Se:(Sm).r
p
(M
Ph
.r
v
((M
Ph
.M
Sm
),Ph),Se). 
 
Шаг 6. Предварительные три условия    –    сервер должен 
проверить ряд элементов перед отправкой квитанции: 

162 
1. Сначала сервер проверяет сертификат Sm, (Sm) и извлекает 
открытый ключ 
Sm: 
 
Se  (Sm, k
Sm.open
). 
 
2. Затем 
Se извлекает M
Se
, которое было отправлено Ph, из своей 
базы данных. 
Se проверяет, что M
Se
 подтвержден Sm и подтверждение 
не повреждено: 
 
Se  G(M
Se
, Sm); 
 
Se  (M
Se
, Sm). 
 
3. 
Se необходимо убедиться, что M
Ph
.M
Sm
 произносится Ph и не 
поврежден: 
 
Se  G(M
Ph
.M
Sm
, Ph); 
 
Se  (
M
Ph
.M
Sm
, Ph). 
 
Далее 
Se выдает квитанцию. Он создает подпись поверх хеша 
(
ID
Sm
), M
Se
 и M
Ph
, которая эффективно подтверждает транзакцию 
между (
ID
Ph
) и (ID
Sm
) в момент времени (T
Se
) с платежной 
информацией, как описано в 
M
Ph
: 
 
Se  Ph:r
v
(((ID
Sm
).M
Se
.M
Ph
), Se). 
 
Шаг 7. Алгоритм работы протокола закончен. 
 
Постусловия: 
1. Утверждения, принадлежащие 
Ph, по последнему сообщению, 
которое получил 
Ph. Ph утверждает, что он происходит от Se, он не 
поврежден, и делает вывод: 
 
Ph  G((ID
Sm
).M
Se
.M
Ph
, Se); 
 
Ph  ((ID
Sm
).M
Se
.M
Ph
, Se). 
 

163 
2. Неопровержимый платеж от Ph: Ph предоставил свою 
платежную информацию 
M
Ph
 и привязал себя к услуге и времени. 
Если 
Ph позже опровергнет, что он согласился оплатить услуги, 
идентифицированные идентификатором смарт-карты (
ID
Sm
) в 
момент времени (
T
Se
) с платежными реквизитами M
Ph
, платежный 
сервер 
Se может предоставить неопровержимые доказательства 
арбитру. Формально это: 
- 
Se предлагает посредством свидетельства M
Sm
 и строки M
Se
 
передаваемое доказательство того, что 
Sm связывает свою 
идентичность с 
M
Se
:  
 
Se  (Se, G(M
Se
, Sm)); 
 
Se  (Se, (M
Se
, Sm)); 
 
- 
Se предлагает передаваемое доказательство того, что Ph связал 
свою личность с платежной информацией 
M
Ph
 и тем же M
Sm
, 
 
Se  (Se, G(M
Ph
.M
Sm
, Ph)); 
 
Se  (Se, (M
Ph
.M
Sm
, Ph)). 
 
таким образом, доказывает, что 
Ph согласился приобрести услугу, 
обозначенную (
ID
Sm
), с платежной информацией M
Ph
 и на 
конкретное время, как указано в (
T
Se
). 
3. Неопровержимое подтверждение платежа. Кроме того,  Se  не 
может позже опровергнуть, что он не получил приемлемого платежа 
от 
Ph. Ph может предъявить передаваемое доказательство арбитру о 
принятии 
Se оплаты Ph. Доказательства связывают согласие Se с 
личностями 
Ph и Sm, а также с платежной информацией и временем 
транзакции. 
 
Ph  (Ph, G((ID
Sm
).M
Se
.M
Ph
, Se)); 
 
Ph  (Ph, ((ID
Sm
).M
Se
.M
Ph
, Se)). 
 
Программная реализация алгоритм 
P
B
 успешно отработала до 
конца без нарушения предварительных условий. Кроме того, все 

164 
постусловия были действительны на момент завершения. P
B
 является 
надёжным протоколом. Это означает, что протокол 
P
B
 соответствует 
набору бизнес-требований и целей безопасности, отраженных в 
предварительных и постусловиях. Кроме того, он соответствует 
предпосылкам вышеупомянутого набора исходных предположений. 
Все исходные предположения должны быть выполнены, прежде чем 
можно будет утверждать, что 
P
B
 надёжный протокол. 
Теперь рассмотрим две возможные атаки, полученные при 
применении функции преобразования 
F
A
 к P
B
. 
I. Секретная атака. 
Представляем злоумышленника, который прослушивает весь 
передаваемый трафик, не внося никаких изменений в передачу. Это 
перехватывающая атака через 
P
B
, обозначенная как P
B.Attack
. 
Диаграмма последовательностей для 
P
B.Attack
 представлена на рис. 48. 
Протокол аналогичен на 
P
B
, за исключением того, что каждая 
передача в 
P
B
 теперь проходит через злоумышленника H*. 
Набор исходных предположений аналогичен, как и для 
P
B
, за 
исключением того, что 
H* теперь знает открытый ключ центра 
сертификации 
N, Se, Ph и Sm. Таким образом, мы имеем: 
 
H*  (N, k
N.open
); 
 
H*  (Se, k
Se.open
); 
 
H*  (Ph, k
Ph.open
); 
 
H*  (Sm, k
Sm.open
). 
 
Кроме того, предполагаем, что 
N и Se заслуживают доверия 
злоумышленника:  
 
H*  N  trustworthy; 
 
H*  Se  trustworthy. 
 
Постусловия такие же, как и в исходном протоколе 
P
B
, 
поскольку 
H* не изменяет никаких сообщений, и Se, Ph и Sm 
участвуют в 
P
B,Attack
 до завершения своих соответствующих ролей. 

165 
 
Рис. 48. Схема последовательности UML для протокола 
P
B.Attack
, 
случай с подслушивателем 

166 
Предварительные условия и последовательность передачи 
сообщений представлены в табл. 18. 
 
Таблица 18 
Предварительные условия и обмен сообщениями для протокола атаки 
P
B.Attack
 
Последовательность 
Предварительные 
условия 
Обмен сообщениями 
1 
Нет 
Ph  H*:(Ph) 
2 
Нет 
H*  Se:(Ph) 
3 
Se  (Ph, k
Ph.open
) Se  H*:(Se).M
Se
.r
v
((M
Se
), Se) 
4 
Нет 
H*  Ph:(Se).M
Se
.r
v
((M
Se
), Se) 
5 
Ph  (Se, k
Se.open
), 
Ph  G(M
Se
, Se), 
Ph  #(M
Se
), 
Ph  (M
Se
, Se), 
Phw
p
(M
Se
,(ID
Ph
)) 
Ph  H*:(M
Se
) 
6 
Нет 
H*  Sm:(M
Se
) 
7 
Нет 
Sm  H*:(Sm).r
v
((M
Se
), Sm) 
8 
Нет 
H*  Ph: (Sm).r
v
((M
Se
), Sm) 
9 
Ph  (Sm, k
Sm.open
), 
Ph  G(M
Se
, Sm), 
Ph  (M
Se
, Sm) 
Ph  
H*:(Sm).r
p
(M
Ph
.M
Sm
.r
v
((M
Ph
.M
Sm
),Ph),Se) 
10 Нет 
H*  Se: 
(Sm).r
p
(M
Ph
.M
Sm
.r
v
((M
Ph
.M
Sm
),Ph),Se) 
11 
Se  (Sm, k
Sm.open
), 
Se  G(M
Se
, Sm), 
Se  (
M
Se
, Sm), 
Se  G(M
Ph
.M
Sm
,Ph), 
Se  (M
Ph
.M
Sm
,Ph) 
Se  H*:r
v
(((ID
Sm
).M
Se
.M
Ph
), Se) 
12 
Нет
 
H
*  Ph:r
v
(((ID
Sm
).M
Se
.M
Ph
), Se) 

167 
Последовательность передач теперь включает в себя те 
последовательности, которые были получены и переданы 
нарушителем 
H*. Утверждения злоумышленника, которые мы 
требуем для 
P
B.Attack
, просто заключаются в том, что перехватчик не 
получает реквизиты платежа, отправленные от 
Ph: 
 

H*  (H*, M
Ph
). 
 
Предполагаем, что 
Sm и Se не предъявляют никаких требований 
к конфиденциальности. 
Se генерирует новую M
Se
, которая может быть 
публично видна, а 
Sm может раскрыть свою идентичность, а также 
(
M
Se
). 
Программная реализация алгоритма 
P
B.Attack
 показала, что 
протокол успешно завершен, и все постусловия и утверждения 
злоумышленников действительны. Программа возвращает 
true, и, 
таким образом, протокол 
P
B
 надежен и безопасен при атаке P
B.Attack
. 
II. Атака с использованием ретрансляции. 
Далее моделируем ретрансляционную атаку на 
P
B
, 
обозначенную как 
P
B2.Attack
. Схема последовательности    UML    
представлена на рис. 49. 
Злоумышленник 
H* не позволяет Sm получить (M
Se
), и H* 
передает (
M
Se
) на вторую аутентифицированную смарт-карту Sm' 
для подписи. Затем 
H* возвращает эту подпись Ph. Ph думает, что он 
прослушивал 
Sm, но на самом деле он получил доказательства 
прослушивания для другой смарт-карты, возможно, в другом 
географическом месте. Обратите внимание, что 
Sm не участвует в 
этом протоколе. 
Исходные предположения такие же, как у 
P
B.Attack
. 
Последовательность передач и их предварительные условия 
представлены на в табл. 19. 

168 
 
Рис. 49. Схема последовательности UML для атаки 
P
B2.Attack
, случай со 
второй аутентифицированной смарт-картой. 

169 
Таблица 19 
Предварительные условия и обмен сообщениями для протокола атаки 
P
B2.Attack
 
Последовательность 
Предварительные 
условия 
Обмен сообщениями 
1 
Нет 
Ph  Se:(Ph) 
2 
Se  (Ph, k
Ph.open
) Se  Ph:(Se).M
Se
.r
v
((M
Se
),Se) 
3 
Ph  (Se, k
Se.open
), 
Ph  G(M
Se
, Se), 
Ph  #(M
Se
), 
Ph  (M
Se
, Se), 
Ph w
p
(M
Se
,(ID
Ph
))
Ph  H*:(M
Se
) 
4 
Нет 
H*  Sm:(M
Se
) 
5 
Нет 
Sm  H*:(Sm).r
v
((M
Se
), Sm) 
6 
Нет 
H*  Ph:(Sm).r
v
((M
Se
), Sm) 
7 
Ph  (Sm, k
Sm.open
),
Ph  G(M
Se
, Sm), 
Ph  (M
Se
, Sm) 
Ph  
Se:(Sm).r
p
(M
Ph
.M
Sm
.r
v
((M
Ph
.M
Sm
),Ph),Se) 
8 
Se  (Sm, k
Sm.open
), 
Se  G(M
Se
, Sm), 
Se  (M
Se
, Sm), 
Se  G(M
Ph
.M
Sm
,Ph), 
Se  (M
Ph
.M
Sm
,Ph)
Se  Ph:r
v
(((ID
Sm
).M
Se
.M
Ph
),Se) 
 
Предварительные условия для обмена сообщениями 7 и 8 теперь 
относятся к 
Sm'. Это связано с тем, что они были семантически 
связаны со смарт-картой при передаче сообщения   6,   которое 
возвращается злоумышленником, выполнившим перенаправление 
сообщения (табл.     19).     Набор постусловий и утверждений 
злоумышленника модифицируется в соответствии с этим изменением 
по сравнению с исходным протоколом. 
Далее представлены постусловия, которые накладываем на 
протокол атаки 
P
B2.Attack
: 

170 
1. Утверждения Ph по последнему сообщению, которое получил 
Ph. Ph утверждает, что он происходит от Se, он не поврежден, и 
делает вывод (
ID
Sm
).M
Se
.M
Ph
: 
 
Ph  G((ID
Sm
).M
Se
.M
Ph
, Se); 
 
Ph  ((ID
Sm
).M
Se
.M
Ph
, Se). 
 
2. Утверждения по общему протоколу по завершении: 
- Неопровержимая выплата от 
Ph: 
 
Se  (Se, G(M
Se
, Sm)); 
 
Se  (Se, (M
Se
, Sm)); 
 
Se  (Se, G(M
Ph
.M
Sm
, Ph)); 
 
Se  (Se, (M
Ph
.M
Sm
, Ph)). 
 
- Неопровержимое подтверждение платежа: 
 
Ph  (Ph, G((ID
Sm
).M
Se
.M
Ph
, Se)); 
 
Ph  (
Ph, ((ID
Sm
).M
Se
.M
Ph
, Se)). 
 
3. Утверждение злоумышленника, которое мы накладываем на 
P
B2.Attack
, состоит в том, что H* не может восстановить M
Ph
: 
 

H*  (H*, M
Ph
). 
 
Отличие спроектированного протокола P
B
 от стандартного 
протока  NFC  в том, что до шага  5  в стандартном протоколе 
Ph не 
проверяет, является ли 
Sm предполагаемым продавцом / товаром для 
покупки. В стандартном протоколе не было указано никаких 
предварительных условий, отражающих это требование 
безопасности. Иначе говоря, 
Ph не заботится, было ли доказательство 
прослушивания от 
Sm или какого-то Sm'. 

171 
На практике приложение, работающее на телефоне, может 
представить окно (диалоговую форму) подтверждения и попросить 
клиента подтвердить, что все, что 
Ph получает обратно от Sm, 
является согласованным, прежде чем 
Ph примет транзакцию. 
Разработанная модель протокола может обеспечить эту 
дополнительную меру предосторожности в виде предварительного 
условия для шага  5  в 
P
B
: Ph  w
p
((Sm),(ID
Sm
)), где (Sm)  –  это 
сертификат определенного 
Sm, который получает Ph, а (ID
Sm
)  –  это 
идентификатор смарт-карта (то есть подразумеваемые товары для 
покупки), которая является ожиданием покупателя. 
Это поднимает интересную проблему для некоторых 
приложений бесконтактных платежей, таких как оформление билетов 
на общественный транспорт, в которых сервер должен иметь 
возможность определять географическое положение любого 
платежного устройства для целей расчета тарифов и аудита. В 
традиционных 
протоколах контактных платежей можно 
предположить, что действительная транзакция между покупателем и 
продавцом физически происходит на считывающем устройстве 
продавца (предполагаем, что считыватель карт заслуживает доверия). 
То есть банковская карта физически присутствовала в считывающем 
устройстве продавца на основе технологии бесконтактной передачи 
транзакций на банковском терминале. 
С другой стороны, протокол бесконтактных мобильных 
платежей работает
 в непосредственной близости, но физический 
контакт не требуется. Это разделение, продемонстрированное на 
примере атаки 
P
B2.Attack
, может быть увеличено. Следовательно, в 
мобильных бесконтактных протоколах мы больше не можем вывести 
физическое присутствие клиента по транзакции. Сама транзакция все 
еще может быть действительной, поскольку в простейшей 
конфигурации требуются только законные отношения между 
идентифицированным покупателем и продавцом. 
Другой интересный случай   –   когда продавец и покупатель 
являются злоумышленниками и вступают в 
сговор (и, таким образом, 
Se взаимодействует с двумя злоумышленниками). Например, Ph 
нечестен и игнорирует любые предварительные условия перед тем, 
как связаться с 
Se, после того, как он получил сообщение от Sm', 
расположенного в другом географическом месте. 
Se просто проверяет 
связь между личностью 
Ph и идентичностью Sm' и записывает, что Ph 
хотел приобрести услугу, как определено (
ID
Sm'
). Se не требует и не 

172 
может обеспечить, основываясь на ограниченной информации, что Ph 
физически находился в 
Sm'. 
При оформлении транзитных билетов с помощью мобильных 
тегов клиенты входят в систему, нажимая на смарт-карты, 
установленные на платформах на станциях. Платежный сервер 
Se 
имеет бизнес-требование для проверки согласованности физического 
местоположения клиента и сообщаемых доказательств 
прослушивания с любым конкретным 
Sm. В этой ситуации 
мобильный телефон также может передавать свои 
аутентифицированные координаты  GPS  для проверки сервера. Мы 
можем смоделировать эту проверку согласованности, выполняемую 
на платежном сервере, введя дополнительную семантику в предикат 
close By (GPS coordinates, 
Sm). 
Подводя итог, можно указать на сложность разработки 
платежных протоколов. Протоколы, которые являются безопасными 
в одном варианте использования, могут не удовлетворять всем 
требованиям бизнеса и безопасности для другого. Однако с точки 
зрения анализа протокола представленная система моделирования 
платежного протокола с разграничением прав достаточно гибкая, 
чтобы формализовать различные наборы требований, и способна 
выполнять проверки в полной автоматизации (программная 
реализация). 
 
  

173 
ЛИТЕРАТУРА 
 
 
1.
 Аверченков, В.И. Аудит информационной безопасности  /  
В.И. Аверченков. – М.: ФЛИНТА, 2011. – 269 с. 
2.
 Аверченков, В.И. Система обеспечения безопасности Российской Федерации / В.И. Аверченков, В.В. Ерохин. – Брянск: БГТУ, 
2005. – 120 с. 
3.
 Аверченков, В.И. Системы организационного управления  /  
В.И. Аверченков, В.В. Ерохин. – Брянск: БГТУ, 2006. – 208 с. 
4.
 Алиев, В.С. Информационные технологии и системы финансового менеджмента  /  В.С. Алиев.  –  М.:  «ФОРУМ»: ИНФРА-М, 
2007. 
5.
 Бауэр, Ф. Расшифрованные секреты. Методы и принципы 
криптологии / Ф. Бауэр. – М.: Мир, 2007. – 550 с. 
6.
 Бернет, С. Криптография. Официальное руководство  RSA  
Security  /  С.Бернет, С.Пейн.  –  2-е изд., стереотипное.  –  М.:  «БиномПресс», 2009. – 384 с. 
7.
 Ван-Тилборг, Х.К.А. Основы криптологии. Профессиональное руководство и интерактивный учебник  /  Х.К.А. Ван-Тилборг.  –  
М.: Мир, 2006 – 471 с. 
8.
 Василенко, О.Н. Теоретико-числовые алгоритмы в криптографии / О.Н. Василенко. – 2-е изд., доп. – М.: МЦНМО, 2006 – 326 с. 
9.
 Гольдштейн, Б.С. Сети связи     /     Б.С. Гольдштейн, 
Н.А. Соколов, Г.Г. Яновский. – СПб.: БХВ-Петербург, 2011. 
10.
 Гордеев, А.В. Операционные системы  /  А.В. Гордеев.  –  
СПб.: Питер, 2006. – 416 с. 
11.
 Дейт, К.Дж Введение в системы баз данных  /  К.Дж. Дейт  –  
М.: Издательский дом «Вильямс», 2006. – 1328 с. 
12.
 Ерохин, В.В. Безопасность информационных систем  /  В.В. 
Ерохин, Д.А. Погонышева, И.Г. Степченко.  –  М.: ФЛИНТА,  2015.  –  
184 с. 
13.
 Ерохин, В.В. Верификация информационных систем коммерческого банка  /  В.В. Ерохин, Е.В. Елисеева  //  Вестник образовательного консорциума среднерусский университет. Информационные 
технологии. – 2017. – No1(9). – С. 20-23. 
14.
 Ерохин, В.В. Защита информации электронных торговых 
сетей банков / В.В. Ерохин, Е.В. Елисеева и др. // Вопросы современ
174 
ной науки: коллект. науч. монография;  [под ред. Н.Р. Красовской].  –  
М.: Изд. Интернаука, 2017. Т. 18. – С. 123-140. 
15.
 Ерохин, В.В. Защита программного обеспечения и верификация информации в информационно-телекоммуникационных системах банка. – М.: Изд-во МГУ, 2015. – 129 с. 
16.
 Ерохин, В.В. Управление доступом к информационному и 
программному обеспечению в коммерческом банке  /  В.В. Ерохин, 
Е.В. Елисеева, А.М. Хлопяников    //    Результаты социальноэкономических и междисциплинарных научных исследований  XXI  
века: монография. – Самара: Поволжская научная корпорация, 2016. – 
С. 189-202. 
17.
 Зильбербург, Л.И. Информационные технологии в проектировании и производстве / Л.И. Зильбербург, В.И. Молочник, Е.И. Яблочников. – СПб.: Политехника, 2008. 
18.
 Игнатьев, В.А. Информационная безопасность современного коммерческого предприятия / В.А.Игнатьев – Старый Оскол: ООО 
«ТНТ», 2005. – 448 с. 
19.
 Ключников, К.К. Методы снижения сбоев в работе биллинговой системы  /  К.К. Ключников  //  Мобильные системы.  –  2007.  –  
No08 – С. 46-48. 
20.
 Кузнецов, С.Л. Современные технологии документационного обеспечения управления / С.Л. Кузнецов. – М.: МЭИ, 2010. – 232 с. 
21.
 Кэрриэ, Б. Криминалистический анализ файловых систем  /  
Б. Кэрриэ – СПб.: Питер, 2007. – 352 с. 
22.
 Марков, А.С. Методы оценки несоответствия средств защиты информации  /  А.С. Марков, В.Л. Цирлов, В.Л. Баранов. – М.: Горячая линия-Телеком, 2012. – 192 с. 
23.
 Мельников, В.П. Информационная безопасность   /   В.П. 
Мельников, С.А. Клейменов, А.М. Петраков  –  М.: Издательский 
центр «Академия», 2012. – 336 с. 
24.
 Олифер, В.Г. Компьютерные сети  /  В.Г. Олифер [и др.].  –  
СПб.: Питер, 2008. – 958 с. 
25.
 Олифер, В.Г. Сетевые операционные системы / В.Г. Олифер, 
Н.А. Олифер. – СПб.: Питер, 2009. – 672 с. 
26.
 Панасенко, С. Алгоритмы шифрования. Специальный справочник / С.Панасенко. – СПб.: БХВ-Петербург, 2009. – 578 с. 
27.
 Платонов, В.В. Программно-аппаратные средства обеспечения информационной безопасности вычислительных сетей   /   В.В. 
Платонов – М.: Издательский центр «Академия», 2006. – 240 с. 

175 
28. Скиба, В.Ю. Руководство по защите от внутренних угроз 
информационной безопасности  /  В.Ю. Скиба, В.А. Курбатов  –  СПб.: 
Питер, 2008. – 320 с. 
29.
 Созыкин, А.В. Модели и методы создания интегрированной 
инфраструктуры управления доступом к сервисам  /  А.В. Созыкин  //  
Системы управления и информационные технологии.   –   2007.   –   
No4.1(30). – С. 191-195. 
30.
 Тихонов, В.А. Информационная безопасность: концептуальные, правовые, организационные и технические аспекты  /  В.А. 
Тихонов, В.В. Рай – М.: Солон-пресс, 2006. – 528 с. 
31.
 Трофимов, В.В. Информационные системы и технологии в 
экономике и управлении     /     В.В. Трофимов, О.П. Ильина, 
Е.В. Трофимова, В.И. Кияев, Приходченко А.П.  /  под ред. проф. 
В.В.Трофимова. – М.: КНОРУС, 2011. 
32.
 Хорев, П.Б. Методы и средства защиты информации в компьютерных системах / П.Б. Хорев. – М.: Издательский центр «Академия», 2008. – 256 с. 
33.
 Anada,  H.,  Yasuda,  T.,  Kawamoto,  J.,  Weng,  J.,  Sakurai,  K.  
(2019).  RSA  public  keys  with  inside  structure:  Proofs  of  key  generation  
and   identities   for   web-of-trust.
   Journal   of   Information   Security   and   
Applications, 45
, 10-19. doi:10.1016/j.jisa.2018.12.006. 
34.
 Asokan, N., Nyman, T., Rattanavipanon, N., Sadeghi, A. -., Tsudik, G. (2018). ASSURED: Architecture for secure software update of realistic  embedded  devices.
  IEEE  Transactions  on  Computer-Aided  Design  
of       Integrated       Circuits       and       Systems,       37
(11),       2290-2300.       
doi:10.1109/TCAD.2018.2858422. 
35.
 Bailey,  D.  V.,  Dürmuth,  M.,  Paar,  C.  (2014).  Statistics  on  password     re-use     and     adaptive     strength     for     financial     accounts.     
doi:10.1007/978-3-319-10879-7_13. 
36.
 Bailey, D.V., Brainard, J., Rohde, S., Paar, C. (2009). One-touch 
financial  transaction  authentication.  Paper  presented  at  the  
ICETE  2009  -  
International Joint Conference on e-Business and Telecommunications, 
512. 
37.
 Bailey,  D.V.,  Brainard,  J.,  Rohde,  S.,  Paar,  C.  (2011).  Wireless 
authentication   and   transaction-confirmation   token.   
doi:10.1007/978-3642-20077-9_13. 
38.
 Brasser,    F.,    Capkun,    S.,    Dmitrienko,    A.,    Frassetto,    T.,    
Kostiainen, K., Sadeghi, A. -. (2019). Dr.SGX: Automated and adjustable 
side-channel  protection  for  sgx  using  data  location  randomization.  Paper  

176 
presented  at  the  ACM  International  Conference  Proceeding  Series,  788800. doi:10.1145/3359789.3359809. 
39.
 Brasser, F., Müller, U., Dmitrienko, A., Kostiainen, K., Capkun, 
S., Sadeghi, A. -. (2017). Software grand exposure: SGX cache attacks are 
practical.  Paper  presented  at  the  
11th  USENIX  Workshop  on  Offensive  
Technologies, WOOT 2017, Co-Located with USENIX Security 2017.
 
40.
 Bulychev, P. Computing (bi)simulation relations preserving ctlx 
logic  for  ordinary  and  fair  kripke  structures  /  P.  Bulychev,  I.  Konnov,  V.  
Zakharov  //  Труды Института системного программирования РАН.  –  
2007. – Vol. 12. – Pp. 59-76. 
41.
 Calder,  M.  Detecting  feature  interactions:  how  many  components do we need? / M. Calder, A. Miller // Objects, Agents and Features. 
– 2004. – Vol. 2975. – Pp. 45-66. 
42.
 Cheng, L., Liljestrand, H., Ahmed, M.S., Nyman, T., Jaeger, T., 
Asokan,  N.,  Yao,  D.D.  (2019).  Exploitation  techniques  and  defenses  for  
data-oriented attacks. Paper presented at the 
Proceedings - 2019 IEEE Secure              Development,              SecDev              2019,              
114-128. 
doi:10.1109/SecDev.2019.00022. 
43.
 Danev, B., Heydt-Benjamin, T. S., Čapkun, S. (2009). Physicallayer identification of RFID devices. Paper presented at the 
Proceedings of 
the 18th USENIX Security Symposium, 
199-214. 
44.
 Dhar, A., Puddu, I., Kostiainen, K., Capkun, S. (2020). ProximiTEE: Hardened SGX attestation by proximity verification. Paper presented 
at the 
CODASPY 2020 - Proceedings of the 10th ACM Conference on Data          and          Application          Security          and          Privacy,          
5-16. 
doi:10.1145/3374664.3375726. 
45.
 Ekberg,  J.  -.,  Kostiainen,  K.,  Asokan,  N.  (2014).  The  untapped  
potential  of  trusted  execution  environments  on  mobile  devices.
 IEEE 
Security and Privacy, 12
(4), 29-37. doi:10.1109/MSP.2014.38. 
46.
 Emerson,  E.A.  Parameterized  model  checking  of  ring-based  
message passing systems / E.A. Emerson, V. Kahlon // Computer Science 
Logic. – 2004. – Vol. 3210/2004 of LNCS. – Pp. 325-339. 
47.
 EMVC0.  The  EMV  4.3  Specifications  -  Book  2  -  Security  and  
Key  Management  [online],  2011.  Avaiable  at:  http  :  //www.emvco.com    
specifications.aspx?id = 223. 
48.
 EMVC0.  The  EMV  Contactiess  Specifications  -  Book  D:  Contactless   Communication   Protocol   [online],   2011.   Avaiable   at:   http                  
www.emvco.com/specifications.aspc?id = 21. 

177 
49. Erokhin  V.V., Fetshchenko  V.V.,  Panina  I.S.,  Kazimirova  N.P.,  
Novikov S.P., Novikova A.V. Verification of Computer Systems of Commercial  Bank  //  International  Journal  Of  Applied  Business  and  Economic  
Research. – 2017. – Volume 15, Number 12. – Р. 297 – 306. 
50.
 Erokhin  V.V., Kulikova  G.A.,  Mudrova  N.V.,  Shadoba  E.M.,  
Romanov  V.A.  Podobai  N.V.
 Controlling  Access  to  the  Information  and  
Software in a Commercial Bank // International Journal Of Applied Business and Economic Research. – 2017. – Volume 15, Number 12. – Р. 159 
– 170. 
51.
 Fan, J., Bailey, D.V., Batina, L., Güneysu, T., Paar, C., Verbauwhede, I. (2010). Breaking elliptic curve cryptosystems using reconfigurable  hardware.  Paper  presented  at  the  
Proceedings  -  2010  International  
Conference   on   Field   Programmable   Logic   and   Applications,   FPL   
2010, 
133-138. doi:10.1109/FPL.2010.34. 
52.
 Foltz, K., Simpson, W.R. (2020). Public key infrastructure issues 
for enterprise level security. Paper presented at the 
ICEIS 2020 - Proceedings of the 22nd International Conference on Enterprise Information Systems,
 91-98. 
53.
 Hawanna, V., Kulkarni, V. Y., Rane, R. A. (2017). Risk assessment  of  X.509  certificate  by  evaluating  certification  practice  statements.  
Paper  presented  at  the  
International  Conference  on  Computing,  Analytics  
and              Security              Trends,              CAST              2016,              
501-506. 
doi:10.1109/CAST.2016.7915020. 
54.
 Heydt-Benjamin, T.S., Bailey, D.V., Fu, K., Juels, A., O'Hare, T. 
(2007). 
Vulnerabilities      in      first-generation      RFID-enabled      credit      
cards.
 doi:10.1007/978-3-540-77366-5_2. 
55.
 IETF  Internet  Engineering  Task  Force.  US  Secure  Hash  Algorithm         1         (SHAI)         [online],         2012.         Available         at:         
http://tools.ietf.org/html/rfc3174. 
56.
 IETF  Internet  Engineering  Task  Force.  Using  SHA2  algorithms  
with    cryptographic    message    syntax    [online],    2012.    Available    at:    
http//tools.ietf.org/html/rfc5754. 
57.
 IETF-RFC5246.  The  Transport  Layer  Security  (TLS)  protocol  
version 1.2 [online], 2008. Avaiable at: http : //tools.ietf.org/html/rfc5246. 
58.
 ISO/1EC-14443.  Identification  cards  Contactless  integrated  circuit      cards      Proximity      cards      [online]      2008.      Avaiable      at:      
http//www.iso.org/iso/iso-catalogue/catalogue-icscatalogue-detailics.htm?csnumber = 28730. 

178 
59. ISO/1EC-7813.  Information  technology  Identification  cards  Financial       transaction       cards       [online],       2008.       Avaiable       at:       
http//www.iso.org/iso/iso-catalogue/catalogue-tc/cataloguedetail.htm?csnumber 43317. 
60.
 Karthikeyan,        S.,        Patan,        R.,        Balamurugan,        B.        
(2019). 
Enhancement  of  security  in  the  internet  of  things  (IoT)  by  using  
X.509 authentication mechanism. 
doi:10.1007/978-981-13-2685-1_22. 
61.
 Kelly,  D.,  Hammoudeh,  M.  (2018).  Optimisation  of  the  public  
key  encryption  infrastructure  for  the  internet  of  things.  Paper  presented  at  
the 
ACM           International           Conference           Proceeding           Series, 
doi:10.1145/3231053.3231098. 
62.
 Khan,  M.S.N.,  Marchal,  S.,  Buchegger,  S.,  Asokan,  N.  (2019).  
Chowniot:  Enhancing  IoT  privacy  by  automated  handling  of  ownership  
change
. doi:10.1007/978-3-030-16744-8_14. 
63.
 Kostiainen,  K.,  Ekberg,  J.  -.,  Asokan,  N.,  Rantala,  A.  (2009).  
On-board   credentials   with   open   provisioning.   Paper   presented   at   
the 
Proceedings  of  the  4th  International  Symposium  on  ACM  Symposium  
on    Information,    Computer    and    Communications    Security,    ASIACCS'09, 
104-115. doi:10.1145/1533057.1533074. 
64.
 Malisa, L., Kostiainen, K., Capkun, S. (2017). Detecting mobile 
application  spoofing  attacks  by  leveraging  user  visual  similarity  perception. Paper presented at the 
CODASPY 2017 - Proceedings of the 7th ACM 
Conference   on   Data   and   Application   Security   and   Privacy,   
289-300. 
doi:10.1145/3029806.3029819. 
65.
 Malisa,  L.,  Kostiainen,  K.,  Knell,  T.,  Sommer,  D.,  Capkun,  S.  
(2017). 
Hacking  in  the  blind:  (almost)  invisible  runtime  user  interface  attacks
 doi:10.1007/978-3-319-66787-4_23. 
66.
 Mannan,  M.,  Asokan,  N.  (2020).  Confronting  the  limitations  of  
hardware-assisted    security.
    IEEE    Security    and    Privacy,    18(5),    6-7.    
doi:10.1109/MSEC.2020.3015413. 
67.
 Marforio, C., Masti, R. J., Soriente, C., Kostiainen, K., Čapkun, 
S.  (2016).  Evaluation  of  personalized  security  indicators  as  an  antiphishing   mechanism   for   smartphone   applications.  Paper  presented  at  
the 
Conference  on  Human  Factors  in  Computing  Systems  -  Proceedings, 
540-551. doi:10.1145/2858036.2858085. 
68.
 Marforio,  C.,  Masti,  R.J.,  Soriente,  C.,  Kostiainen,  K.,  Capkun,  
S.  (2016).  Hardened  setup  of  personalized  security  indicators  to  counter  
phishing  attacks  in  mobile  banking.  Paper  presented  at  the  
SPSM  2016  -  
Proceedings of the 6th Workshop on Security and Privacy in Smartphones 

179 
and      Mobile      Devices,      Co-Located      with      CCS      2016,      83-92. 
doi:10.1145/2994459.2994462. 
69.
 Markert,  P.,  Bailey,  D.  V.,  Golla,  M.,  Durmuth,  M.,  Avig,  A.J.  
(2020).   This   PIN   can   be   easily   guessed:   Analyzing   the   security   of   
smartphone unlock PINs. Paper presented at the 
Proceedings - IEEE Symposium        on        Security        and        Privacy,        2020-May
 286-303. 
doi:10.1109/SP40000.2020.00100. 
70.
 Mumtaz, M., Akram, J., Ping, L. (2019). An RSA based authentication    system    for    smart    IoT    environment.    Paper    presented    at    
the 
Proceedings  -  21st  IEEE  International  Conference  on  High  Performance Computing and Communications, 17th IEEE International Conference  on  Smart  City  and  5th  IEEE  International  Conference  on  Data  Science        and        Systems,        HPCC/SmartCity/DSS        2019,        
758-765. 
doi:10.1109/HPCC/SmartCity/DSS.2019.00112. 
71.
 NFC-Forum.  NFC  Logical  Link  Control  Protocol  (LLCP)  technical       specification       [online].       2012.       Avaiable       at:       http       
www.nfcforum.org/specs/spec-list/. 
72.
 Ruan,  O.,  Zhang,  Y.,  Zhang,  M.,  Zhou,  J.,  Harn,  L.  (2018).  After-the-fact       leakage-resilient       identity-based       authenticated       key       
exchange.
 IEEE Systems Journal, 12(2),             2017-2026.             
doi:10.1109/JSYST.2017.2685524. 
73.
 Shivaprasad, S., Sadanandam, M., Sowjanya, M., Kondapalli, S. 
V.  (2019).  Deliver  an  accurate  image  on  the  digital  certificate  and  digital  
signature   using   RSA   and   SHA.
   Journal   of   Advanced   Research   in   
Dynamical and Control Systems, 11
(7), 501-514. 
74.
 Wang,  L.,  Asharov,  G.,  Pass,  R.,  Ristenpart,  T.,  Shelat,  A.  
(2019).  Blind  certificate  authorities.  Paper  presented  at  the  
Proceedings  -  
IEEE    Symposium    on    Security    and    Privacy,    2019-May
 1015-1032. 
doi:10.1109/SP.2019.00007. 
 
  

180 
ОГЛАВЛЕНИЕ 
 
ВВЕДЕНИЕ ............................................................................................... 3 
1. АНАЛИЗ АВТОМАТИЗИРОВАННЫХ МЕТОДОВ 
ПОСТРОЕНИЯ УПРАВЛЕНИЯ ДОСТУПОМ К 
ИНФОРМАЦИОННОМУ И ПРОГРАММНОМУ 
ОБЕСПЕЧЕНИЮ БАНКА ....................................................................... 8
 
1.1. Управления доступом к информационному и программному 
обеспечению в коммерческом банке ................................................................... 34
 
1.2. Анализ методов проверки корректности работы программного 
обеспечения ............................................................................................................  41
 
2. АВТОМАТИЗАЦИЯ ПРОЦЕССА УПРАВЛЕНИЯ 
ДОСТУПОМ К ИНФОРМАЦИОННОМУ И ПРОГРАММНОМУ 
ОБЕСПЕЧЕНИЮ БАНКА ..................................................................... 50
 
2.1. Автоматизация разграничения доступа к информационному и 
программному обеспечению банка ..................................................................... 50
 
2.2. Обеспечение надёжности и доступности компьютерных систем 
банка ....................................................................................................................... 74
 
3. АНАЛИЗ ДОСТОВЕРНОСТИ И ВЕРИФИКАЦИИ 
ИНФОРМАЦИИ В ИНФОРМАЦИОННОТЕЛЕКОММУНИКАЦИОННЫХ СИСТЕМАХ БАНКА ................... 84
 
3.1. Алгоритм анализа достоверности и верификации информации ............... 84 
3.2. Верификация вычислительных систем банка ........................................... 101 
3.3. Совершенствования верификации симуляций между моделями 
программ............................................................................................................... 107
 
4. АВТОМАТИЧЕСКИЙ АНАЛИЗ БЕЗОПАСНОСТИ 
ПЛАТЕЖНЫХ ПРОТОКОЛОВ .......................................................... 126
 
4.1. Протоколы бесконтактных платежей по банковским картам ................. 126 
4.2. Протоколы оплаты с использованием мобильных устройств ................. 141 
4.3. Протоколы оплаты с использованием мобильных токенов .....................  155 
ЛИТЕРАТУРА .......................................................................................  173 
 
  

 
 
Научное издание 
 
Ерохин Виктор Викторович, 
Бахадиров Хикмет Муратович  
 
ВЕРИФИКАЦИЯ ИНФОРМАЦИИ 
И ЗАЩИТА ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ 
В ИНФОРМАЦИОННО-ТЕЛЕКОММУНИКАЦИОННЫХ  
СИСТЕМАХ БАНКА 
 
Монография 
 
Издательство «Спутник +» 
109428, Москва, Рязанский проспект, д. 8А. 
Тел.: (495) 730-47-74, 778-45-60 (с 9.00 до 18.00) 
Подписано в печать 17.05.2021. Формат 60×90/16. 
Бумага офсетная. Усл. печ. л. 11,31. Тираж 25 экз. Заказ 161. 
Отпечатано в ООО «Издательство «Спутник +» 