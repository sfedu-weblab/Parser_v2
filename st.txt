В . В .  Ерохин Х . М .  Бахадиров ВЕРИФИКАЦИЯ ИНФОРМАЦИИ И ЗАЩИТА ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ В ИНФОРМАЦИОННО - ТЕЛЕКОММУНИКАЦИОННЫХ СИСТЕМАХ БАНКА Монография Москва  2021  УДК  004.056.5:004.627  ББК  32.972.53  Е   78  Авторы :  доктор технических наук ,  доцент ,  профессор кафедры математических методов и бизнес - информатики Московского государственного института международных отношений  ( университета )  МИД России Ерохин Виктор Викторович ;  магистрант направления  « Бизнес - информатика »   Московского государственного института международных отношений ( университета )  МИД России Бахадиров Хикмет Муратович Научный редактор :  доктор технических наук Лагерев Александр Валерьевич Рецензенты :  доктор технических наук Гольдфарб Вениамин Иосифович ;  доктор технических наук Лагерев Игорь Александрович Ерохин В . В .,  Бахадиров Х . М .  Е   78   Верификация информации и защита программного обеспечения в информационно - телекоммуникационных системах банка :  Монография .–  М .:  Издательство  « Спут - ник  +», 2021. – 181  с .  ISBN 978-5-9973-5919-5 Излагаются основные аспекты и характеристики технологии защиты информации в банковских телекоммуникационных системах ,  а также подходы к анализу информаци - онной безопасности банковских систем .  Решаются задачи обеспечения информационной верификации информации в компьютерных и экономических системах банка .  Монография предназначена для специалистов в области защиты компьютерных систем и студентов по направлениям подготовки  09.04.01 – « Информатика и вычисли - тельна я техника », 09.04.02 – « Информационные системы и технологии », 38.04.05 –  « Бизнес - информатика ».  Ил . 49.  Табл . 19.  Библиогр . – 74  назв .  УДК  004.056.5:004.627  ББК  32.972.53  Отпечатано с готового оригинал - макета .  ISBN 978-5-9973-5919-5 ©  Ерохин В . В .,  Бахадиров Х . М ., 2021  3  ВВЕДЕНИЕ В предлагаемой монографии излагаются основные принципы и положения формирования общих знаний в области безопасности эко - номических систем ,  в частности ,  коммерческих банков .  Современные коммерческие банки всё чаще сталкиваются с проблемой нарушения параметров защиты информационного и про - граммного обеспечения банка ,  связанной с несанкционированными действиями легальных пользователей  –  сотрудников банка .  Ведущие коммерческие банки страны ставят задачи усовершенствования меха - низмов и технологий контроля работы с информационным и про - граммным обеспечением .  В настоящее время банки используют инте - грированные информационные среды ,  технологии классов  CALS,  ERP, MRP, SCADA, CAD/CAM/CAE,  применение которых предпола - гает наличие высокого уровня защиты информационного и про - граммного обеспечения .  Существует ряд систем предотвращения не - санкционированного использования информационного и программ - ного обеспечения ,  но ни одна из них не обеспечивает комплексной защиты ресурсов банка .  Необходимость обеспечения комплексной защиты информационных и программных ресурсов требует разработ - ки единой ,  интегрированной в основную информационную среду банка ,  системы ,  основной задачей которой является предотвращение максимального количества видов  « инсайдерских »  атак .  Сложность структуры информационного и программного обеспечения коммер - ческого банка определяет сложность структуры разрабатываемой ав - томатизированной системы разграничения доступа к информацион - ному и программному обеспечению  ( АСРДкИПО ).  Большинство вычислительных систем ,  используемых для техни - ческих ,  инженерных ,  коммерческих ,  научных целей имеют сложную архитектуру .  Будучи состоящими из множества взаимодействующих компонентов ,  современные вычислительные системы подвержены сбоям ,  причем сбои могут происходить как вследствие отказа обору - дования ,  так и вследствие некорректной работы программного обес - печения .  В этой связи ,  все большее значение и актуальность приобре - тают математические методы оценки влияния сбоев на работу ком - пьютерных систем .  Одним из подходов к рассматриваемым пробле - мам является вероятностный .  4  Проблема анализа качества аппаратного и программного обес - печения  ( ПО )  становится сегодня все более острой ,  особенно по мере расширения использования в информационных банковских техноло - гиях при разработке ПО .  Экспоненциальный рост сложности аппаратного и программно - го обеспечения вычислительных процессов порождает повышенные требования к бездефектному проектированию .  Известны примеры ,  как дорого обходятся ошибки ,  допущенные на различных этапах про - ектирования ,  поэтому все современные ИС обязательно снабжаются методологическими ,  программными и инструментальными средства - ми анализа разрабатываемого изделия на всех этапах автоматизиро - ванного проектирования .  Не менее актуальными являются проблемы ,  связанные с обеспечением проектирования надежного ПО .  Большой вклад в становление и развитие методов решения данной проблемы внесли отечественные ученые Пархоменко П . П .,  Липаев В . В .,  Сого - монян Е . С .,  Майоров С . А .,  Немолочнов О . Ф .,  Рябов Г . Г .,  Селютин В . А .,  Курейчик В . М .  и многие другие .   В настоящее время сложилось несколько подходов к проверке правильности программного обеспечения  ( ПО ):  тестирование ,  теоре - тико - доказательный подход и верификация моделей программ .   Наиболее распространённым методом является тестирование .  При тестировании на вход программе подаются заранее приготовлен - ные тестовые данные и проверяется соответствие результата ,  выдан - ного программой ,  ожидаемому .  Важным свойством ,  используемом при тестировании ,  является свойство детерминированности алгорит - ма .  В случае распределённого ПО ,  использующего несколько процес - сов и выполняющегося на нескольких ЭВМ ,  поведение ПО становит - ся существенно неоднозначным .  В этом случае для проверки поведе - ния ПО в ходе вычисления могут использоваться средства трассиров - ки .  Методы верификации направлены на доказательство утвержде - ний о свойствах поведения ПО или результатов её работы .  Этот под - ход к проверке правильности ПО был впервые предложен в работах А . А .  Ляпунова ,  Т .  Хоара ,  Э .  Дейкстры ,  Пратта и Флойда .  Методы верификации ПО ,  использующие теоретико - доказательный подход ,  основываются на средствах автоматического доказательства теорем  ( САДТ , theorem prover, « прувер »).  Описание ПО представляется в виде множества логических утверждений .  Спе - цификация ПО также представляется в виде утверждения .  САДТ 5  строит доказательство выполнимости спецификации ,  исходя из утверждений ,  описывающих проверяемое ПО .  При использовании САДТ в процессе построения доказатель - ства может потребоваться участие эксперта .  Одной из наиболее труд - ных задач ,  возникающих при верификации ПО с помощью САДТ ,  яв - ляется задача порождения инварианта цикла .  Инвариант цикла требу - ется при проверке выводимости постусловия функции из предусло - вия .   Верификация ПО с использованием логических утверждений ,  построенных непосредственно на основании исходных кодов ПО ,  увеличивает сложность процесса доказательства .  Некоторые фраг - менты кода могут быть несущественными для проверки выделенных свойств ПО .  Свойства ПО могут быть проверены на модели ПО ,  бо - лее простой ,  чем исходное ПО .  Группа методов ,  основанных на ве - рификации моделей  (Model Checking, MC),  использует компромисс - ный подход между полноценной верификацией ПО и тестированием ,  использующим формальную проверку свойств .  В области ЭВМ исследуются классы ИС ,  параметризованных по числу взаимодействующих компонентов :    распределённые алгоритмы :  волновые алгоритмы ,  распределе - ния ресурсов ,  взаимного исключения доступа к критической секции ,  избрания лидера  (leader election),  обнаружения завершения (termination detection),  согласованного принятия транзакции (distributed commit);   сетевые протоколы :  кольцо с маркером ,  протоколы маршрути - зации ,  протоколы обеспечения качества сервиса ,  широковещательные протоколы ;   аппаратные схемы :  аппаратные схемы управления доступом к шине при различном числе клиентских устройств ,  протоколы обеспе - чения когерентности кэшей .  При построении модели распределённой ИС ,  которая может по - тенциально содержать любое количество однотипных процессов ,  ограничиваются моделью с небольшим ,  фиксированным числом про - цессов .  Предполагается ,  что свойства ,  проверенные на модели с фик - сированным числом процессов ,  автоматически масштабируются для моделей с большим числом процессов .  Однако этот приём не являет - ся вполне корректным :  известны примеры ,  когда спецификация была верна на модели с одним числом процессов и нарушалась при изме - нении числа процессов .  6  Это означает ,  что для верификации параметризованных моделей ПО недостаточно проверить спецификацию на нескольких моделях с фиксированным числом процессов :  необходимо обоснование мас - штабируемости проверенной спецификации на остальные модели .  Так как число процессов в моделях не ограничено ,  то спецификация должна быть проверена на бесконечном семействе моделей с конеч - ным числом состояний .   Наиболее перспективными методами ,  настраиваемыми на раз - личные виды топологии параметризованных систем ,  являются мето - ды ,  основанные на поиске инвариантов ,  и символьные методы .  Символьные методы верификации параметризованных систем могут потребовать участия эксперта для переработки модели и указа - ния дополнительных подсказок .   Помимо верификации моделей с произвольным числом одно - типных процессов алгоритмы решения задачи  PMC  позволяют про - водить редукцию моделей с большим числом однотипных процессов к моделям с малым числом процессов .  Решение задачи  PMC  имеет практический смысл даже тогда ,  когда рассматриваются модели с фиксированным ,  но очень большим числом процессов .  В этом случае задача ,  требующая недоступных на практике вычислительных ресур - сов ,  может быть сведена к практически решаемой задаче .  Задача верификации параметризованных моделей распределён - ных ИС актуальна .  Однако при разработке таких методов и средств необходимо сохранить основное преимущество метода  MC –  свой - ство автоматической верификации модели .  Необходимо ,  чтобы для верификации параметризованной модели не требовалась существен - ная перестройка модели ,  использованной при верификации средства - ми  MC,  или участие эксперта .  В четвертой главе использовался формальный анализ для разра - ботки и проверки платежных протоколов ,  но ,  несмотря на развитие семантики и выразительности ,  в литературе мало внимания уделялось аспектам автоматизации систем подтверждения платежей в банков - ской системе .  Это исследование совершенствует платформу автома - тизированного анализа для платежных протоколов .  Усовершенствована комплексная и автономная система под - тверждения ,  которая позволяет в платежных системах повысить кон - фиденциальность ,  целостность ,  аутентификацию ,  актуальность ,  под - тверждение и неотказуемость .  Моделируются общие примитивы без - опасности ,  такие как шифрование ,  дешифрование ,  цифровые подпи - 7  си ,  дайджесты сообщений ,  коды аутентификации сообщений и сер - тификаты  X.509.  Представлен автоматизированный анализ реальных протоколов платежей по банковским картам ,  а также протоколов бесконтактных мобильных платежей .  В некоторых протоколах обнаружены недо - статки безопасности ;  рассматриваются их причины и последствия .  По тематике настоящей монографии имеется достаточно об - ширная литература ,  однако в них недостаточно изложены вопросы практического применения основных правил функционирования раз - личных технологий безопасности информации в коммерческих бан - ках .  Это дает нам право предложить данную монографию в качестве ключевого систематизированного материала для более полного и до - статочного изучения экономической безопасности в области техноло - гий обработки информации коммерческим банком .  8  1.  АНАЛИЗ АВТОМАТИЗИРОВАННЫХ МЕТОДОВ ПОСТРОЕНИЯ УПРАВЛЕНИЯ ДОСТУПОМ К ИНФОРМАЦИОННОМУ И ПРОГРАММНОМУ ОБЕСПЕЧЕНИЮ БАНКА На сегодняшний день существует множество систем защиты информационного и программного обеспечения от внутренних угроз .  Одной из наиболее популярных технологий является технология  IPC  (Information Protection and Control).  Основные функции ,  выполняемые технологией  IPC:  -  предотвращение различных видов утечек информационных ре - сурсов ;  -  защита информационных и программных ресурсов от внутрен - них угроз ;  -  предупреждение промышленного шпионажа .  К информационным ресурсам банка относятся :  -  данные банка о разработках ,  проектах ;  -  персональные данные сотрудников банка .  К данным банка о проектах можно отнести :  -  технические задания ;  -  программные коды разработок ;  -  проектно - конструкторскую документацию ;  -  сопровождающую документацию ;  -  экономические характеристики проектов .  К персональным данным сотрудников банка относятся :  -  номера паспортов ;  -  номера документов ,  заверяющих личность ;  -  номера страховок ;  -  номера кредитных и дебетовых банковских карт .  Разрабатываемая автоматизированная система разграничения доступа к информационному и программному обеспечению  ( далее АСРДкИПО )  имеет сложную структуру ,  так как должна решать не только проблему утечки информационных ресурсов за пределы про - граммного обеспечения банка .  Основными объектами защиты ,  проек - тируемой АСРДкИПО являются :  -  информационные ресурсы банка ,  потеря или несанкциониро - ванное изменение которых влечѐт за собой ущерб ,  потерю репутации банка ;  9  -  процессы обработки информационных и программных ресур - сов .  Примером процессов обработки могут служить хранение ,  испол - нение  ( запуск ),  передача ,  отображение ,  изменение ,  вычислительная обработка ,  утилизация ;  -  программное обеспечение банка ;  -  информационная архитектура ,  представляющая собой структу - рированную совокупность автоматизированных систем и технологий банка .  Информационная среда банка является распределенной структу - рой ,  объединяющей информационные подсистемы банка в единую интегрированную автоматизированную компьютерную систему бан - ка ,  осуществляющую обработку ,  хранение и преобразование данных .  К основным особенностям информационной среды банка относятся :  -  хранение информационных ресурсов в единых хранилищах ( северах ,  банках данных , « серверных фермах »  и т . д .);  -  многофункциональность и широкий круг применения про - граммного и информационного обеспечения банка ;  -  возрастание ответственности принимаемых решений ,  возло - женной на программное обеспечение банка ;  -  функциональное разнообразие выполняемых задач программ - ного обеспечения банка ;  -  высокий показатель нагрузки внутреннего информационного трафика  ( особенно это касается файлов банковской документации ,  графических файлов );  -  применение особых технологий обработки графических фай - лов ;  -  недопустимость возникновения перебоев работы ПО банка ,  особенно при применении систем реального времени ;  -  многообразие пользователей ПО банка  –  сотрудников банка ;  -  объединение большого количества информационного ,  про - граммного и аппаратного обеспечения в единую интегрированную информационную систему .  С учѐтом перечисленного ужесточаются требования к соблюде - нию норм и правил работы с информационным и программным обес - печением коммерческого банка .  К субъектам защиты АСРДкИПО от - носятся :  -  юридические и физические лица ,  задействованные в обеспече - нии выполнения банком своих функций  ( разработчики ,  консультан - 10  ты ,  сторонние организации ,  привлекаемые для оказания услуг ,  об - служивающий персонал и т . д .);  -  сотрудники структурных подразделений банка ;  -  подразделения банка ;  -  руководство банка ;  -  банк в целом ;  -  представители третьей стороны .  Перечисленные субъекты заинтересованы в обеспечении :  -  целостности информационных ресурсов ПО банка ;  -  полезности информационных ресурсов ПО банка ;  -  достоверности информационных ресурсов ПО банка ;  -  конфиденциальности информационных ресурсов ПО банка ;  -  доступности информационных ресурсов ПО банка ;  -  защиты информационных ресурсов ПО банка от несанкциони - рованного копирования ,  распространения ,  тиражирования ;  -  защиты программных ресурсов банка от некомпетентного и некорректного использования  ( как специально ,  так и по неосторож - ности );  -  разграничения ответственности за нарушения и отклонения от правил работы с информационными и программными ресурсами бан - ка ;  -  возможности мониторинга работы с информационными и про - граммными ресурсами банка ,  определения причин инцидентов нару - шения их защиты .  Основной целью проектируемой АСРДкИПО является защита перечисленных объектов от возможного нанесения им физического ,  материального ,  морального или иного ущерба .  Указанная цель долж - на достигаться посредством обеспечения и постоянного поддержания следующих свойств информационных ресурсов банка :  -  конфиденциальность  –  сохранение в секрете информационных ресурсов ,  находящихся внутри ПО банка ;  -  целостность  –  сохранение свойств и полноты информационных ресурсов ,  находящихся внутри ПО банка ;  -  доступность информационных ресурсов для легальных пользо - вателей  –  нахождение ПО банка в таком состоянии ,  при котором санкционированные пользователи  ( сотрудники банка )  могли обра - щаться и работать с запрашиваемыми информационным и программ - ными ресурсами банка .  11  К качеству информационных ресурсов ,  предоставляемых со - трудникам банка ,  предъявляются определенные требования ,  прежде всего требования о том ,  чтобы они были полезными .  Для того чтобы информационные ресурсы банка обладали перечисленными свой - ствами ,  необходима разработка методики защиты информационных и программных ресурсов банка .  Методика защиты информационных и программных ресурсов банка должна включать в себя следующие ас - пекты :  -  применение принципа предоставления сотруднику минималь - ного количества разрешенных программ ,  специального программного обеспечения для работы с журналами безопасности  ( для сотрудников отдела информационной безопасности банка ),  оперативного контроля состояния автоматизированных рабочих мест сотрудников ;  -  обеспечение комплексного использования средств защиты ин - формационных и программных ресурсов банка ;  -  централизованное управление потоками информации в банке ;  -  централизованное управление учѐтными записями сотрудников банка ,  зарегистрированных в ПО банка ,  их правами доступа к инфор - мационным массивам ;  -  комплексное использование средств защиты от утечки инфор - мационных ресурсов по техническим каналам .  Для обеспечения доходности ,  ликвидности ,  конкурентоспособ - ности ,  сохранения репутации банка информационные ресурсы ПО банка должны обладать всеми перечисленными свойствами .  В соот - ветствии с изложенными аспектами ,  в АСРДкИПО предполагается использовать средства защиты информационного и программного обеспечения банка :  -  централизованное управление параметрами операционных си - стем ,  установленных на рабочих станциях сотрудников банка ;  -  централизованное управление учѐтными записями сотрудников банка  –  пользователей ПО банка ;  -  применение современных методов идентификации ,  аутентифи - кации и авторизации сотрудников банка при работе с информацион - ным и программным обеспечением банка ;  -  применение методов шифрования ;  -  использование только зарегистрированных ,  прошедших кон - троль на наличие закладок и вирусов ,  устройств и внешних носите - лей ;  12  -  использование лицензированного ,  прошедшего специальный контроль программного и аппаратного обеспечения ;  -  использование только сертифицированных средств защиты информации ;  -  применение методики однонаправленной передачи информа - ции от удаленных подсистем ,  между контурами различных грифов секретности ,  а также с автоматизированных рабочих мест ввода дан - ных ,  при обращении к базе данных инцидентов нарушения защиты информационного и программного обеспечения банка ;  -  защита от несанкционированного физического доступа к сер - верам ,  хранилищам информации , « серверным фермам »;  -  проведение специальных проверок технических средств банка ;  -  проведение специальных проверок аппаратного обеспечения банка ;  -  проведение специальных проверок программного обеспечения банка ;  -  проведение специальных исследований технических средств банка ;  -  проведение специальных исследований помещений ;  -  проведение специальных исследований программного обеспе - чения банка ;  -  проведение специальных исследований аппаратного обеспече - ния банка ;  -  применение механизма сигнализации  –  события несанкциони - рованного доступа на автоматизированных рабочих местах сотрудни - ков  –  отслеживание и оповещение сотрудников отдела информацион - ной безопасности банка .  Также должна существовать возможность информирования не только сотрудников отдела безопасности банка ,  но и непосредственно руководства .  Важно отметить ,  что события не - санкционированного доступа также заносятся в базу данных инци - дентов нарушения правил работы с информационным и программ - ным обеспечением банка ;  -  применение методики  « замкнутой программной среды » –  для каждого сотрудника банка  –  пользователя ПО банка  –  формируется определенный перечень программ ,  разрешенных только ему для за - пуска .  Перечень может быть задан как индивидуально для каждого пользователя ,  так и определен на уровне групп пользователей .  При - менение данного режима необходимо для исключения попыток зара - жения вирусами , « червями »,  для предотвращения промышленного 13  шпионажа ,  а также применения нелицензированного программного обеспечения .  Информация в коммерческом банке может существовать в раз - личных формах :  -  в бумажной форме ;  -  в электронном виде ;  -  устно .  В электронном виде информация может передаваться как в ло - кально - вычислительной сети  ( ЛВС ),  так и в глобальной вычисли - тельной сети  ( ГВС ).  Безотносительно формы выражения информаци - онных ресурсов ,  средств их распространения или хранения они должны всегда быть защищены .  В банке большая часть информаци - онных ресурсов хранится в электронном виде .  Это ,  в первую очередь ,  связано с повсеместным внедрением :  -  электронного документооборота ;  -  интеграционных средств поддержки ;  -  единых сред обработки большого количества информации ;  -  технологии непрерывной информационной поддержки поста - вок и жизненного цикла изделий  CALS;  -  технологии планирования ресурсов банка  ERP;  -  технологии управления и сбора данных систем реального вре - мени  SCADA;  -  технологии проектирования  CAD/CAM/CAE;  -  применение дополнительных вспомогательных программных модулей и комплексов .  При проектировании специального программного обеспечения ( ПО ),  используемого сотрудниками банка при выполнении своих должностных обязанностей ,  должны учитываться требования мето - дики защиты ПО банка .  Примером такого специального ПО являются среды программирования :  - Oracle JDevelope;  - Microsoft Visual Studio;  - Embarcadero RAD Studio;  и среды проектирования :  - AutoCAD;  - ProEngineer;  - T-Flex;  редакторы - верификаторы  G- кода :  - NCManager;  14  - CIMCO Edit;  - cgtech VERICUT;  текстовые редакторы :  - Microsoft Word;  - TEX.  Определение требований согласно методике обеспечения защи - ты информационного и программного обеспечения банка включает в себя :   оценку рисков безопасности функционирования ПО банка .  В рамках оценки рисков необходимо произведение подсчѐта возмож - ных угроз нарушения защиты ПО банка ,  планирование комплекса мероприятий по их предотвращению ;   приведение к соответствию требованиям нормативных доку - ментов ключевых параметров АСРДкИПО ;   формирование специального набора норм ,  законов ,  целей и требований ,  разработанных банком в отношении работы с информа - ционными и программными ресурсами банка .  Решения о расходах на мероприятия по защите информационно - го и программного обеспечения банка должны приниматься ,  исходя и из возможного ущерба ,  нанесенного банку в результате нарушений параметров защиты систем .  Оценки рисков могут проводиться как для ПО банка в целом ,  так и для отдельных составляющих модулей .  Оценка риска  –  это систематический анализ следующих вероятно - стей :  -  возникновения угрозы ;  -  возникновения инцидента нарушения правил работы с инфор - мационными и программными ресурсами банка  –  реализации угрозы ;  -  возникновение последствий инцидента .  Оценка рисков должна производиться с использованием прин - ципов системности и комплексности :  для банка должны быть выяв - лены возможные источники угроз ,  предоставлены подробные отчѐты о проведенном анализе .  В ходе анализа необходимо учитывать :  -  технический прогресс ;  -  возможные изменение направления деятельности банка ;  -  возможные изменение приоритетов деятельности банка ;  -  появление новых видов уязвимостей ПО банка ;  -  появление новых видов угроз .  После анализа рисков необходима разработка комплекса меро - приятий для обеспечения требуемого уровня защиты .  При выборе 15  мероприятий следует придерживаться принципа ,  что стоимость их проведения не должна превышать ценности защищаемых ресурсов ПО банка .  Ценность информационных ресурсов составляют их акту - альность и полезность .  Ценность программных ресурсов составляет их функциональность и полезность .  Также следует принимать во внимание факторы ,  которые не могут быть представлены в денежном выражении ,  например ,  потерю репутации .  Ключевыми мерами кон - троля с точки зрения законодательства Российской Федерации явля - ются :  -  обеспечение конфиденциальности персональных данных со - трудников банка ;  -  защита учѐтных данных банка ;  -  защита прав на интеллектуальную собственность .  Типами доступа ,  которые следует рассматривать согласно ГОСТ Р ИСО / МЭК  17799-2005,  являются :  -  физический  –  к помещениям ,  компьютерным комнатам ,  сер - верным ;  -  логический  –  к базам данных ,  информационным системам бан - ка .  В соответствии с системой классификации информационных ре - сурсов банка ,  принятой в банке ,  необходимо проведение процедур их маркировки .  Процедуры маркировки должны осуществляться для информационных ресурсов как в электронной ,  так и в бумажной форме .  В рамках работы рассматривается маркировка информацион - ных ресурсов в электронном виде .  При проведении маркировки сле - дует учитывать процессы обработки информационных ресурсов  ( хра - нение ,  копирование ,  утилизация ,  передача и т . д .).  Маркирование ин - формационных ресурсов также необходимо для последующего про - ведения процедуры авторизации сотрудников банка .  Технология  Information Protection and Control (IPC)  является технологией защиты информационных ресурсов от внутренних угроз .  Решения класса  IPC  предназначены для защиты информационных ре - сурсов от внутренних угроз ,  предотвращения различных видов утечек информационных ресурсов ,  промышленного шпионажа и разведки .  Задача технологии  IPC –  предотвращение передачи информационных ресурсов за пределы периметра основной информационной системы .  Технология  IPC  соединяет в себе три основных принципа :  -  мониторинг технических каналов связи с помощью технологии Data Loss Prevention (DLP);  16  -  контроль доступа к сети ,  приложениям и данным ;  -  шифрование носителей информации .  В ходе работы систем  IPC  широко используется детектирование информационного контента .  Детектирование информационного кон - тента может происходить с помощью следующих методов :  -  метод ручного детектирования  (« Карантин »);  -  метод  « цифровых отпечатков »;  -  метод сигнатур ;  -  метод ,  основанных на проставлении меток ;  -  метод лингвистического анализа ;  -  метод ,  основанный на  « регулярных выражениях ».  Метод ручного детектирования  (« Карантин »)  основан на приме - нении ручной проверки .  При обращении сотрудника к файлам ,  со - держащим конфиденциальные данные ,  производится информирова - ния сотрудников отдела информационной безопасности банка ,  кото - рые принимают решение о дальнейших действиях :  предоставлении сотруднику запрашиваемых данных или отказе в доступе .  Достоинством метода является его эффективность .  Недостатком является тот факт ,  что данный метод практически не реализуем в крупных банках ,  т . к .  требует привлечения больших человеческих ре - сурсов  ( для формирования штата сотрудников отдела безопасности ).  Метод  « карантин »  можно применять с другими методами для анализа данных выбранных  « подозрительных »  сотрудников .  При использова - нии метода  « цифровых отпечатков » ( англ . «Digital Fingerprints»)  формируется база данных образцов  ( паттернов ,  шаблонов )  конфиден - циальных файлов .  В начале работы создается файл - шаблон и переда - ется  DLP- системе ,  далее формируется отпечаток и передается в спе - циальную базу данных так называемых  « паттернов ».  Затем в прави - лах фильтрации контента файлов настраивается процентное соответ - ствие шаблону из базы .  Достоинством метода является тот факт ,  что система фильтрации информационного трафика ,  основанная на дан - ном методе ,  способна работать с информацией любого формата .  Так - же достоинствами системы на основе технологии  « цифровых отпе - чатков »  являются :  -  прозрачность работы алгоритма для сотрудников отдела ин - формационной безопасности ;  -  высокая степень детектирования инцидентов нарушения пра - вил работы с информационным обеспечением ;  -  простота добавления новых файлов - шаблонов  ( паттернов ).  17  Недостатками метода являются :  -  чувствительность к изменениям файлов - шаблонов ;  -  требование обеспечения дополнительной защиты базы данных паттернов  ( особое расположение серверов ,  формирование правил и настройка допуска сотрудников к базе );  -  снижение эффективности детектирования при переполнении базы данных паттернов ,  что на практике происходит довольно часто ;  -  высокая степень влияния на производительность основной ин - формационной системы банка ;  -  низкая эффективность метода при работе с графическими фай - лами .  В крупных банках данную технологию трудно реализовать ,  так как база данных файлов - шаблонов увеличивается слишком быстро ,  что повышает нагрузку на сервера  DLP- системы ,  кроме того посто - янно приходится сталкиваться с проблемой заполнения базы данных ,  распределения нагрузки .  Метод сигнатур представляет собой поиск в информационном потоке определенных символьных последователь - ностей ,  так называемых  « стоп - выражений »  запрещенных последова - тельностей символов .  Метод относится к  « детерминистским »,  т . к .  ал - горитм метода настроен на поиск  100 %  совпадения  « стоп - выражения ».  Большинство сигнатурных систем предназначены для поиска нескольких слов и частоту их встречаемости .  Достоинства ме - тода сигнатур :  -  очевидность принципа работы ;  -  простота реализации и настройки .  Недостатками метода являются :  -  чувствительность к специальной замене некоторых символов ( например ,  на похожие символы из другого алфавита );  -  неэффективность метода при работе с файлами программного кода ;  -  неприменимость метода к графическим файлам ;  -  зависимость функционирования от языка  ( как естественного ,  так искусственного ).  DLP- системы ,  основанные на методе сигнатур хорошо  « приспо - соблены »  для западного рынка ,  но практически не пригодны в Рос - сии .  Причина  –  русский язык несигнатурен :  в нѐм много приставок ,  суффиксов и окончаний .  Метод  « меток »  заключается в расстановке специальных  « меток »  внутри файлов конфиденциальной информа - ции .  Достоинства метода :  18  -  высокая эффективность детектирования ;  -  точность предоставляемой информации ;  -  высокое быстродействие .  Недостатки метода :  -  сложность реализации  -  данный метод требует изменение структуры всей основной информационной системы банка ;  -  требование выполнения дополнительных настроек при форми - ровании нового файла конфиденциальной информации .  Лингвистические методы являются самыми распространенными в применении в  DLP- системах ,  т . к .  предоставляют гибкий аппарат де - тектирования информационного контента .  Лингвистический анализ текста включает в себя несколько методов детектирования :  -  синтаксический анализ ;  -  семантический анализ ;  -  морфологический анализ и т . д .  Применение перечисленных методов анализа увеличивает эф - фективность  DLP- системы .  Недостатки лингвистических методов :  -  чувствительность к переформированию предложений ;  -  неэффективность метода к файлам программного кода ;  -  неприменимость метода для графических файлов ;  -  зависимость от языка информационного контента .  Метод  « регулярных выражений » ( метод  « текстовых идентифи - каторов »)  применяется в  DLP- системах недавно .  Регулярные выра - жения позволяют находить совпадения по типу данных  ( их форме представления ).  Основное отличие от метода  « сигнатур »  является особенность поиска :  не по значению ,  а по типу данных .  Таким обра - зом ,  производится поиск целого блока идентичной информации .  По - добный метод эффективен для поиска :  -  обозначений изделий ;  -  дат ;  -  адресов  (MAC, IP,  интернет - сервисов );  -  номеров портов ;  -  номеров кредитных карт ;  -  номеров счетов ;  -  номеров паспортов ;  -  классификаторов и т . д .  Достоинства метода :  -  высокая эффективность ;  -  высокий уровень быстродействия ;  19  -  способность детектировать специфичный для каждого банка тип контента ;  -  применимость метода для работы с графическими файлами .  Часто метод  « регулярных выражений »  применяется в качестве дополнительного алгоритма в  DLP- системе ,  но не в качестве основ - ного .  Следует отметить ,  что вышеперечисленные методы ,  применяе - мые в современных системах  DLP,  работают с открытыми данными .  Если злоумышленник в лице сотрудника банка ,  превышающего должностные обязанности и нарушающего правила работы с инфор - мационными ресурсами банка ,  попытается передать конфиденциаль - ную информацию в зашифрованном виде ,  современные  DLP- системы не смогут предотвратить утечку .  В проектируемой АСРДкИПО предусмотрено решение данной проблемы путѐм добавления специ - ального модуля ,  в ядро которого включены криптоаналитические ме - тоды .  Следует уделить особое внимание модулю мониторинга инфор - мационного трафика банка  ( как внутреннего ,  так и внешнего )  разра - батываемой АСРДкИПО ,  а именно ,  работе с зашифрованными дан - ными .  Также следует отметить ,  что большую часть информационного контента банка составляют графические файлы .  Большинство мето - дов детектирования не предназначены для работы с такими файлами .  Злоумышленник может воспользоваться данным недостатком и пере - дать конфиденциальные информационные ресурсы , « зашив »  их в графические файлы с помощью методов стеганографии ,  кроме того ,  сами графические файлы представляют собой конфиденциальные информационные ресурсы .  Важно предусмотреть мероприятия по управлению защитой ин - формационного и программного обеспечения банка ,  необходимые для управления доступом к средствам обработки информационных ресурсов третьей стороной .  Все требования безопасности ,  связанные с доступом третьей стороны или мероприятиями по управлению за - щитой ПО банка ,  следует отражать в контракте с третьей стороной .  Например ,  если существует специальная потребность в обеспечении конфиденциальности информационных ресурсов ,  следует заключить соглашение о их неразглашении .  Недопустимо предоставлять третьей стороне доступ к информационным ресурсам и средствам их обра - ботки до тех пор ,  пока не установлены соответствующие мероприя - тия по управлению защитой и не подписан контракт ,  определяющий условия предоставления информационных и программных ресурсов 20  банка .  Распределение уровней доступа ,  предоставляемых сотрудни - кам банка ,  лицам третьей стороны ,  представлен на рис . 1.  Согласно рис . 1,  субъектам информационных отношений может быть присвоен уровень доступа к объектам информационных отношений .  Управле - ние присвоением соответствующего уровня доступа обеспечивается разрабатываемой АСРДкИПО .  Рис . 1.  Распределение уровней доступа для сотрудников банка и представителей  « третьей стороны »  Для обеспечения должного уровня защиты информационного и программного обеспечения банка необходимо проведение надлежа - щего контроля запросов сотрудников банка к соответствующим ре - сурсам .  Одной из важных задач АСРДкИПО является контроль за - просов сотрудников банка к информационным и программным ре - сурсам банка .  Так как запросы пользователей могут быть адресованы как в Интернет ,  так и в сеть серверов данных банка с одного и того же автоматизированного рабочего места  ( АРМ ),  может произойти утечка информационных ресурсов .  С целью предотвращения утечки 21  секретных данных в разрабатываемой автоматизированной системе должен быть модуль контроля запросов сотрудников банка к инфор - мационным ресурсам  ( МКЗСПкИР ).  МКЗСПкИР должен производить мониторинг запросов пользователей к информационным ресурсам банка и отправлять соответствующие отчѐты в модули аудита ,  со - трудникам отдела информационной безопасности банка ,  руководству в случае необходимости .  МКЗСПкИР в качестве основных механиз - мов должен использовать ,  в первую очередь ,  методы детектирования информационного контента .  Доступ к информационным и программ - ным ресурсам в банке должен быть регламентирован .  По установлен - ному регламенту все информационные массивы банка разделяются на группы  ( грифы )  секретности с помощью специальных меток .  Каждой такой группе соответствует список лиц ,  допущенных к работе с ней .  Цель системы класса  DLP –  предотвращение утечки стратегиче - ски важных информационных ресурсов банка за пределы основной информационной системы  –  определяет ее архитектуру .  Архитектура DLP- системы представлена на рис . 2.  DLP – система включает в себя подсистему контроля и монито - ринга информационного контента и подсистему реагирования на ин - циденты нарушения параметров защиты ПО банка .  Подсистема кон - троля и мониторинга информационного контента включает в себя контроль доступа к данным ,  к сети ,  к приложениям ,  шифрование ин - формации ,  детектирование информационного контента .  Подсистема реагирования на инциденты включает настройку правил и условий срабатывания сигнала - оповещения  (alarm)  и самого модуля оповещение сотрудников службы безопасности и руководства банка .  Настройка подсистемы мониторинга информационного контента осуществляется сотрудниками службы информационной безопасно - сти банка .  Настройка подсистемы реагирования на инциденты произ - водится сотрудниками службы безопасности банка с непосредствен - ным контролем руководящего состава банка .  Важно отметить ,  что в условиях совершенствования методов осуществления угроз снижения уровня защиты основной информационной системы ,  в качестве кото - рой в работе рассматривается ПО банка ,  необходимо учитывать :  -  возможность совершенствования  DLP- системы ;  -  возможность модификации основных составляющих ;  -  возможность добавление компонентов .  22  Рис . 2.  Архитектура  DLP- системы Инфраструктура  DLP- системы представлена на рис . 3.  Условные обозначения :  -  АРМ П  –  автоматизированное рабочее место пользователя  ( со - трудника банка );  -  АРМ А  –  автоматизированное рабочее место  ( АРМ )  админи - стратора  ( сотрудника отдела безопасности банка );  -  АРМ Р  –  АРМ руководящего состава банка ;  -  синяя стрелка  –  запрос к данным ;  -  красная стрелка  –  осуществление контроля ;  -  зелѐная стрелка  –  оповещение ;  -  зелѐная пунктирная стрелка  – « скрытое » ( прозрачное для всех сотрудников банка )  оповещение .  Передача информации происходит от одного модуля  ( программного или аппаратного обеспечения )  к другому автоматически  ( без участия сотрудников банка ).  23  Рис . 3.  Инфраструктура  DLP- системы Согласно рис . 3,  пользователь  ( сотрудник банка )  может обра - щаться к информационным ресурсам банка ,  физически расположен - ной во внутренней распределѐнной сети банка ,  а также обращаться за необходимой информацией в Интернет .  Кроме того ,  сотрудник может обращаться к приложениям и сервисам  ( программному обеспечению )  банка и ГВС .  Таким образом ,  формируются два основных информа - ционных потока запросов ,  над которыми необходимо осуществлять контроль со стороны АСРДкИПО .  На рис . 4  представлены взаимодействия основных структур DLP- системы .  В состав  DLP- системы входят три основных компо - нента :  24  -  рабочие станции сотрудников банка  ( автоматизированные ме - ста сотрудников банка ,  администраторов и руководящего состава банка );  -  контролирующие структуры  ( модули );  -  данные  ( Интернет ,  файлы локальной сети банка ,  база данных инцидентов нарушений правил работы с информационным и про - граммным обеспечением банка ).  Сотрудники банка производят обра - щение к данным  ( в Интернет ,  в локальной сети банка ,  к базе данных инцидентов безопасности банка ).  Рис . 4.  Взаимодействие основных структур  DLP- системы 25  Условные обозначения к рис . 4:  -  фигурная стрелка  –  запрос данных ,  обращение к модулю опо - вещения ;  -  чѐрная стрелка  –  действия модуля оповещения  ( информирова - ние сотрудников отдела безопасности и руководства ,  запись в базу данных инцидентов нарушения правил работы с информационным и программным обеспечением банка );  -  красная стрелка  –  обращение сотрудников отдела информаци - онной безопасности и руководства к базе данных инцидентов банка и получение ответа .  Затем сотрудник получает доступ к запрашивае - мым информационным ресурсам .  В табл . 1  приведена информация о  DLP- системах от основных поставщиков  IPC- продуктов на российском рынке :  - Simantec Data Loss Prevention;  - InfoWatch Traffic Monitor;  - McAfee Host Data Loss Prevention;  - Websence Data Security Suite.  Изложенные в предыдущем пункте характеристики информаци - онных систем класса  DLP  можно привести к восьми основным ( рис . 5):  -  гибкость ;  -  способность к адаптации ;  -  способность к интеграции ;  -  производительность детектирования ошибок  I  рода ;  -  производительность детектирования ошибок  II  рода ;  -  масштабируемость ;  -  скорость анализа сетевого трафика ;  -  прозрачность работы .  Из рис . 5  видно ,  что лучшей системой класса  DLP  по перечис - ленным критериям является  Simantec DLP.  Существует только один критерий ,  по которому она уступает отечественной разработке InfoWatch Traffic Monitor –  способность к интеграции .  Это ,  прежде всего ,  связано с особенностями предпочтения использования про - граммных продуктов почты и т . д .)  на российском рынке .  26  Таблица  1  Сравнение основных  DLP- систем 27  28  29  30  31  32  33  Рис . 5.  Сравнительная диаграмма основных характеристик систем класса  DLP  Надежность и точность идентификации стратегически важных информационных ресурсов в информационных потоках банка с по - 34  мощью технологии лингвистического анализа зависят от принципа формирования БКФ ,  на основе которой осуществляется анализ .  По - этому важно создать базу ,  которая обеспечит надежные результаты фильтрации информационного контента по категориям .  Основным методом лингвистического анализа с помощью БКФ является поиск в анализируемом фрагменте информации слов и словосочетаний ,  опи - сывающих стратегически важные данные и структурированных по категориям групп слов .  1.1.  Управления доступом к информационному и программному обеспечению в коммерческом банке Управление доступом  (access control) –  это процесс проверки за - просов на доступ к сервису с целью определить разрешить или запре - тить доступ .  Большая часть современных систем использует модель управления доступом ,  предложенную Лампсоном в  1974  г  ( рис . 6).  Рис . 6.  Модель управления доступом  ( Лампсон , 1974)  Модель Лампсона включает следующие элементы :  - Principal –  автор запроса  ( принципал ,  иногда называют субъек - том ).  - Object –  ресурс ,  информационный ,  сетевой или вычислитель - ный .  - Request –  запрос на выполнение операции с объектом .  - Reference Monitor –  диспетчер доступа ,  проверяющий все за - просы к объекту и принимающий решение о разрешении или запре - щении доступа .  Диспетчер доступа для принятия решения проводит три проце - дуры защиты информации .  Определение источника запроса называ - ется идентификацией ,  подтверждение подлинности источника назы - 35  вается аутентификацией ,  анализ правил разграничения доступа назы - вается авторизацией .  Наиболее полную интероперабельность интегрируемых систем обеспечивает семантическая интеграция .  Интеграционные решения ,  использующие синтаксический и структурный подход ,  являются частными ,  рассчитанными на определенные системы .  Широкое при - менение таких решений затруднено .  В настоящее время наиболее популярной технологией семанти - ческой интеграции являются онтологии .  Онтологии определяют об - щий словарь предметной области ,  который может совместно исполь - зоваться людьми или информационными системами .  Для разработки онтологий существует широкий набор инструментальных средств :  язык описания онтологий  OWL (Web Ontology Language),  являющий - ся стандартом  W3C,  среды редактирования онтологий  Protégé,  Ontolingua, Chimaera,  готовые и доступные к использованию онтоло - гии ,  описывающие различные предметные области .  Выявлены аналоги трех типов :  системы централизованного управления ,  системы федеративной идентификации ,  системы инте - грированного управления .  Оценка наиболее близких аналогов приве - дена в табл . 2.  Таблица  2  Оценка существующих систем интеграции управления доступом 36  Оценка наиболее близких онтологий с точки зрения возможно - сти применения для интеграции управления доступом к сервисам разных типов приведена в табл . 3.  Таблица  3  Оценка онтологий в предметной области управления доступом Схема прототипа и существующее решение в  « Газпромбанке »  приведена на рис . 7.  Основным недостатком прототипа является низкая интеропера - бельность ,  вызванная использованием структурной интеграции .  Для увеличения интероперабельности предлагается использовать семан - тическую интеграцию :  разработать семантическую модель в виде он - тологии ,  ввести блок согласования семантики в адаптеры сервисов ,  37  модифицировать схему данных и блоки хранения правил разграниче - ния доступа ,  ПО управления доступом и консоль управления досту - пом .  Рис . 7.  Процесс доступа к информации в  « Газпромбанке »  Используется методика интеграции управления доступом к сер - висам разных типов на основе семантического подхода .  Методика за - ключается в выполнении следующих шагов :  1.  Задать множество сервисов S ,  которые подлежат интеграции .  38  2.  Задать множество моделей М ,  используемых для управления доступом к сервисам из множества S .  3.  Задать множество репозиториев правил разграничения досту - па R ,  которые подлежат интеграции .  4.  Задать множество протоколов управления доступом P ,  кото - рые используются сервисами из множества S .  5.  Разработать унифицированную модель управления доступом M 0 .  Модель включает семантическое описание базовых понятий и операций систем управления доступом  ( представленное в виде онто - логии )  и синтаксис записи правил разграничения доступа с использо - ванием данной семантики .  6.  Определить отображение моделей управления доступом m i  M в унифицированную модель М 0 :  F : m i  M 0 | m i  M .  7.  Создать консолидированный репозиторий правил разграниче - ния доступа R 0 ,  использующий унифицированную модель M 0 .  8.  Разработать адаптеры AR ,  обеспечивающие перенос данных из репозиториев r i  R в консолидированный репозиторий R 0 .  9.  Создать программное обеспечение управления доступом ,  реа - лизующее процедуры защиты информации с использованием правил разграничения доступа в консолидированном репозитории R 0 .  10.  Разработать адаптеры AS протоколов управления доступом p i  P ,  обеспечивающие взаимодействие сервисов s i  S с ПО управле - ния доступом ,  для выполнения процедур защиты информации с ис - пользованием протокола p i  P .  11.  Настроить сервисы s i  S для взаимодействия с ПО управле - ния доступом с помощью адаптеров a i  AS по протоколам p i  P .  12.  Разработать консоль управления правилами разграничения доступа в консолидированном репозитории R 0 .  Структурная схема системы семантической интеграции управ - ления доступом к сервисам разных типов ,  получаемой с помощью предлагаемой методики ,  показана на рис . 8.  Особенность предлагаемого метода интеграции управления до - ступом к сервисам разных типов заключается в применении семанти - ческого подхода к интеграции ,  обеспечивающее большую интеропе - рабельность ,  по сравнению с используемыми в настоящее время син - таксическим и структурным подходами .  Построенная с применением данного метода система обеспечит интеграцию более широкого круга сервисов и использование большего количества методов управления доступом .  39  Рис . 8.  Структурная схема системы семантической интеграции управления доступом к сервисам Логическая архитектура комплекса программ показана на рис . 9  и состоит из трех уровней :  -  Уровень технических служб отвечает за взаимодействие с ре - позиториями правил разграничения доступа r i  R ,  обеспечивает со - здание консолидированного репозитория правил разграничения до - ступа R 0 .  -  Уровень приложений реализует прикладную логику управле - ния доступом :  процедуры защиты информации ,  управление сессиями и т . д .  -  Уровень представления обеспечивает взаимодействие ком - плекса с внешним миром :  сервисами ,  администраторами ,  пользовате - лями и внешними информационными системами .  40  Рис . 9.  Архитектура комплекса программ по управлению доступом к сервисам Консолидированный репозиторий правил разграничения досту - па построен на основе  LDAP- каталога  Sun Java System Directory Serv- er.  Адаптеры протоколов идентификации реализованы с использова - нием ПО  FreeRADIUS, OpenSSO, Samba.  Система управления по - строена на основе  Sun Java System Delegated Administrator,  функцио - нальность которого расширена для возможности управления досту - пом к сервисам разных типов .  Система управления предоставляет два типа интерфейса : Web  и командную строку .  Распределение полномо - чий между администраторами реализовано с помощью делегирования на двух уровнях :  администратор с полным доступом и администратор организации .  Комплекс работает под управлением ОС  Solaris.  Надежность работы комплекса обеспечивается с помощью структур - ного резервирования .  Удобство использования сервисов повышается за счет единого идентификатора и пароля .  Количество необходимых для работы идентификаторов сократилось с  10 ( соответствует количеству серви - сов ,  подключенных к системе управления доступом )  до одного .  Со - 41  кращение количества идентификаторов также привело к уменьшению количества запросов в службу поддержки по восстановлению забы - тых паролей и консультаций по порядку доступа к сервисам на  60 %.  Проведен сравнительный анализ временных характеристик про - цесса управления доступом к сервисам с использование системы ин - тегрированного управления и без нее .  Результаты сравнительного анализа представлены в табл . 4.  Таблица  4  Результаты сравнительного анализа временных затрат в ходе управления доступом к сервисам Время ,  сэкономленное при управлении доступом с использова - нием системы интегрированного управления ,  может составлять до 80%  от обычного времени работы с применением существующих си - стем управления доступом за счет сокращения количества ручных операций .  Интеграция управления доступом к сервисам разных типов поз - воляет снизить требования к администраторам за счет предоставле - ния единой интуитивной понятной системы управления с  Web- интерфейсом .  1.2.  Анализ методов проверки корректности работы программного обеспечения Если корректность модели можно гарантировать с помощью ограничений на методы построения модели в ПО ,  тогда адекватность может быть проверена только после того ,  как проведена верификация модели .  Для построения корректной модели могут использоваться 42  методы автоматического порождения моделей  (Model Extraction)  по заданному алгоритму ,  а автоматическое построение адекватной мо - дели достигается за счёт комбинирования методов булевой абстрак - ции с итеративной верификацией моделей .  Такой подход к построе - нию моделей получил название  Counter Example Guided Abstraction  Refinement.  В случае неудачной проверки построенной модели про - водится уточнение модели с помощью САДТ .  В данном случае ком - бинируются средства  MC  и САДТ .  Гарантия полностью автоматиче - ской проверки моделей исчезает ,  т . к .  не во всех случаях САДТ спо - собны выдать доказательство запрашиваемого утверждения .  Эффект  « комбинаторного взрыва »  связан с экспоненциальным ростом пространства состояний при линейном росте числа взаимо - действующих процессов .  Последствиями экспоненциального роста пространства состояний становятся высокие требования к объему па - мяти ,  используемой верификатором моделей ,  и долгое время провер - ки модели .  Для сжатия проверяемого множества состояний исполь - зуются символьные способы представления моделей ,  например ,  дво - ичные разрешающие диаграммы  (Binary Decision Diagrams, BDD).  В символьном представлении модели выражаются с помощью  BDD,  ко - торые реализуют функции алгебры логики .  При поиске в простран - стве состояний вместо перебора состояний используются операции над функциями .  Алгоритмы верификации моделей с помощью  BDD  могут быть значительно эффективнее явного перебора состояний в том случае ,  когда  BDD  системы переходов модели и промежуточных результатов остаются компактными .  Для моделей аппаратных схем представление модели в виде  BDD  даёт хороший коэффициент сжатия по отноше - нию к явному представлению множеств .  Модели распределённого ПО сжимаются несколько хуже ,  т . к .  в распределённом ПО использу - ется асинхронное взаимодействие .  Для борьбы с  « комбинаторным взрывом »  при верификации мо - делей ПО используются методы редукции частичных порядков .  В этих методах проверяется достаточное подмножество множества всех трасс .  Такое подмножество вычисляется на основании зависимостей между переходами процессов модели .  Типы проверяемых зависимо - стей выявляются эмпирически .  Оптимальный выбор правил редукции может существенно ускорить алгоритм верификации модели .  Третьей проблемой применения группы методов  MC  является требование конечности числа состояний проверяемой модели .  Алго - 43  ритмы  MC  гарантированно завершаются и эффективно работают именно на моделях с конечным числом состояний .  При попытке обобщения задачи верификации методами  MC  с целью проверки си - стем с бесконечными множествами состояний возникает два направ - ления :  верификация моделей с бесконечным числом состояний и ве - рификация параметризованных моделей .  При верификации моделей с бесконечным числом состояний (Infinite State-Space Model Checking)  в описании модели могут при - сутствовать переменные с неограниченными типами данных ,  а по - рождаемая по описанию система переходов обладает бесконечным множеством состояний .  Для решения этой задачи используются ком - бинации символьных методов верификации моделей .  Задача верификации параметризованных моделей  (Parameterized  Model Checking, PMC)  возникает при рассмотрении моделей распре - делённых систем ,  в которых число однотипных взаимодействующих процессов зависит от начальной конфигурации системы и может быть сколь угодно большим .  Увеличение числа вычислителей не всегда приводит к линейному росту производительности распределённой ИС .  Аналогично ,  выводы о выполнимости спецификации ,  получен - ные для конфигурации с одним числом процессов ,  нельзя переносить на конфигурации с другим числом процессов ,  не приводя дополни - тельной аргументации .  Решение задачи  PMC  позволяет убедиться в выполнимости проверяемых спецификаций при масштабировании распределённого ПО ,  т . е .  при росте числа взаимодействующих про - цессов .   При фиксированном числе процессов может быть построена мо - дель распределённой ИС с конечным числом состояний .  Однако чис - ло взаимодействующих процессов неограниченно ,  и множество мо - делей с различным числом процессов бесконечно .  Проверка произ - вольных моделей с фиксированным числом процессов не даёт гаран - тии выполнимости проверяемого свойства при увеличении числа вза - имодействующих процессов ,  а все модели проверить невозможно .   В задаче  PMC  рассматриваются распределённые ИС взаимодей - ствующих процессов .  В этих ИС присутствует фиксированное число статических процессов и неограниченное число однотипных процес - сов .  Так как число однотипных процессов не ограничено ,  то по рас - пределённой ИС может быть построено бесконечное семейство моде - лей .  Каждая модель соответствует конфигурации ИС с фиксирован - ным числом процессов .  Для проверки свойств распределённой ИС 44  необходимо проверить спецификацию на всех моделях бесконечного семейства .  Методы решения задачи  PMCP  развивались в следующих направлениях :   аналитические методы редукции ;   методы абстракции ;   символьные методы ;   методы ,  основанные на поиске инварианта .  В аналитических методах редукции указывается способ отобра - жения моделей семейства параметризованных моделей на одну мо - дель этого семейства  (cut-off model).  В этом случае точно известны ограничения ,  которым должны удовлетворять модели семейства .  Несомненными достоинствами аналитических методов редук - ции являются :  точное описание области применимости методов ,  ал - горитмизация и завершаемость .  С помощью средств  MC  достаточно проверить все модели ܯ 1 , ...,  ܯ ܰ до порогового значения ܰ ,  где ܰ из - вестно заранее .  Среди недостатков подхода можно перечислить следующие .  Во - первых ,  аналитические методы редукции применимы только к двум видам ИТС :  асинхронным ИТС с кольцевой топологией ,  процессы которых обмениваются маркером ,  а также асинхронным широкове - щательным ИТС с переходами специального вида .  Во - вторых ,  теоре - тические оценки порогового значения для некоторых методов зависят от числа состояний процессов ,  поэтому число состояний пороговой модели может быть настолько большим ,  что в результате проверка пороговой модели будет практически невозможной .  Для методов абстракции также указывается способ отображения параметризованных моделей на одну модель ,  но эта модель не при - надлежит самому параметризованному семейству ,  а моделирует по - ведение любого числа однотипных процессов .  Из способа отображе - ния следуют структурные ограничения на параметризованные семей - ства моделей ,  которые могут быть верифицированы таким способом .  Основное достоинство методов абстракции заключается в том ,  что после нахождения вида абстрактной модели и отображения моде - лей семейства ࣠ на абстрактную модель ,  проверка свойств осуществ - ляется автоматически для любой параметризованной модели  ( за ис - ключением метода Лесена и Сайди ,  где булева абстракция строится с помощью САДТ ).  Методы верификации параметризованных моделей с помощью абстракции опираются на постоянно развивающийся ап - 45  парат построения булевых абстракций и абстрактной интерпретации .  Поэтому область применимости методов абстракции к задаче  PMC  постепенно расширяется .  Недостатки .  Даже в тех случаях ,  когда экспертам удаётся ука - зать вид абстрактной модели ܣ и способ абстракции ߙ для класса мо - делей ,  область применимости методов ограничивается :  ИТС ,  процес - сы которых обмениваются маркером ;  широковещательными ИТС ;  ИТС с топологией  « звезда ».  В остальных случаях методы абстракции требуют подсказок от эксперта .  Например ,  требуется явное указание существенных переменных и предикатов в ИТС переходов .  Когда аб - стракция построена ,  спецификация может не выполняться на аб - страктной модели .  Из чего не следует ,  что спецификация нарушается и на моделях параметризованного семейства ࣠ .  В таком случае тре - буется участие эксперта для уточнения абстракции ,  однако уточнение возможно не для всех указанных методов .  Символьные методы используют модификации символьного подхода к решению задачи  MC.  Для описания параметризованного семейства моделей используются системы переходов ,  в которых пе - реходы задаются неявно ,  с помощью символьных описаний .  Напри - мер ,  множества переходов могут представляться регулярными выра - жениями или логическими формулами с кванторами существования и всеобщности .  Для заданной системы переходов ищется множество состояний ,  достижимых из начальных состояний .  В случае символь - ных методов ,  как правило ,  нет гарантии завершаемости .  Достоинства .  Символьные методы могут применяться для про - верки свойств информационной безопасности  ( ИБ )  параметризован - ных моделей асинхронных распределённых ИТС со следующими то - пологиями :  кольцевая ,  древовидная ,  полносвязная .  Положительным свойством методов является использование известных в математиче - ской логике языков и готовых средств вывода для этих языков .  Выра - зительные возможности применяемых языков позволяют описывать протоколы ,  параметризованные не только по числу процессов ,  но и использующие бесконечные типы данных ,  например ,  целочисленные счётчики .  Недостатки .  Так как символьные методы основаны на представ - лении ИТС переходов параметризованного семейства ࣠ в целом с помощью более выразительных языков ,  нежели  LTS,  размеченных пропозициональными переменными ,  завершаемость методов ,  в об - щем случае не гарантируется .  В некоторых случаях завершаемость 46  может быть достигнута модификацией преобразователя ܶ ,  например ,  с помощью применения техник добавления дополнительных перехо - дов  ( акселерация , acceleration)  и поиска аппроксимаций  ( расширение ,  widening).  Однако в этом случае требуется участие эксперта с целью изменения преобразователя .  Другим недостатком является требова - ние повторного описания модели в параметризованном виде на язы - ках ,  сильно отличающихся от языков описания моделей ,  используе - мых в средствах  MC.  После того ,  как модель распределённой ИТС построена и верифицирована для фиксированного числа процессов с помощью стандартного средства  MC,  желательно использовать вы - бранный уровень абстракции и перевести модель в параметризован - ный вид с минимальным вмешательством эксперта .  В методах ,  основанных на поиске инварианта ,  ищется или кон - струируется процесс - инвариант ,  моделирующий поведение несколь - ких процессов ИС .  Инвариант должен обладать следующим свой - ством :  ИС ,  состоящая из инварианта с дополнительными однотипны - ми процессами ,  также моделируется инвариантом .  С помощью ин - дукции показывается ,  что ИС со сколь угодно большим числом одно - типных процессов моделируется системой ,  состоящей из фиксиро - ванного числа процессов и инварианта .  Основное отличие от методов абстракции состоит в том ,  что не требуется явное отображение каж - дой модели параметризованного семейства на модель - инвариант .  Достоинства .  В методах инвариантов используется способ ин - дуктивного доказательства и довольно простой критерий проверки инварианта .  Поэтому методы могут быть автоматизированы .  Поиск инварианта среди моделей семейства ࣠ с малым числом процессов соответствует интуитивному представлению инженеров ,  разрабаты - вающих модель ,  о поведении модели .  С помощью методов инвариан - тов могут проверяться параметризованные модели с нетривиальной топологией ,  представляемой сетевыми грамматиками ,  и различными прототипами процессов .  Существенным достоинством является и то ,  что после нахождения инварианта  ( или нескольких инвариантов в случае сетевой грамматики ),  для проверки модели ,  содержащей инва - риант ,  достаточно применить развитые средства метода верификации моделей .  Недостатки .  В тех случаях ,  когда не удаётся найти инвариант среди моделей с малым числом процессов ,  необходимо дополнитель - но применять методы абстракции ,  требующие знаний эксперта .  Так как автоматический поиск инварианта проводится среди моделей се - 47  мейства ,  в общем случае для процедуры поиска нет гарантии завер - шаемости .  Однако ,  на практике инварианты необходимо искать среди моделей с довольно небольшим числом процессов ,  так как размер множеств состояний в моделях параметризованного семейства растёт экспоненциально с числом процессов .  На основе описания достоинств и недостатков представленных методов решения задачи  PMCP,  большинство аналитических методов редукции и методов абстракции обладает свойствами алгоритмизации и завершаемости .  Однако область применимости обеих групп методов невелика :  асинхронные модели ,  в которых процессы обмениваются маркером ;  асинхронные модели с широковещательной передачей сообщений ;  асинхронные модели с топологией  « звезда ».  При необходимости про - верки моделей с другой топологией требуется разработка новых ме - тодов ,  возможно ,  аналогичных уже известным .  Сравним символьные методы и методы инвариантов .  Символь - ные методы и методы инвариантов применяются к параметризован - ным моделям с различной топологией :  кольцевой ,  линейной ,  древо - видной .  Символьные методы применяются ,  в основном ,  для проверки свойств безопасности ,  в то время как многие методы инвариантов применимы и для проверки свойств живучести .  Обе группы методов используют полуразрешающие процедуры ,  поэтому ,  в общем случае ,  не завершаются .  Для применения символьных методов описание параметризо - ванной модели требуется представить на специальном языке метода ,  обычно довольно сильно отличающегося от языков описания моделей средств  MC.  Методы инвариантов используют описания процессов в виде  LTS,  размеченных пропозициональными переменными ,  и совме - стимы с языками описания моделей средств  MC.  Методы инвариан - тов используют для проверки спецификации и поиска контрпримеров существующие средства  MC,  символьные же методы требуют реали - зации специальных алгоритмов .  Учитывая вышесказанное ,  в настоящей работе в качестве базо - вого метода выбран метод инвариантов ,  а процедура порождения мо - делей параметризованного семейства и поиска инвариантов основана на процедуре ,  используемой в методах сетевых инвариантов .  Метод сетевых инвариантов с использованием квазиблочной и блочной симуляций .  Идея метода заключается в поиске моделей - инвариантов среди  LTS,  соответствующих деревьям вывода ,  с ис - 48  пользованием отношения блочной симуляции .  Если такие модели - инварианты найдены ,  задача  PMC  может быть сведена к проверке ко - нечного числа моделей методом  MC.   При поиске инварианта сначала ищутся инварианты для тех не - терминалов ܣ ,  из которых выводятся лишь терминалы или сам не - терминал ܣ .  После того ,  как инварианты для таких нетерминалов найдены ,  осуществляется поиск инвариантов для нетерминалов ,  ис - пользующих в правилах вывода другие нетерминалы .  Так как поиск осуществляется только среди  LTS,  выводимых из нетерминалов ,  перебор осуществляется полностью автоматически .  Однако ,  не для каждого параметризованного семейства процедура перебора завершается .  Алгоритм построения блочной симуляции яв - ляется ключевым для поиска инварианта .  Из этого следует ,  что до - статочно ограничиться построением полублочной симуляции .  Таким образом ,  алгоритм построения полублочной симуляции является ключевым в методе поиска инвариантов .  Алгоритм построения полублочной симуляции .  В начале работы алгоритма пары начальных состояний первой и второй модели зано - сятся в множество неподтверждённых пар .  На каждой итерации алго - ритма проверяется гипотеза о том ,  что все неподтверждённые пары удовлетворяют определению полублочной симуляции .  Если в ходе проверки обнаруживается ,  что некоторая пара не удовлетворяет это - му определению ,  она заносится в множество опровергнутых пар .  Проверка прекращается ,  как только множества неподтверждённых и опровергнутых пар перестаёт расширяться .  При анализе ПО выделяют два основных метода контроля и анализа программ :  статический и динамический .  Статические методы основаны на исследовании тех или иных свойств ПО без его выпол - нения с использованием различных инструментальных сред .  Наибо - лее широкое распространение имеют следующие методы статическо - го контроля :  •  синтаксический контроль ;  •  контроль структурированности ПО ;  •  контроль правдоподобия программ ;  •  верификация ПО .  Методы верификации основаны на доказательстве корректности или некорректности ПО ,  соответствии разработанного ПО его специ - фикациям .  49  Верификация ПО весьма сложна ,  но практически гарантирует правильность полученного ПО относительно сформулированных для него спецификаций .  К недостаткам методов верификации можно от - нести то ,  что формирование метаописания ПО весьма сложно .  Кроме того ,  верификация практически не применяется на поздних этапах жизненного цикла ПО .  Существует два основных вида тестирования ПО :  •  функциональное тестирование ;  •  структурное тестирование .  Функциональное тестирование рассматривает программу как « черный ящик ».  Проверяется соответствие программы ее внешней спецификации .  Отмечено ,  что исчерпывающее функциональное те - стирование невозможно ,  а для программных продуктов большого размера применение его нецелесообразно .  Структурное тестирование основано на знании внутренней структуры программы и предполагает обход всех ветвей по графу управления ПО .  50  2.  АВТОМАТИЗАЦИЯ ПРОЦЕССА УПРАВЛЕНИЯ ДОСТУПОМ К ИНФОРМАЦИОННОМУ И ПРОГРАММНОМУ ОБЕСПЕЧЕНИЮ БАНКА 2.1.  Автоматизация разграничения доступа к информационному и программному обеспечению банка Для создания структурной модели управлением банком необхо - димо выявление взаимосвязей структурных подразделений банка с точки зрения управления защитой информационного и программного обеспечения банка .  На рис . 10  представлена структура банка с точки зрения управления защитой информационного и программного обес - печения банка .  Объектом защиты являются данные о деятельности банка ,  составляющие совершенно секретную информацию ,  коммер - ческую тайну ,  а также другую конфиденциальную информацию .  К совершенно секретным информационным и программным ре - сурсам банка относятся проекты ,  разработки банка ,  такие как проект - но - конструкторская документация ,  программно - аппаратные продук - ты ,  сопровождающая документация к ним .  К коммерческой тайне от - носится информация о материальных и финансовых ресурсах ,  вло - женных в производство конечного продукта банка .  К другой конфиденциальной информации можно отнести иден - тифицирующую информацию сотрудников .  Согласно рис . 10,  в банке существуют ,  как минимум ,  три уровня доступа к информационным и программным ресурсам :    « красный »  уровень ,  к которому относится доступ непосред - ственно к стратегически важным информационным и программным ресурсам банка ,  информации о разработках ,  проектах ,  сопровождаю - щей документации к ним ;    « жѐлтый »  уровень  –  доступ к информационным и программ - ным ресурсам банка ,  связанным с разработками ,  проектами ,  но не имеющим непосредственного отношения к совершенно секретным ;    « зелѐный »  уровень  –  отсутствие доступа к информационным и программным ресурсам банка ,  связанным с разработками и проекта - ми банка .  51  Рис . 10.  Структура коммерческого банка в аспекте управления защитой информационного и программного обеспечения банка К  « красному »  уровню доступа относятся структурные подразде - ления банка ,  которые имеют отношение к разработке проектов и их сопровождению .  К сопровождению относятся :  тестирование ,  провер - ка качества продуктов банка ,  проверка технической документации ,  проверка соблюдения установленных норм защиты информационного и программного обеспечения банка .  К  « желтому »  уровню доступа относятся структурные подразде - ления банка ,  которые производят обработку информации о проектах и разработках банка ,  не содержащей совершенно секретных данных .  К ним относятся структуры ,  проводящие экономический расчѐт ,  от - дел кадров ,  отдел закупок .  Экономическим группам ,  отделу снабже - ния нет необходимости знать детали разработок и проектов .  Данная информация является для них избыточной .  То же касается отдела кадров банка :  сотрудники отдела кадров имеют доступ только к пер - сональным данным других сотрудников банка .  52  К  « зеленому »  уровню доступа относятся подразделения банка ,  которым нет необходимости в ознакомлении со стратегически важ - ными информационными и программными ресурсами банка .  К ним относятся подразделения сторонних служб ,  например ,  здравпункт и столовая .  Основной целью разрабатываемой АСРДкИПО является обеспечение должного уровня защиты информационного и про - граммного обеспечения банка согласно требованиям ранжирования доступа ,  представленного на рис . 10.  Данные об уровне доступа со - трудников структурных подразделений банка к информационным ре - сурсам банка представлен в табл . 5.  Согласно представленной струк - турной модели управления банка с учѐтом требований защиты ин - формационного и программного обеспечения банка ,  а также пред - ставленных в таблице уровней доступа подразделений банка к ин - формации о проектах ,  требуется создание эффективного решения в виде отдельного модуля АСРДкИПО .  АСРДкИПО при работе с  « красным »  уровнем доступа должна отслеживать внутренние информационные потоки банка .  Поддержка журнала аудита важна с целью детектирования инцидентов наруше - ний правил работы с информационным и программным обеспечением банка и дальнейшего их расследования .  Что касается внешних информационных потоков на  « красном »  уровне доступа ,  то лучшим вариантом является изолирование рабо - чих мест сотрудников ,  относящихся к  « красному »  уровню доступа ,  от ГВС  ( Интернет ).  Если полное изолирование невозможно ,  то необхо - димо обеспечить фильтрацию информационного потока в виде агента подсистемы класса  DLP – Endpoint Solution.  Также это касается пере - носных носителей данных и принтеров :  лучшим вариантом является полный запрет на распечатку или хранение на съѐмных носителях стратегически важной информации  –  организация хранения инфор - мационных ресурсов только в контуре ЛВС банка .  Если это решение невозможно ,  то необходимо также применять подсистему класса  DLP  – Endpoint Solution.  На рис . 10  видно ,  что также к  « красному »  уровню относятся отделы стандартизации ,  контроля качества и контроля тех - нической документации .  Перечисленные отделы также имеют доступ к стратегически важной информации о разрабатываемом проекте ,  по - этому им необходимо уделить особое внимание .   53  Таблица  5  Уровень доступа структурных подразделений банка к стратегически важным информационным ресурсам банка 54  Сопровождающая документация представлена в электронном или бумажном виде ,  и она также является стратегически важным ин - формационным ресурсом ,  поэтому при работе с ней необходимо под - ключать все три составляющие АСРДкИПО :  подсистему класса  DLP  – Endpoint Solution;  подсистему слежения за внутренними потоками информации ;  подсистему разграничения доступа сотрудников к ин - формационным и программным ресурсам банка .  Основная задача от - дела информационной безопасности банка  –  отслеживание ,  предот - вращение и ведение расследований инцидентов нарушения правил работы с информационным и программным обеспечением банка .  Также в полномочия сотрудников отдела входит проверка поступаю - щего в банк аппаратного и программного обеспечения на наличие ви - русов ,  программных и аппаратных закладок ,  подслушивающих устройств и т . д .  Отдел информационной безопасности также несет ответственность за поддержку функционирования АСРДкИПО ,  по - этому его сотрудники должны проходить особую проверку  ( на поли - графе ). «Who guards the guardians?» « Кто следит за следящими ?»  фи - лософский вопрос ,  который до сих пор не решѐн ,  поэтому подбор персонала в отдел информационной безопасности банка должен осу - ществлять особо строго .  Информационные ресурсы ,  доступные сотрудникам отдела кад - ров ,  является ,  несомненно ,  конфиденциальными ,  но не обязательно критичными для банка .  Злоумышленник ,  перехвативший данные из отдела кадров ,  не будет осведомлѐн о разработках банка ,  более того ,  ему не будет доступен список сотрудников ,  задействованных в тех или иных текущих проектах ,  поэтому уровень доступа для сотрудни - ков отдела кадров  – « жѐлтый ».  К информации о разработках сотруд - ники отдела кадров вовсе не имеют доступа ,  поэтому необходимости в очень строгом уровне контроля нет .  Аналогична ситуация с эконо - мическими службами банка  –  расчѐт заработной платы и расходно - доходной части также производится изолированно .  Сотрудники эко - номических отделов не имеют доступа к стратегически важным ин - формационным ресурсам банка  –  к информации о разработках и про - ектах .  Злоумышленник ,  перехвативший данные из экономического отдела максимум ,  что может узнать  –  это размер заработной платы сотрудника и кодировку проекта ,  в котором сотрудник задействован ,  поэтому все экономические службы банка имею  « жѐлтый »  уровень доступа .  Сотрудники отделов снабжения и закупок осведомлены о материальных ресурсах ,  требуемых для основного производства ,  но 55  им присвоен  « жѐлтый »  уровень доступа .  Сотрудники общего отдела не имеют доступа ни к каким стратегически важным информацион - ным ресурсам банка ,  поэтому они относятся к  « зелѐному »  уровню доступа .  Таким образом ,  три уровня доступа охватывают всех со - трудников банка .  Основной задачей разрабатываемой АСРДкИПО является поддержание описанной выше методики управления защи - той информационного и программного обеспечения банка .  На рис . 11  отображены части информации о проекте ,  к каждой из которых опре - делен свой уровень доступа .  Рис . 11.  Области доступа к информации о проекте Для осуществления организации допуска сотрудника к той или иной части информации о проекте необходим дополнительный мо - дуль  –  менеджер доступа .  Основной задачей менеджера доступа яв - ляется проведение аутентификации и авторизации сотрудника .  Для работы менеджера потребуется база данных сотрудников банка .  В ба - зе данных должны содержаться имена сотрудников и их аутентифи - цирующая информация ,  в качестве которой могут выступать пароль ,  информация о материальном носителе ,  информация о биометриче - ских характеристиках сотрудника ;  также в базе данных необходимо 56  наличие информации о метках доступа объектов информационных отношений  –  информационном и программном обеспечении банка .  На рис . 12  представлен алгоритм работы сотрудника банка с АСРДкИПО .  Рис . 12.  Алгоритм работы сотрудника банка с АСРДкИПО Перед началом работы сотрудника с ПО банка ,  управление пе - редаѐтся АСРДкИПО .  Сотрудник предоставляет идентифицирующую 57  информацию  (IDe)  и аутентификатор  (Pe),  в качестве которого могут выступать :  -  пароль ;  -  материальный носитель ;  -  биометрические данные сотрудника .  Далее происходят процессы :  -  идентификации ;  -  аутентификации ;  -  авторизации сотрудника .  Все процедуры проходят последовательно .  При неудачном про - хождении любой из них управление передаѐтся в начало алгоритма .  После удачно пройденных последовательных процедур идентифика - ции ,  аутентификации и авторизации сотруднику предоставляется метка доступа L .  Метка доступа содержит данные об уровне доступа сотрудника к информационным массивам банка .  Соответственно представленной структурной модели автоматизированного управле - ния банком ,  метка доступа может определять  « красный уровень »,  « жѐлтый уровень »  и  « зелѐный уровень »  доступа .  Для реализации методики защиты информационного и про - граммного обеспечения банка необходимо использования базы дан - ных ,  которая содержит информацию как об объектах ,  так и о субъек - тах защиты .  На рис . 15  представлена схема таблиц базы данных банка .  В базе данных банка находятся шесть основных таблиц :  -  таблица  « Сотрудники »;  -  таблица  « Проекты »;  -  таблица  « Сопровождающая документация »;  -  таблица  « Экономические характеристики »;  -  таблица  « Отдела кадров предприятия »;  -  таблица  « Информационная безопасность ».  Поля таблицы базы данных перечислены в табл . 6.  Таблица  6  Таблица базы данных  « Сотрудники »  58  Рис . 13.  Схема таблиц базы данных коммерческого банка 59  В табл . 6  имеются следующие поля :  - ID –  идентифицирующая информация сотрудника  ( ключевое поле );  - P –  аутентифицирующая информация сотрудника ,  в качестве которой могут выступать пароль ,  материальный носитель ,  биометри - ческие данные сотрудника ;  - Descr –  описание сотрудника  –  поле ,  в котором могут хранить - ся данные о сотруднике  ( ФИО ,  год рождения ,  подразделение банка ,  к которому относится сотрудник );  - Level –  информация об уровне доступа сотрудника  (« красный »,  « жѐлтый »  или  « зелѐный »).  Поля таблицы базы  « Проекты »  данных перечислены в табл . 7.  Таблица  7  Таблица базы данных  « Проекты »  Как представлено в табл . 7,  таблица базы данных  « Проекты »  имеет поля :  - ProjectID –  идентификатор проекта  ( ключевое поле );  - Descr –  описание проекта ;  - Field1,…, FieldN –  поля подробной информации о проекте .  В качестве подробной информации о проекте могут выступать сроки сдачи проекта ,  дополнительные характеристики ,  входные данные ,  ограничения и т . д .  Поля таблицы базы данных  « Сопровождающая документация »  перечислены в табл . 8.  Таблица  8  Таблица базы данных  « Сопровождающая документация »  Таблица базы данных  « Сопровождающая документация »  имеет поля :  - DocID –  идентификатор документа  ( ключевое поле );  60  - ProjectID –  идентификатор проекта ,  к которому относится до - кумент ;  - Field1,…, FieldM –  поля подробной информации о документе .  В качестве подробной информации о документе могут выступать сроки сдачи документа ,  грифы секретности ,  дополнительные ограни - чения и т . д .  Поля таблицы базы данных  « Экономические характеристики »  перечислены в табл . 9.   Таблица  9  Таблица базы данных  « Экономические характеристики »  Таблица базы данных  « Экономические характеристики »  имеет поля :  - EcoID –  идентификатор экономического показателя  ( ключевое поле );  - ProjectID –  идентификатор соответствующего проекта ;  - Field1,…, FieldK –  поля подробной информации экономическо - го показателя .  В качестве подробной информации могут выступать стоимость ,  условия финансирования ,  номер контракта ,  договора и т . д .  Поля таблицы базы данных  « Отдел кадров предприятия »  пере - числены в табл . 10.  Таблица  10  Таблица базы данных  « Отдел кадров предприятия »  Таблица базы данных  « Экономические характеристики »  имеет поля :  - ID –  идентифицирующая информация сотрудника  ( ключевое поле );  - DepartmentID –  идентификатор подразделения банка ;  - Field1,…, FieldL –  поля дополнительной информации о сотруд - нике банка .  В качестве дополнительной информации могут высту - 61  пать :  фамилия ,  имя ,  отчество ,  должность ,  семейное положение ,  дата принятия на работу ,  другие персональные данные сотрудника .  Поля таблицы базы данных  « Информационная безопасность »  перечислены в табл . 11.  Таблица  11  Таблица базы данных  « Информационная безопасность »  Таблица базы данных  « Информационная безопасность »  имеет следующие поля :  - T –  время инцидента  ( ключевое поле );  - incidentID –  идентификатор инцидента нарушения правил ра - боты с информационным и программным обеспечением банка ;  - subjectID –  идентификатор субъекта ,  породившего инцидент ,  в качестве которого может выступать как сотрудник организации ,  так и сама система  ( ее процесс );  - objectID –  идентификатор объекта инцидента  –  части стратеги - чески важного информационного пространства банка ;  - LocationID –  идентификатор места инцидента ,  в качестве кото - рого могут выступать любые  « интерфейсы - выходы »  из ПО банка ( порт связи с Интернет , USB- порт ,  принтер и т . д .);  - Field1,…, FieldT –  поля дополнительной информации об инци - денте нарушения правил работы с информационным и программным обеспечением банка .  В качестве дополнительной информации могут выступать :  коды ошибок и исключений  ( детализация происшествия )  –  информация для сотрудника отдела информационной безопасности банка ,  идентификатор  « подозрительного »  пакета передачи данных и т . д .  Вспомогательные таблицы базы данных .  Для корректной работы АСРДкИПО с базой данной сотрудников банка необходимо наличие вспомогательных таблиц .  -  таблица  « Инциденты »;  -  таблица  « Субъекты »;  -  таблица  « Объекты »;  -  таблица  « Интерфейсы - выходы ».  Поля таблицы базы данных  « Инциденты »  перечислены в табл . 12.  62  Таблица  12  Таблица базы данных  « Инциденты »  Таблица базы данных  « Инциденты »  имеет следующие поля :  - incidentID –  идентификатор инцидента нарушения правил ра - боты с информационным и программным обеспечением банка  ( клю - чевое поле );  - incidentDescr –  описание инцидента .  Поля таблицы базы данных  « Субъекты »  перечислены в табл . 13.  Таблица  13  Таблица базы данных  « Субъекты »  Таблица базы данных  « Субъекты »  имеет следующие поля :  - subjectID –  идентификатор субъекта информационных отноше - ний  ( ключевое поле );  - subjectDescr –  описание субъекта ;  - ID –  идентификатор сотрудника ,  соответствующего идентифи - катору субъекта информационных отношений .  Поля таблицы базы данных  « Объекты »  перечислены в табл . 14.  Таблица  14  Таблица базы данных  « Объекты »  Таблица базы данных  « Объекты »  имеет следующие поля :  - objectID –  идентификатор объекта информационных отноше - ний  ( ключевое поле );  - objectDescr –  описание объекта информационных отношений ;  - DepartmentID –  идентификатор подразделения банка ,  к кото - рому относится соответствующий объект информационных отноше - ний ;  63  - ID –  идентификатор сотрудника ,  несущего ответственность за соответствующий объект информационных отношений .  Поля таблицы базы данных  « Интерфейсы - выходы »  перечислены в табл . 15.  Таблица  15  Таблица базы данных  « Интерфейсы - выходы »  Таблица базы данных  « Интерфейсы - выходы »  имеет следующие поля :  - LocationID –  идентификатор потенциального места инцидента нарушения правил работы с информационным и программным обес - печением банка  – « интерфейса - выхода »  из информационной системы банка  ( ключевое поле );  - locationDescr –  описание места инцидента ;  - DepartmentID –  идентификатор подразделения банка ,  к кото - рому относится соответствующий  « интерфейс - выход »  из ПО банка .  - ID –  идентификатор сотрудника ,  несущего ответственность за соответствующий  « интерфейс - выход ».  Для достижения требований принятой методики защиты инфор - мационного и программного обеспечения банка необходимо разгра - ничить доступ к таблицам базы данных .  Сотрудники разных структурных подразделений банка обраща - ются к одному и тому же информационному ресурсу  –  базе данных сотрудников банка .  Соответственно ,  к таблицам : « Информационная безопасность », « Инциденты , « Субъекты , « Интерфейсы - входы »,  « Объекты »  имеют доступ только сотрудники отдела информацион - ной безопасности .  Сотрудники отдела кадров имеют доступ к таблице « Отдел кадров предприятия ».  Экономические группы  ( планово - финансовый отдел ,  бухгалтерия ,  отдел труда и т . д .)  имеют доступ к таблице  « Экономические характеристики ».  К таблице  « Проекты »  полного доступа не имеет никто .  Разграничение доступа производит - ся относительно строк таблицы ,  а не таблицы целиком .  Также орга - низуется доступ к таблице  « Сопровождающая документация ».  Это связано с такой характеристикой информации ,  как полезность .  64  Сотрудник банка ,  принадлежащий к одному из отделов разра - ботки ,  имеет доступ только к тем строкам  ( кортежам таблицы ),  кото - рые относятся к проекту ,  над которым он работает в данный момент времени .  Причѐм ,  эффективность работы сотрудника увеличится ,  ес - ли ему будет предоставлена максимально большая часть информации о проекте .  Это связано с тем ,  что зачастую за надуманной секретно - стью разработки прячется корыстное утаивание от разработчика важ - ной для него информации ,  в том числе информации о технических заданиях ,  о требованиях заказчика ,  о планах и сроках сдачи и т . д . –  той информации ,  которая является важной для разработчика .  Поэто - му в рамках предлагаемой методики защиты информационного и программного обеспечения банка предполагается следующее утвер - ждение :  если конкретный разработчик  ( сотрудник одного из проект - но - конструкторских или научно - исследовательских подразделений банка )  имеет доступ к проекту ,  то этот доступ определяет максималь - ный уровень осведомленности об информации о этом проекте .  Дан - ное утверждение не противоречит принципу полезности информаци - онных и программных ресурсов банка ,  описанном ранее .  Для более высокого уровня защиты информационного и программного обеспе - чения банка доступ к таблице  « Проекты »  сотрудник получает не напрямую ,  а через таблицу  « Объекты » ( связь по идентификатору со - трудника  «ID»).  Аналогично ,  сотрудник экономической группы по - лучает информацию о сотруднике банка  ( например ,  когда производит расчѐт заработной платы )  не напрямую ,  а через таблицы  « Проекты »,  « Объекты », « Сотрудники ».  Полного доступа к таблице  « Сотрудники »  не имеет никто из физических лиц ,  в том числе и доступа по строкам .  Обращение к этой таблице также происходит во время процедур идентификации ,  аутентификации и авторизации пользователей .  Соот - ветственно ,  это обращение формирует сама АСРДкИПО .  Также мож - но организовать дополнительную защиту за счѐт использования « двойной аутентификации ».  Сотрудник банка проходит процедуру во время входа в систему ,  а также во время обращения к данным .  На рис . 14  отображено соответствие таблиц базы данных банка и струк - турным подразделениям .  Примеры окон программы работы с базой данных банка приведены в приложении .  65  Рис . 14.  Соответствие таблиц базы данных банка и доступа к ним сотрудников структурных подразделений 66  Для фиксации инцидентов ,  а также для проведения расследова - ний при разработке АСРДкИПО необходимо предусмотреть наличие журнала аудита .  Журнал аудита представляет собой таблицу базы данных ,  а также копию данной таблицы в отдельном файле  ( чаще всего лог - файле ).  Файл - лог может иметь несколько копий в системе .  Также необходимо предусмотреть тот факт ,  что журнал аудита дол - жен быть доступен только для просмотра и только сотрудниками от - дела информационной безопасности банка . « Дозапись »  строк  ( корте - жей )  должна производиться только самой АСРДкИПО .  Согласно представленным структурной модели автоматизированного управле - ния банком на основе принципов ограничения доступа к стратегиче - ски важным информационным ,  программным ресурсам ,  и схеме базы данных ,  журнал аудита относится к таблице  « Информационная без - опасность ».  Полями таблицы являются :  -  Идентификационный номер инцидента нарушения правил ра - боты с информационным и программным обеспечением банка  –  явля - ется уникальным ,  поэтому является ключевым полем .  Тип данных  –  счѐтчик ;  -  Время инцидента .  Тип данных  -  время ;  -  Идентификатор субъекта ,  инициализировавшего инцидент ( идентификатор сотрудника ).  Тип данных  - GUID;  -  Идентификатор объекта ,  к которому относится инцидент  ( файл конфиденциальной информации ).  Тип данных  - GUID;  -  Идентификатор места инцидента  –  физическое расположение инцидента  (USB- порт ,  принтер ,  терминал сотрудника ,  терминал ГВС и т . д .).  Тип данных  - GUID;  -  Дополнительные поля  –  поля ,  в которых располагается специ - фическая информация об инциденте .  Как правило ,  данное поле имеет тип данных  « строка »,  так как чаще всего специфической информаци - ей об инциденте являются коды ошибок ,  инициализированные ис - ключения .  Необходимо предусмотреть функцию просмотра таблицы  « Ин - формационная безопасность »  с возможностью фильтрации по :  -  времени ;  -  субъекту ;  -  объекту ;  -  месту происхождения инцидента .  Как видно из рис . 14  данная таблица связана с таблицами :  67  - « Инциденты »,  в которой хранится подробная информация об инциденте  –  описание инцидента и т . д .;  - « Субъекты »,  в которой хранятся данные о сотрудниках банка ;  - « Объекты »,  в которой хранится подробная информация о фай - лах стратегически важных информационных ресурсах банка ;  - « Интерфейсы - входы »,  в которой перечислены все возможные каналы утечки информационных ресурсов .  Перечисленные таблицы также доступны только для просмотра и записи только сотрудниками отдела информационной безопасности банка .  Как правило ,  данные таблицы формируются при проектирова - нии АСРДкИПО сотрудниками отдела информационной безопасно - сти с занесение в них информации о файлах стратегически важных информационных и программных ресурсов банка ,  о сотрудниках ,  о физических расположения портов .  В таблицы заносятся изменения в процессе работы АСРДкИПО при следующих ситуациях :  -  изменение списка сотрудников ;  -  изменение списка файлов стратегически важных информаци - онных ресурсах ;  -  изменение списка портов ,  физических устройствах ,  терминалов входа в ГВС  ( Интернет )  и т . д .;  -  изменение топологии ЛВС банка .  С целью повышения отказоустойчивости АСРДкИПО необхо - димо предусмотреть обязательное резервное копирование информа - ции о нарушениях  –  сохранение таблицы инцидентов в отдельном хранилище  « Архив инцидентов нарушения правил работы с инфор - мационным и программным обеспечением банка ».  Работу с  « архивом инцидентов »  необходимо организовать таким образом ,  чтобы запись в архив  ( изменение содержимого архива )  могла производить только АСРДкИПО  ( без участия человека ) –  т . е .  в автоматическом режиме .  Чтение информации из архива должно быть доступно всем сотрудни - кам отдела информационной безопасности банка .  Процесс работы с архивом инцидентов нарушений правил работы с информационным и программным обеспечением банка представлен на рис . 15.  Условные обозначения на рис . 15:  -  зеленая стрелка  –  обращение по чтению ;  -  красная стрелка  –  обращение по записи .  68  Рис . 15.  Процесс работы с архивом инцидентов Подразделение информационной безопасности банка относится к  « красному »  уровню доступа ,  но ответственность за обеспечение функционирования АСРДкИПО ложится именно на сотрудников это - го подразделения ,  поэтому данное подразделение можно классифи - цировать как подразделение высшего уровня доступа .  Сотрудники подразделения информационной безопасности банка  –  офицеры без - опасности  –  наделены высшим уровнем доступа ,  поэтому при зачис - лении в штат банка им необходимо пройти особую проверку ,  в том числе с использованием полиграфа .  Для непосредственной организа - ции и эффективного функционирования АСРДкИПО как системы обеспечения защиты информационного и программного обеспечения банка ,  исключающей возможные конфликты интересов ,  в банке необходимо наличие единого подразделения .  На данное подразделе - ние необходимо возложить следующие задачи :  -  проведение в жизнь принятой методики обеспечения защиты информационного и программного обеспечения банка ;  -  анализ текущего состояния обеспечения защиты ;  -  организация мероприятий и координация работ всех подразде - лений банка по комплексной защите составляющих ПО банка ;  -  контроль и оценка эффективности принятых мер и применяе - мых средств защиты ;  69  Основные функции подразделения обеспечения защиты состав - ляющих ПО банка заключается в следующем :  -  формирование требований к системам защиты  ( АСРДкИПО )  в процессе создания и дальнейшего развития существующих компо - нентов банка ;  -  участие в разработке ,  сопровождению АСРДкИПО ,  испытани - ях и приемке в эксплуатацию ;  -  обеспечение корректного функционирования АСРДкИПО ;  -  постоянный контроль и мониторинг основных программно - аппаратных модулей АСРДкИПО на наличие вредоносного про - граммного и аппаратного обеспечения ;  -  проверка информационных файлов ,  генерируемых АСРДкИПО в ходе функционирования системы  ( так называемы  log- файлов ),  в ко - торых содержатся данные об информационных потоках и о работе основных пользователей ПО банка со стратегически важными ин - формационными и программными ресурсами ;  -  реагирование на инциденты нарушения правил работы с ин - формационным и программным обеспечением банка согласно соот - ветствующим инструкциям и нормативным документам ;  -  проведение расследований инцидентов на основании получен - ных о АСРДкИПО файлов - логов ;  -  генерация и распределение между пользователями необходи - мых атрибутов доступа к информационным и программным ресурсам банка ;  -  наблюдение за функционированием АСРДкИПО и ее элемен - тов ;  -  постоянная проверка надѐжности функционирования АСРД - кИПО ;  -  разработка мер нейтрализации моделей возможных атак ;  -  обучение пользователей и обслуживающего персонала прави - лам работы с информационным и программным обеспечением банка ( в том числе особым правилам по работе с информационными ресур - сами особой важности );  -  оказание методической помощи сотрудникам банка в вопросах обеспечения параметров защиты ;  -  контроль за соблюдением пользователями  ( сотрудника банка )  и обслуживающим персоналом установленных правил обращения с информационными и программными ресурсами банка  ( в том числе со стратегически важными );  70  -  организация по указанию руководства служебного расследова - ния по фактам нарушения правил обращения с информационными и программными ресурсами  ( в том числе со стратегически важными ),  оборудованием банка ;  -  принятие мер при попытках несанкционированного доступа к информационным и программным ресурсам и компонентам ПО банка или при нарушениях правил функционирования системы защиты ( АСРДкИПО );  -  сбор ,  накопление ,  систематизация и обработка информации по вопросам обеспечения защиты информационных и программных ре - сурсов банка .  Организационно - правовой статус подразделения обеспечения защиты банка должен определяться следующим образом :  -  численность подразделения должна быть достаточной для вы - полнения всех перечисленных выше функций ;  -  сотрудники ,  занимающиеся обеспечением защиты информаци - онного и программного обеспечения банка не должны иметь других обязанностей ,  связанных с обеспечением функционирования техни - ческих компонентов ПО банка ;  -  сотрудники подразделения обеспечения защиты должны иметь право доступа во все помещения ,  где установлены технические сред - ства банка ,  и право прекращать обработку информационных ресурсов при наличии непосредственной угрозы для них ;  -  руководителю подразделения должно быть предоставлено пра - во запрещать включение новых компонентов ПО банка в число дей - ствующих ,  если они не отвечают требования защиты и это может привести к серьезным последствиям в случае реализации значимых угроз нарушения параметров защиты ;  -  подразделению обеспечения контроля защиты ПО банка долж - ны обеспечиваться все условия ,  необходимые для выполнения своих функций .  Основные компоненты АСРДкИПО представлены на рис . 16.  Основная задача ,  решаемые данной подсистемой разграничения доступа сотрудников банка к информационным и программным ре - сурсам банка  –  обеспечение соблюдения разграничения доступа за счѐт применения организационных ,  правовых ,  технических  ( аппарат - но - программные ),  физических мер защиты .  Основные модули АСРД - кИПО представлены на рис . 17.  71  Рис . 16.  Основные компоненты АСРДкИПО 72  Рис . 17.  Основные модули АСРДкИПО При разработке АСРДкИПО особое внимание уделялось приме - нению аппаратно - программных мер защиты :  применение алгоритма разграничения доступа ,  включающего процессы идентификации ,  аутентификации ,  авторизации .  Организационные меры защиты  –  это меры ,  регламентирующие процессы функционирования системы обработки данных ,  использо - вание ее ресурсов ,  деятельность персонала ,  а также порядок взаимо - действия пользователей с системой таким образом ,  чтобы в наиболь - шей степени затруднить или исключить возможность реализации угроз безопасности циркулирующей в системе информации .  К правовым мерам защиты относятся действующие в стране за - коны ,  указы и другие нормативные акты ,  регламентирующие правила обращения с информационными ресурсами и ответственность за их нарушения ,  препятствующие тем самым неправомерному их исполь - зованию и являющиеся сдерживающим фактором для потенциальных нарушений .  Технические  ( аппаратно - программные )  средства защиты –  различные электронные устройства и специальные программы ,  ко - торые выполняют  ( самостоятельно или в комплексе с другими сред - ствами )  функции защиты информационных и программных ресурсов банка  ( идентификацию и аутентификацию пользователей ,  разграни - чения доступ к ресурсам ,  регистрацию событий ,  криптографическое закрытие информации и т . д .).  К физическим мерам защиты относят 73  разного рода механические ,  электронные или электронно - механические устройства и сооружения ,  специально предназначен - ные для создания физических препятствий на возможных путях про - никновения и доступа потенциальных нарушителей к защищаемому информационному и программному обеспечению и другим ресурсам ПО банка ,  а также технические средства визуального наблюдения ,  связи охранной сигнализации .  Система слежения за внутренними ин - формационными потоками в банке позволяет отслеживать весь жиз - ненный цикл стратегически важных информационных ресурсов банка –  кто создал ,  изменил ,  где он  ( ресурс )  хранится ,  кто из сотрудников его копировал ,  кому передавал по внутренней электронной почте и т . д .   Основной функцией модульной подсистемы класса  DLP  являет - ся отслеживание утечек информационных ресурсов банка через сеть ,  съѐмные носители данных ,  принтеры и т . д . –  т . е .  детектирование угроз нарушения параметров защиты информационного и программ - ного обеспечения банка происходит только  « в месте »  соприкоснове - ния ПО банка с внешней средой  –  с ГВС ,  а также на всех  « интерфей - сах - выходах »:  съѐмные носители данных ,  факсы ,  принтеры .  За мони - торинг внутренних потоков конфиденциальной информации в банке подсистема класса  DLP  ответственности не несѐт .  Одной из задач мо - дульной подсистемы класса  DLP  является контроль работы пользова - телей ПО банка в глобальной сети Интернет .  Целью защиты страте - гически важных информационных и программных ресурсов является предотвращение или минимизация наносимого ущерба  ( прямого или косвенного )  субъектам информационных отношений посредством нежелательного воздействия на компоненты ПО банка ,  а также раз - глашения  ( утечки ),  искажения  ( модификации ),  утраты  ( снижения степени доступности )  или незаконного тиражирования информаци - онных ресурсов ,  некомпетентного и некорректного использования программных ресурсов .  Таким образом ,  применение только одной из перечисленных технологий не способно решить поставленных в ра - боте задач обеспечения защиты информационного и программного обеспечения банка .  Для обеспечения требуемого уровня защиты необходимо применение всех трѐх подсистем в едином комплексе .  74  2.2.  Обеспечение надёжности и доступности компьютерных систем банка Под надежностью понимается вероятность события ,  состоящего в том ,  что система выполняет требуемую задачу на временном интер - вале  [0,t].  Доступность есть вероятность события ,  состоящего в том ,  что система выполняет требуемую задачу в определенный момент времени .  В монографии рассмотрим модель без восстановления рабо - чей станции после сбоя и модель с восстановлением .  Рассмотрим сначала случай без восстановления рабочей станции .  Пусть  ( i , j )  есть состояние ,  в котором находится система .  Индекс i обозначает количество работоспособных рабочих станций  ( прини - мает значения  2,1,0),  индекс j принимает значения  1- сервер работает ,  0- сервер находится в состоянии сбоя .  Считаем ,  что система находит - ся в работоспособном состоянии ,  если сервер и хотя бы одна из рабо - чих станция работоспособны .  Множество возможных состояний си - стемы есть А  = {(0, 1), (1,1), (1,0), (2.0), (2,1)}.  Пусть X t ( w ),  t   R + есть случайный процесс ,  описывающий состояние работы системы ,  при - нимающий значения из множества А .  Пусть  i (t) =  Р  (w:  X t ( w )= i ),  i  {(2.1), (1,1), (0,1), (2,0), (1,0)}.  Предположим ,  что случайный процесс X t ( w )  есть марковская цепь со следующей диаграммой ,  рис . 18.  Рис . 18.  Диаграмма марковской цепи Величина надежности R ( t )  для данной системы имеет вид 75  Диаграмма марковской цепи для системы с восстановлением представлена на рис . 19.  Рис . 19.  Диаграмма марковской цепи для системы с восстановлением Условие  w  +  подразумевает ,  что в случае сбоя одной из ра - бочих станций ,  осуществляется мгновенный переход в  « идеальное »  состояние  (2,1).  В этом случае показатель надежности R ( t )  достигает максимума и его предельное значение зависит лишь от параметра  s - среднего времени сбоя сервера .   Далее исследуем метод обновления работы программы .  Предпо - лагаем ,  что с самого начала работы компьютерная система ,  на кото - рой исполняется программа ,  находится в некотором идеальном со - стоянии .  Вероятность сбоев в этом состоянии близка к нулю .  Идеаль - ное состояние обозначим через  «0».  Предполагаем ,  что пребывание системы в состоянии  «0»  не бесконечно и через некоторое время си - стема переходит в состояние  « Р »,  в котором вероятность сбоя уже от - 76  лична от нуля .  Происходит этот переход по причине того ,  что про - цесс функционирования системы со временем деградирует и начина - ет происходить постепенная утечка ресурсов компьютерной системы .  Из состояния  « Р »  система через некоторое время переходит в состоя - ние  «F»,  что соответствует сбою в работе системы .  Данный процесс можно формализовать с помощью следующей математической моде - ли .  Пусть X t ( w ), t  <   R + есть случайный процесс со значениями во множестве  {0,  Р , F}.  Предполагаем ,  что X t ( w ), t  <   R + есть марковская цепь ,  диаграмма которой представлена на рис . 20.  Рис . 20.  Диаграмма марковской цепи X t ( w ), t  <   R + Пусть также процесс X t ( w )  однородный по времени и обладает марковским свойством .  Обозначим .  Тогда справедлива система дифференциальных уравнений Кол - могорова :  В силу эргодической теоремы Таким образом ,  имеем следующую систему уравнения для пре - дельных вероятностей :  77  Отсюда Величина  F есть предельная вероятность пребывания системы в состоянии сбоя .  С ее помощью можно оценить надежность работы компьютерной системы .  Если величина  F велика ,  то это говорит о низкой надежности системы .  Величина доступности системы опреде - ляется как  A  = 1 –   F .  Далее рассмотрим модель ,  в которой система из состояния  « Р »  может также переходить в состояние  «R»,  в котором осуществляется обновление работы системы .  Пусть диаграмма пере - ходов системы имеет вид ,  представленный на рис . 21.  Рис . 21.  Диаграмма переходов компьютерной системы Считаем ,  что система во время пребывания в состоянии  «R»  не функционирует .  Тогда выражение для предельной вероятности сбоя системы примет вид 78  Величина доступности системы определяется как Последние выражения указывают достаточное условие ,  при ко - тором метод обновления увеличивает величину предельной доступ - ности системы .  Моделирование работы банкомата с применением ограни - чений доступа к программному обеспечению банка .  Модель общения банкомата с сервером банка построена на ос - нове транзакций :  в ходе взаимодействия с пользователем устройство банкомата накапливает вводимую информацию в специальном внут - реннем списке ,  отправляя серверу по требованию совершения опера - ции полный набор информации ,  описывающий транзакцию .  Так ,  в начале работы пользователь вводит номер карты .  После этого банко - мат запрашивает у него  PIN- код .  Как номер карты ,  так и введенный PIN- код запоминаются во внутреннем списке .  Банкомат запрашивает у сервера авторизацию для карты .  В случае неверного ввода  PIN- кода ,  карта возвращается .  После успешной проверки  PIN- кода клиенту становится доступ - но основное меню ,  в котором он может выбрать одно из действий :   забрать карту ;   посмотреть остаток счета ;   снять деньги со счета .  При выборе первого пункта пользователю возвращается карта ,  и работа с банкоматом завершается .  При выборе последнего пункта пользователю необходимо дополнительно выбрать одну из предопре - деленных сумм для снятия или ввести сумму с клавиатуры .  После этого ,  как и в случае выбора второго варианта ,  автомат отправляет серверу накопленные данные .  При получении ответа от сервера кли - енту отображается информация о результате операции .  После этого банкомат вновь отображает главное меню ,  или клиент забирает карту .  79  Управление осуществляется системой взаимодействующих ав - томатов .  Формальное описание ,  содержащее в себе объекты управле - ния ,  источники событий и систему автоматов ,  приведено ниже .  На рис . 22  приведена схема связей автоматов .  Рис . 22.  Схема связей автоматов с поставщиками событий и объектами управления 80  На рис . 23  представлен граф переходов автомата ,  управляющего банкоматом .  Рис . 23.  Граф переходов автомата ,  отвечающего за работу банкомата Рассмотрим ситуацию ,  когда к созданной программе изменяют - ся требования .  Пусть сценарий работы с банкоматом изменился сле - дующим образом : « В случае неверного ввода  PIN- кода он запрашива - ется повторно .  В случае неверного ввода  PIN- кода три раза подряд работа с банкоматом принудительно завершается ».  Граф переходов автомата ,  отвечающего за работу банкомата ,  достаточно громоздок .  Упростим его ,  выделив два вызываемых авто - мата :  один для режима просмотра остатка счета ,  второй для режима снятия денег со счета .  Граф переходов автомата после применения таких рефакторингов представлен на рис . 24.  81  Рис . 24.  Граф переходов автомата ,  отвечающего за работу банкомата ,  после выделения вызываемых автоматов Граф переходов стал существенно проще для восприятия .  В но - вом графе существует фрагмент ,  который нуждается в изменении :  из состояния  3 (« Авторизация »)  по событию ݁ 11 («pin  код неверный »)  совершается действие ݋ 1. ݖ 50 (« Возврат карты »)  и переход в состоя - ние  50 (« Завершение работы »).  Необходимо ,  чтобы по событию ݁ 11  карта не возвращалась ,  а производился выбор действия в зависимости от числа неверных попыток ввода  PIN- кода .  Получается ,  что следует некоторым образом разделить связь события ݁ 11  и выходного воздей - ствия ݋ 1. ݖ 50.  Самый простой способ сделать это  –  осуществить пере - нос воздействий с переходов ,  ведущих в состояние  50,  внутрь этого состояния .  Граф переходов автомата ,  получающийся после применения та - кого рефакторинга ,  представлен на рис . 25.  По событию ݁ 11  должно осуществляться ветвление в зависимо - сти от числа попыток .  Поэтому добавим в граф переходов состояние 5 (« Неверный  PIN- код »),  в котором будет это ветвление осуществ - ляться .  Теперь установим конечным состоянием перехода по собы - 82  тию ݁ 11  добавленное состояние .  Полученный граф переходов пред - ставлен на рис . 26.  Рис . 25.  Граф переходов автомата ,  отвечающего за работу банкомата ,  после переноса воздействия внутрь состояния При входе в состояние  5  выполняется выходное воздействие ݋ 2. ݖ 5 (« Проверка количества попыток »).  Воздействие ݋ 2. ݖ 5  активи - зирует одно из двух событий :  ݁ 26 (« Повторная авторизация »)  или ݁ 7  (« Карта заблокирована »).  В первом случае ,  автомат должен перейти в состояние  2,  во втором  –  в состояние  50.  Соответствующие измене - ния графа переходов легко осуществить  ( рис . 27).  Полученный граф переходов удовлетворяет всем поставленным требованиям .  Стоит отметить ,  что при модификации программы при - менялись только рефакторинги и базовые изменения ,  что позволило избежать анализа графа переходов после каждого проведенного из - менения .  83  Рис . 26.  Граф переходов автомата ,  отвечающего за работу банкомата ,  после добавления нового состояния Рис . 27.  Граф переходов автомата ,  отвечающего за работу банкомата 84  3.  АНАЛИЗ ДОСТОВЕРНОСТИ И ВЕРИФИКАЦИИ ИНФОРМАЦИИ В ИНФОРМАЦИОННО - ТЕЛЕКОММУНИКАЦИОННЫХ СИСТЕМАХ БАНКА 3.1.  Алгоритм анализа достоверности и верификации информации Алгоритм построения отношения полублочной симуляции меж - ду двумя моделями при анализе достоверности и верификации ин - формации в информационно - телекоммуникационных системах КБ .  В разделе приведена упрощённая версия алгоритма .  Различные оптими - зации ,  нацеленные на повышение эффективности ,  указаны в прило - жении А .  При описании алгоритма используются синтаксис и семантика языка  C++,  дополненные следующим синтаксисом ,  типами и вспомо - гательными ключевыми словами :   Тип  tuple < ܶ 1 , ...,  ܶ ݊ >  описывает кортеж над типами ܶ 1 , ...,  ܶ ݊ .  Кортеж может записываться следующим образом : ( ܽ 1 , ...,  ܽ ݊ ),  где ܽ ݅  –  значение или переменная типа ܶ ݅ .  Кортежи поддерживают операции присваивания и сравнения .   Тип  set <  ܶ  >  описывает множество из элементов типа ܶ .  Тип set  соответствует типу  std::set  стандартной библиотеки языка  C++.  Для краткой записи пользуемся математическими обозначениями пу - стого множества  ( ∅ )  и операций :  ∈ , / ∈ ,  ∪ ,  ∩ ,  ∖ .   Тип  vector <  ܶ  >  описывает массив из элементов типа ܶ .  Тип vector  соответствует типу  std::vector  стандартной библиотеки языка C++.  Для типа  vector < ܶ >  используются стандартные функции :  push_back, pop_back, back, operator[], size.   Тип  list <  ܶ  >  описывает список из элементов типа ܶ .  Тип  list  соответствует типу  std::list  стандартной библиотеки языка  C++.  Для типа  list <  ܶ  >  используются стандартные функции : push_back,  pop_back, back, size.   Цикл по множеству : foreach  ݔ  in  ܺ .  Перебирает элементы мно - жества ܺ в произвольном порядке ,  на каждой итерации текущий эле - мент множества ܺ сохраняется в переменной ݔ .  Оценка сложности 85  операции зависит от структуры данных ,  используемой для представ - ления множества .   Выбор произвольного элемента из множества :  ݔ  = any from  ܺ .  Записывает в переменную ݔ произвольный элемент непустого множе - ства ܺ .  В случае пустого множества ܺ выполнение оператора приво - дит к ошибочной ситуации .  Оценка сложности операции зависит от структуры данных ,  используемой для представления множества .  Используемые типы :   тип ܵݐܽݐ݁ 1 описывает состояния  LTS  ܯ 1 ,   тип ܵݐܽݐ݁ 2 описывает состояния  LTS  ܯ 2 ,   тип ܣܿݐ݅݋݊ 1 описывает действия  LTS  ܯ 1 ,   тип ܣܿݐ݅݋݊ 2 описывает действия  LTS  ܯ 2 .  Для построения полублочной симуляции воспользуемся подхо - дом ,  основанным на итеративном вычислении неподвижной точки .  Для того ,  чтобы избежать построения первого приближения отноше - ния ,  которое на практике требует хранения большого количества со - стояний ,  инициализировали множество ܪ  « ленивым »  способом .  Строящееся множество ܪ делится на два непересекающихся подмно - жества :  опровергнутые пары  (negatives)  и неподтверждённые пары (positives).  В начале работы алгоритма пары начальных состояний первой и второй модели заносятся в множество неподтверждённых пар .  На каждой итерации алгоритма проверяется гипотеза о том ,  что все не - подтверждённые пары удовлетворяют определению полублочной си - муляции .  Если в ходе проверки обнаруживается ,  что некоторая пара не удовлетворяет этому определению ,  тогда она заносится в множе - ство опровергнутых пар .  Проверка прекращается ,  как только множе - ства неподтверждённых и опровергнутых пар перестаёт расширяться .  Листинг .  Краткое описание алгоритма построения полублочной симуляции .  86  87  88  Функция  build  строит отношение полублочной симуляции опи - санным выше способом .   Функция  satisfiesDef  проверяет определение полублочной симу - ляции для одной пары состояний ,  используя множества ܲ݋݈݀ и ܰ .  Функция  satisfiesDef  использует функции  lazyHasPositive,  buildFront1  и  buildFront2.   Функция  lazyHasPositive  проверяет наличие пары в множествах ܲ ∪ ܲ݋݈݀ и ܰ .  Если пара присутствует в множестве ܲ ∪ ܲ݋݈݀  ( множе - стве ܰ ),  функция возвращает истину  ( ложь соответственно ).  Если же пара не найдена в обоих множествах ,  тогда это означает ,  что она по - 89  сещается в первый раз ,  и в этом случае пара заносится в множество неподтверждённых пар ܲ ,  а функция возвращает истину .   Функции  buildFront1  и  buildFront2  строят множества финальных переходов из заданного состояния  LTS  ܯ 1 и ܯ 2 соответственно ( фронты ).  В качестве верификатора моделей ПО ,  используемого для про - верки формул темпоральной логики ,  выбран верификатор  Spin.  На вход ИТС подаются описания прототипов процессов и сетевой грам - матики .  По сетевой грамматике строятся модели ,  порождаемые не - терминальными символами грамматики .  Для каждого нетерминала грамматики проводится поиск модели - инварианта среди моделей ,  выводимых из данного нетерминала .  Проверка того ,  что модель явля - ется инвариантом ,  осуществляется с помощью построения полублоч - ной симуляции .  Когда для каждого нетерминала найдена модель - инвариант ,  может быть построен инвариант проверяемого семейства моделей .  В тех случаях ,  когда найти инвариант не представляется воз - можным ,  предлагается использовать подсистему нахождения контр - примеров по построенному отношению полублочной симуляции между моделями .  С помощью контрпримеров могут быть обнаруже - ны различия в поведении моделей семейства с различным числом процессов .  Протокол резервирования ресурсов предоставляет механизм ре - зервирования сетевых ресурсов для соблюдения заданного качества сервиса  (QoS).  Протокол реализован на транспортном уровне стека протоколов  TCP/IP.  Данный протокол используется для обеспечения определённой скорости передачи аудио -  и видеотрафика от сервера к потребителю .  На уровне протокола выделяются три вида взаимодей - ствующих хостов :  производители данных  (senders),  потребители дан - ных  (receivers)  и маршрутизаторы  (routers).  Потребители ,  производи - тели и маршрутизаторы объединены сетью .  Потребители подписы - ваются на получение данных от заданных производителей ,  произво - дители рассылают данные подписанным потребителям .  Подписка по - требителя проводится рассылкой соответствующим производителям запроса на резервирование канала от производителя к потребителю .  В запросе на резервирование задаются ограничения на пропускную способность канала и скорость реакции .  При прохождении запроса через маршрутизатор принимается решение ,  есть ли у него необхо - димые ресурсы для поддержания качества сервиса или нет .  Если ре - 90  сурсов недостаточно ,  маршрутизатор отсылает потребителю отказ в резервировании .  Если ресурсы имеются ,  тогда маршрутизатор пере - сылает запрос следующему хосту .  После успешного резервирования канала создаётся сессия и производитель отсылает данные потреби - телю в рамках созданной сессии до тех пор ,  пока одна из сторон не закроет сессию .  Так как протокол находится на транспортном уровне ,  предпола - гается ,  что маршруты между хостами построены на сетевом уровне .  В протоколе используются два вида рассылки :  адресная  (unicast)  и групповая  (multicast).  В  RSVP  предусмотрена возможность подтвер - ждения резервирования при изменении маршрутов в сети .  В общем случае хост - потребитель может быть и хостом - производителем .  В протоколе определены следующие вспомогательные механиз - мы :  классификатор пакетов  (packet classifier),  планировщик пакетов (packet scheduler),  механизм контроля доступа  (policy control),  меха - низм контроля соединения  (admission control).  Классификатор паке - тов выбирает уровень качества сервиса и возможные пути следования пакетов .  Планировщик пакетов определяет порядок отправки паке - тов .  Механизм контроля доступа определяет права пользователя на резервирование ресурсов в заданном объёме .  Механизм контроля со - единения проверяет наличие необходимых сетевых ресурсов на про - межуточных узлах сети .  В протоколе определены следующие типы сообщений ,  которы - ми обмениваются производители и потребители :   сообщение  path  рассылается производителями для оповещения потребителей о наличии сетевого ресурса ;   сообщение  resv  рассылается потребителями после получения сообщения  path  с целю подписки на ресурс производителя ;   сообщение  path_teardown  рассылается производителем для за - крытия всех существующих соединений ;   сообщение  resv_teardown  рассылается потребителем с целью прекращения подписки на сетевой ресурс производителя ;   сообщение  path_refresh  периодически рассылается производи - телем для проверки работоспособности установленных соединений ;   сообщение  resv_refresh  периодически рассылается потребите - лем для проверки работоспособности соединения ;   сообщение  path_error  посылается маршрутизатором в случае ошибки во время рассылки  path;  91   сообщение  resv_error  посылается маршрутизатором в ответ на запрос о резервировании  ( сообщение  resv)  в случае отсутствия необ - ходимых ресурсов ;   сообщение  data  рассылается производителям для передачи данных потребителям ;   сообщение  resv_conf ( необязательное )  рассылается потребите - лям для подтверждения резервирования ресурса .  Схема взаимодействия процессов .  После установления сетевых маршрутов  ( на сетевом уровне )  производители рассылают сообщение типа  path  для уведомления потребителей о наличии сетевых ресурсов .  Маршрутизаторы пересылают эти сообщения по дереву маршрутиза - ции .  После приёма сообщения  path  потребитель может послать в от - вет запрос на резервирование ресурса  resv  с заданными параметрами качества сервиса .  Маршрутизаторы проверяют ,  выполняются ли тре - бования к качеству сервиса .  Если требования не выполняются ,  марш - рутизатор отвечает сообщением  resv_error.  В противном случае маршрутизатор пересылает сообщение следующему хосту в таблице маршрутизации .  В случае получения сообщения  resv  производитель создаёт сессию для обмена данными с потребителем и начинает по - сылать сообщения типа  data,  содержащие данные для потребителя .  В любой момент производитель ,  потребитель или маршрутизатор могут проверить работоспособность соединения с помощью сообщений ти - па resv_refr  и  path_refr.  Производитель  ( потребитель )  может закрыть сессию рассылкой сообщения  path_teardown ( сообщения refr_teardown  соответственно ).  При создании модели протокола по его описанию необходимо провести абстракцию с учётом выбранного класса свойств .  Использу - ем модель ,  в которой можно проверять спецификации для производи - телей ,  потребителей и маршрутизаторов по отправке / приёму сообще - ний в терминах логики линейного времени .  Ниже перечислены основные абстракции ,  которые использова - лись при построении модели рассматриваемого протокола .  Сообщения .  В протоколе используются два вида рассылки со - общений :  адресная и групповая .  При адресной рассылке каждый по - требитель задаёт адрес производителя ,  на сообщения которого он хо - чет подписаться ,  и сохраняет в пакете свой собственный адрес .  В случае адресной рассылки модель должна описывать адрес узла ,  при этом размер типа адреса растёт с числом узлов в сети .  Так как метод не поддерживает модели с бесконечным числом состояний ,  адресная 92  рассылка из модели исключена .  В модели используется групповая рассылка в пределах одной группы .  Логическая топология сети .  Протокол располагается на транс - портном уровне и использует протоколы маршрутизации сетевого уровня .  Так как в модели рассматривается групповая рассылка сооб - щений ,  процессы объединены с помощью дерева групповой рассыл - ки ,  в корне которого располагается производитель сообщения  (source  based multicast distribution tree).  В модели используется бинарное де - рево .  Однако принципиальных ограничений на моделирование дерева с заданной степенью ветвления  ( для всей топологии )  в методе нет .  Типы сообщений .  В модели используются сообщения типов :  path, resv, data, path_teardown, resv_t eardown, path_refre sh, resv_refresh,  path_error, resv_error.  Необязательные сообщения типа  path_conf,  под - тверждающие успешное резервирование ,  не используются .  Механизм контроля соединения .  В протоколе  RSVP  описан ме - ханизм задания ограничений на качество сервиса с помощью филь - тров .  В каждом маршрутизаторе ,  через который проходит запрос на резервирование ,  проводится проверка возможности резервирования с помощью механизма контроля соединения .  В модели не рассматри - ваются различные варианты контроля соединения .  Предполагается ,  что каждому маршрутизатору всегда хватает ресурсов для выполне - ния запроса на резервирование .  Сбои .  Описание протокола предусматривает возможность изме - нения топологии сети и реакции на отключение маршрутизаторов .  В модели все маршрутизаторы и каналы считаются надёжными .  Другие абстракции .  В модели не рассматривается механизм кон - троля доступа .  Также не моделируются тайм - ауты .  Описание модели .  Модель протокола реализована на языке TinyPromela.  В модели участвуют процессы ,  порождаемые из описа - ний прототипов  Sender ( производитель ), Router ( маршрутизатор )  и Receiver ( потребитель ).  Указанные прототипы представлены разме - ченными системами переходов ,  содержащими  9408, 24  и  126  состоя - ний соответственно .  Листинг .  Сетевая грамматика модели  RSVP (RSVPNet).  93  На рис . 28  приведена архитектура подсистемы построения по - лублочной симуляции .  По описанию прототипов процессов и описа - нию привязки процессов к каналам на подмножестве языка  Promela  порождается описание на промежуточном языке описания моделей PTY.  По описанию моделей на языке  PTY  порождаются функции вы - числения следующих состояний системы по предыдущему на языке C++.  Сгенерированные функции собираются вместе с модулями по - строения полублочной симуляции ,  в результате чего создаётся ис - полняемый файл ,  настроенный на построение симуляции между дву - мя заданными моделями .  Язык  PTY  служит низкоуровневым тексто - вым представлением  LTS,  в котором описываются непосредственно переходы процессов из одного состояния в другое .  Основные отличия языка  PTY  от  MDL:   в качестве механизма синхронизации используется синхрони - зация действий и ко - действий вместо разделяемых переменных ;   разрядность целочисленных переменных не указывается явно ,  а вычисляется по телу процессов ,  так как над целочисленными типа - ми допустимы лишь операции присваивания и сравнения ;   наряду с целочисленными типами поддерживаются перечис - лимые типы .  94  Рис . 28.  Архитектура подсистемы проверки симуляции 95  На языке  PTY LTS  задаётся с помощью трёх секций :  секции прототипов процессов ,  секции экземпляров процессов и секции свя - зывания действий различных процессов .  В секции прототипов процессов для каждого прототипа описы - ваются локальные переменные процесса и множество переходов ви - да : action: x_1 = u_1, ..., x_m = u_m => y_1 = v_1, ..., y_n = v_n,  где action  соответствует обозначению действия в  LTS,  пары  x_i = u_i, 1  ≤ ݅ ≤ ݉ ,  задают условие на значения переменных ,  при котором сраба - тывает переход ,  а пары  y_j = v_j, 1  ≤ ݆ ≤ ݊ ,  задают новые значения пе - ременных в результате выполнения перехода .  В секции экземпляров процессов задаются процессы ,  порождае - мые с помощью описаний в прототипах .  Описание процесса выглядит следующим образом : p1 = new Proto().  Данная запись означает по - рождение процесса с именем  p1  и телом ,  изоморфным  LTS,  заданной в прототипе  Proto.  В секции связывания действий процессов задаются пары син - хронизации действий экземпляров процессов вида : p.a / q.b,  где  p  и  q  –  имена экземпляров процессов , a  и  b –  названия синхронизируемых действий .  Листинг .  Состояние распределённой системы .  Функция переходов системы задаётся с помощью функций пе - реходов процессов .  Для каждого процесса  pi  задаются массивы ,  ука - занные в следующем листинге .  Листинг .  Массивы описания переходов .  Данное представление позволяет быстро перебирать возможные переходы из заданного состояния .  При этом создаваемые массивы не потребляют критического объёма памяти ,  так как системы переходов 96  всех процессов малы ,  в то время как система переходов композиции процессов велика .  Переходы  LTS  распределённой системы вычисляются  « на лету »  с использованием массивов переходов процессов .  Листинг Б .6.  Схема генерации функции построения переходов « на лету »  97  98  Аналогично функции  nextState  порождается функция  prevState,  вычисляющая состояния ,  из которых можно попасть в заданное со - стояние по заданному действию .  Функция  prevState  используется для проверки пар состояний в отношении полублочной симуляции в том случае ,  когда пара состояний заносится в множество опровергнутых пар .  Благодаря использованному подходу нам удалось избежать предварительного построения и хранения в памяти графа переходов распределённой системы без заметной потери производительности .  В качестве хранилища пар состояний выбрали стандартный кон - тейнер  std::set<State1, std::set<State2> > ( в дальнейшем это хранилище называется  std).  Однако с ростом числа процессов в моделях потреб - ление памяти при построении отношения симуляции росло довольно быстро .  При запуске тестов даже на  5  процессах со  100  состояниями объём используемой памяти превышал два гигабайта .  Из - за нехватки памяти при использовании хранилища  std  реши - ли использовать одно из символьных представлений множества со - стояний .   Используется реализация  dfa  из исходных кодов  Spin  версии 4.2.7.  Для операций над  dfa  верны следующие оценки сложности :   время выполнения операции вставки слова оценивается вели - чиной ܱ ( ݇ ·| Σ ܣ |),   время выполнения операции удаления слова так же оценивает - ся величиной ܱ ( ݇  | Σ ܣ |),   время выполнения операции проверки вхождения слова в язык автомата оценивается величиной ܱ ( ݇ ).  Данное представление хорошо подходит для хранения множеств неподтверждённых и опровергнутых пар ,  т . к .  проверка наличия со - стояния в множествах проводится чаще ,  чем вставка и удаление .  При этом множество состояний довольно сильно сжимается ,  благодаря разметке рёбер интервалами целых чисел вместо значений .  В исполь - зуемой реализации нам не хватает операции перебора слов автомата 99  для организации цикла по неподтверждённым состояниям .  Для реа - лизации перебора слов автомата мы добавляем к слову дополнитель - ный байт  –  признак чётности итерации .  При переборе слов автомата на итерации ݅ в языке автомата ищется произвольное слово  ( ݅ ݉݋݀ 2)  ݓ  ( с признаком чётности ݅ ݉݋݀ 2).  Если такое слово найдено ,  то слово  ( ݅ ݉݋݀  2)  ݓ удаляется из языка автомата ,  добавляется слово  (( ݅ + 1)  ݉݋݀  2)  ݓ и выдаётся слово ݓ .  Для быстрого поиска произвольного слова в автомате переходам приписывается флаг  empty,  информирующий о пустоте языка автома - та по пройденному префиксу .   Листинг .  Перебор состояний в  DFA.  100  На каждом уровне автомата необходимо перебрать не более  | Σ ܣ |  рёбер ,  поэтому сложность операции поиска произвольного слова с заданным префиксом оценивается величиной ܱ ( ݇  | Σ ܣ |),  последующие операции удаления и вставки также занимают ܱ ( ݇  | Σ ܣ |).  Сложность функции  dfa_next  равна ܱ ( ݇  | Σ ܣ |).  101  Более эффективным представлением оказалось представление dfa,  потребляющее в экспериментах  20-30  мегабайт памяти в тех слу - чаях ,  когда представление  std  требует более  2  гигабайт .  Применение представления  dfa  позволило сократить и время вычисления на боль - ших примерах .   3.2.  Верификация вычислительных систем банка В качестве примера предложенного метода верификации моде - лей разного уровня рассмотрена графовая модель абстрактного и структурного автоматов схемы пересчета ,  его схемная реализация и построение комплексного покрытия синтезированной схемы методом пересечения всех кубов вырожденных покрытий подсхем и методом пересечения с ограничениями .  На основе комплексного кубического покрытия схемы был восстановлен граф переходов схемы и сделано заключение об изоморфизме графов и ,  следовательно ,  об их идентич - ности ,  что позволило сделать заключение о верификации моделей разного уровня .  Для моделей одного уровня абстракции предложен метод вери - фикации с использованием комплексных покрытий на основании операций  #  и ∩ кубов комплексного покрытия анализируемых схем .  Рассмотрим применение условий необходимости и достаточности при верификации схемных решений методом моделирования .  Пусть задана некоторая булева функция  f  своими покрытиями  C1( f ),  при  f  = 1,  и  C0( f )  при  f = 0,  которые построены произвольным методом ,  например по картам Карно .  Требуется верифицировать некоторое схемное решение для  f  в виде логической схемы  N (  с внешним выхо - дом  ZN ),  спроектированной ,  например ,  эвристическим способом в произвольном базисе с применением методов факторизации ,  деком - позиции или их сочетания .  Необходимым условием верификации является совпадение ре - акций схемы  N ZN =1 (ZN = 0)  для ∀  c  ∈  C1( f ) (  ∀  c  ∈  C0( f )).  Достаточным условием верификации является совпадение реак - ции схемы  ZN =0 (ZN = 1)  для ∀  c  ∈  C0( f ) (  ∀  c  ∈  C1( f ) ).  Таким образом необходимым и достаточным условиями вери - фикации схемы  N  является совпадение реакции схемы  ZN  со значе - 102  ниями булевой функции  f  для всех кубов  c  ∈  C1( f )  ∪  C0 ( f ).  Ком - плексное покрытие КР  = C1( f )  ∪  C0 ( f )  и есть метамодель схемы  N,  Верификацию схемы  N  можно осуществить и другим способом ,  от - личным от метода моделирования .  Построим метамодель схемы для значений выхода  ZN,  равных  0  и  1,  в виде комплексного покрытия КР  = C0(ZN )  ∪  C1( ZN ).  В этом случае требуется установить соответствие между покрытиями  C1( f )  ∪  C0 ( f )  и  C0(ZN )  ∪  C1( ZN),  которое может быть выполнено либо с использованием операции вычитания кубов покрытий  (#),  либо с по - мощью операции пересечения кубов покрытий  ( ∩ ).  При использова - нии операции вычитания для верификации схемы  N  необходимо ,  чтобы  C1( f ) # C1( ZN) =  ∅ ,  и достаточно ,  чтобы  C1( ZN) # C1( f ) =  ∅ .  Аналогично для покрытий  C0( f )  и  C0(ZN ).  Из этого следует ,  что при использовании операции вычитания достаточно иметь только один тип покрытий :  либо единичное  C1( f )  и  C1( ZN),  либо нулевое C0 ( f )  и  C0(ZN ).  Применение алгебро - топологических операций вычитания и пе - ресечения покрытий позволяет при сравнении множеств избежать точного соответствия элементов множеств между собой ,  поэтому  C1(  f ) # C1( ZN)  и  C1( ZN) # C1( f )  не соответствуют аналогам  ( не топо - логическим )  обычного вычитания множеств  (  А  \  В и В  \  А ).  Применив операции вычитания  ( # )  и пересечения  (  ∩  )  покр ы - тий при верификации объектов получим четыре возможных отноше - ния :  1. C1( f ) # C1( ZN) =  ∅ и  C1( ZN) # C1( f ) =  ∅ ,  или  C1( f )  ∩ C0(ZN ) =  ∅ и  C0( f )  ∩  C1( ZN) =  ∅  -  условия полной верификации .  2. C1( f ) # C1( ZN)  ≠ ∅ и  C1( ZN) # C1( f ) =  ∅ ,  или  C1( f )  ∩ C0(ZN )  ≠ ∅ и  C0( f )  ∩  C1( ZN) =  ∅  -  есть необходимое ,  но недоста - точное условие верификации .  3. C1( f ) # C1( ZN) =  ∅ и  C1( ZN) # C1( f )  ≠ ∅ ,  или  C1( f )  ∩ C0(ZN ) = ∅ и  C0( f )  ∩  C1( ZN)  ≠ ∅  -  есть достаточное ,  но не необхо - димое условие верификации .  4. C1( f ) # C1( ZN)  ≠ ∅ и  C1( ZN) # C1( f )  ≠ ∅ ,  или  C1( f )  ∩ C0(ZN )  ≠ ∅ и  C0( f )  ∩  C1( ZN)  ≠ ∅  -  условия верификации отсут - ствуют .  Во  2- ом и  3- ем случаях можно говорить о верификации частич - но определенных функций  ( объектов )  с использованием  « размытых »  множеств ,  иначе говоря ,  один объект  « делает »  больше ,  чем другой .  Полная верификация существует только при выполнении соотноше - 103  ний  1- го случая .  Данное рассуждение проведено для случая одновы - ходной схемы  N  и исходного покрытия булевой функции  f,  которое является простейшим случаем метамодели высшего ранга .  Аналогичные методы можно применить при верификации граф - схем алгоритмов ,  конечных автоматов  ( абстрактных и структурных ),  многовыходных последовательностных схем и ПО .  На рис . 29  один и тот же вычислительный процесс реализован двумя различными способами .  На схеме показано ,  что на основании технических заданий  ( ТЗ )  или разработанных программ ,  строятся ГАМ и комплексные покрытия двух рассматриваемых вычислитель - ных процессов .  Из них методом алгебро - топологического вычитания исключаются значения ,  на которых функция не определена  (don't  care),  и строятся контролирующие тесты .   Рис . 29.  Общая схема процесса верификации вычислительных процессов 104  Предложены два способа верификации этих процессов :   метод алгебро - топологического вычитания покрытий каждого из каждого .  При условии пустого значения результата делается за - ключение о эквивалентности данных вычислительных процессов ;   метод построения тестовых наборов по комплексным покры - тиям путем пересечения кубов из интервальных частей покрытий и перекрестное тестирование ,  по результатам которого делается заклю - чение о результатах верификации .  Рассмотрим пример верификации ациклического процесса .  Пусть задана некоторая интервальная формула :  реализующая вычисления некоторой переменной  r  по различным формулам : FR1, FR2  и  FR3  произвольного вида в зависимости от двух булевых переменных ,  задающих некоторые условия - предикаты в виде неравенств : a: x  ≤  k1  и  b: x  ≥  k2.  Переход от неравенств к булевым переменным при проектиро - вании вычислительного процесса позволяет абстрагироваться от кон - кретного смысла неравенств и им соответствующих условий - предикатов и рассмотреть решение задачи верификации в общем ви - де .  ГАМ вычисления переменной  r  приведены на рис . 30.  На рис . 30, а показана функциональная декомпозиция булевой функции  f  = f(a,b)  с начальной вершиной условия - предиката а  ( ГАМ  1),  а на рис . 30, б  –  с начальной вершиной  b ( ГАМ  2).  Построим комплексные кубические покрытия  C 1 (r)  и  C 2 (r)  для вычисляемой переменной  r  по ГАМ  1  и ГАМ  2:  105  а )         б )  Рис . 30.  ГАМ вычисления интервальной формулы По покрытиям  C 1 (r)  и  C 2 (r)  построим тесты Т 1 (r)  и Т 2 (r)  путем пересечения кубов из интервальных частей покрытий  C 1 (r)  и  C 2 (r),  соответственно .  Получим тесты :  106  Для формул должны выполняться условия : /FR1/  ≠  /FR2/ ≠  /FR3/  ≠  p,  т . е .  вычисляемые и хранимые значения должны различаться на разных наборах теста .  Штрихами в тестах отмечены значения актив - но изменяемых условий - предикатов .  С учетом удаления  ab=11  верификация по покрытиям дает  C 1  #   C  2  =  ∅ и  C 2 # C 1  =  ∅ ,  что и свидетельствует об эквивалентности вы - числительных процессов .  Это наглядно можно наблюдать на картах Карно приведенных на рис . 30.  Перекрестное тестирование дает следующий результат :  R 1 (T 1 )=R 2 (T 1 )  и  R 1 (T 2 )=R 2 (T 2 ),  что также подтверждает эквивалент - ность вычислительных процессов .  Если переменную  r  вычислять по разным упрощенным формулам  FR1, FR2  и  FR3,  тогда метод пере - крестного тестирования является предпочтительным ,  так как не тре - бует приведения выражений формул к каноническому виду .  Далее приводятся машинно - ориентированные алгоритмы реали - зации основных операций по вычислению комплексных кубических покрытий .  Алгоритм построения комплексного кубического покры - тия представлен на рис . 31.  107  Рис . 31.  Алгоритм построения комплексного кубического покрытия 3.3.  Совершенствования верификации симуляций между моделями программ Решается задача создания универсальной среды проверки симу - ляций между моделями программ ,  заданными конечными структура - ми Крипке .  Определение  2.1 .  Структура Крипке задаётся пятёркой ۦܵ ,  ݏ 0 , ܴ ,  ,  ܮۧ ,  где ܵ  –  конечное множество состояний ,  ݏ 0 ∈ ܵ  –  начальное 108  состояние ,  ܴ ⊆ ܵ × ܵ  –  отношение переходов ,    –  множество атомар - ных переменных ,  ܮ :  ܵ → 2 Σ  –  функция разметки состояний .  Для задания спецификаций поведения программ наиболее часто используется темпоральная логика ветвящегося времени ܥܶܮ *  и её фрагменты ܮܶܮ ,  ܣܥܶܮ *,  ܥܶܮ * ܺ и ܣܥܶܮ * ܺ .  Эти логики имеют различ - ные выразительные способности и области применения .  Так ,  ܥܶܮ *  и ܣܥܶܮ *  позволяют описывает свойства деревьев вычислений ,  а ܮܶܮ  —  свойства отдельных вычислений .  В логиках ܥܶܮ * ܺ ,  ܣܥܶܮ * ܺ и ܮܶܮ ܺ отсутствует оператор ܺ .  Данный оператор используется для задания свойств ,  которые должны выполняться в следующем состоянии вы - числения .  Поэтому он не применяется для описания свойств парал - лельных асинхронных систем ,  поскольку порядок выполненияпро - цессов в таких системах недетерменирован .  Бинарное отношение ⪯ на множестве структур Крипке сохраня - ет выполнимость формул логики  ,  если для любой формулы  ∈  и любых структур Крипке ܯ 1 и ܯ 2 таких ,  что ܯ 1 ⪯ ܯ 2 ,  из ܯ 2  |=   сле - дует ܯ 1  |=   .  Отношения симуляции  –  это специальная разновидность бинар - ных отношений на множестве моделей программ ;  говоря неформаль - но ,  модель ܯ 2 симулирует модель ܯ 1 ,  если дерево вычислений ,  по - рождённое моделью ܯ 1 ,  подобно некоторому фрагменту дерева вы - числений ,  порождённому моделью ܯ 2 .  Определяя по - разному подо - бие деревьев вычислений ,  можно получить большое разнообразие от - ношений симуляции  ( строгую симуляцию ,  прореженную симуляцию ,  ...).  Наибольший интерес представляют отношения симуляции ,  со - храняющие выполнимость формул различных темпоральных логик .  Определение  2.2  ( Строгая симуляция ).  Пусть даны две структу - ры Крипке ܯ 1 и ܯ 2 ,  где ܯ ݅  =  ۦܵ ݅ ,  ݏ ݅ 0 , ܴ ݅ ,  ݅ ,  ܮ ݅ ۧ ,  ݅  = 1, 2,  и  1  =   2 .  Будем говорить ,  что между ܯ 1 и ܯ 2 выполняется строгая симуляция  ( обо - значается ܯ 1 ⪯ ܯ 2 ),  если существует такое ܪ ⊆ ܵ 1  ×  ܵ 2 ,  что  ( ݏ 10 ,  ݏ 20 )  ∈ ܪ и для любой пары  ( ݏ 1 ,  ݏ 2 ) ∈ܪ выполняется :  1.  ܮ 1 ( ݏ 1 ) =  ܮ 2 ( ݏ 2 ).  2.  Если  ( ݏ 1 ,  ݏ ′ 1 )  ∈ ܴ 1 ,  то существует такое состояние ݏ ′ 2 ∈ ܵ 2 ,  что ( ݏ 2 ,  ݏ ′ 2 )  ∈ܴ 2 и  ( ݏ ′ 1 ,  ݏ ′ 2 )  ∈ ܪ .  Будем говорить ,  что между ܯ 1 и ܯ 2 выполняется строгая биси - муляция ,  если в определении  2.2 отношение ܪ является симметрич - ным  ( т .  е .  ܪ  =  ܪ −  1).  109  Определение прореженной симуляции отличается от определе - ния строгой симуляции тем ,  что каждому переходу  ( ݏ 1 ,  ݏ ′ 1 )  ∈ ܴ 1 мо - жет соответствовать последовательность переходов ݐ 0 ,  ݐ 1 , . . .  ݐ ݊  ( ݊ ≥ 0)  в ܴ 2 ,  такая ,  что ݐ 0 = ݏ 2 ,( ݏ ′ 1 , ݐ ݊ ) ∈ܪ и для всех ݅  <  ݊ выполняется  ( ݐ ݅ ,  ݐ ݅ +1 )  ∈ ܴ 2 и  ( ݏ 1 ,  ݐ ݅ )  ∈ ܪ .  Если добавить к этому определению требование симметрично - сти ,  то мы придём к определению прореженной бисимуляции .  Строгая симуляция сохраняет выполнимость формул ܣܥܶܮ *,  строгая бисимуляция  –  выполнимость формул ܥܶܮ *,  прореженная симуляция  —  выполнимость формул ܣܥܶܮ * ܺ ,  прореженная бисиму - ляция  —  выполнимость формул ܥܶܮ * ܺ .  Здесь преследуется цель разработки универсальной программ - ноинструментальной среды проверки симуляций .  Разрабатываемая среда должна состоять из двух компонент :  формального языка ,  поз - воляющего описывать различные симуляции ,  и программно - инструментального средства ,  которое по двум размеченным системам переходов и описанию симуляции проверяет ,  выполняется ли задан - ная симуляция между этими системами переходов .  В основу универсального средства описания и проверки симу - ляций целесообразно положить теоретико - игровой подход .  Этот под - ход годится для проверки всех известных отношений симуляции ,  и более того ,  во многих случаях его использование даёт оптимальные по сложности алгоритмы проверки симуляций .  В теоретико - игровом подходе задача проверки симуляции сво - дится к задаче нахождения выигрышной стратегии в антагонистиче - ской игре двух игроков  Spoiler  и  Duplicator ( или для краткости ܵ и ܦ ).  Формально такая игра задаётся пятёркой ۦܸ ܵ ,  ܸ ܦ , ܧ ܵ , ܧ ܦ ,  ݒ 0 ۧ ,  где ܸ ܵ и ܸ ܦ  –  множества состояний игроков  Spoiler  и  Duplicator  соответ - ственно , ܧ ܵ ⊆ܸ ܵ × ܸ ܦ и ܧ ܦ ⊆ ܸ ܦ × ܸ ܵ  –  множества допустимых ходов ,  ݒ 0 ∈ ܸ ܵ  –  начальное состояние .  История игры  –  это такая конечная или бесконечная последовательность игровых состояний  ( ݒ 0 ,  ݒ 1 ,  ݒ 2 , ...),  что  ( ݒ ݅ ,  ݒ ݅ +1 )  ∈ ܧ ܵ ∪ܧ ܦ для любого ݅ ≥  0. C тратегией игрока  Duplicator –  это функция ܹ  :  ܸ ܦ → ܸ ܵ ∪ { ݄݈ܽݐ }.  История игры  ( ݒ 0 ,  ݒ 1 ,  ݒ 2 , ...)  удовлетворяет стратегии ܹ игрока Duplicator,  если для любого состояния ݒ ݅ ∈ ܸ ܦ из истории игры ,  за ис - ключением ,  возможно ,  последнего ,  выполняется ݒ ݅ +1  =  ܹ ( ݒ ݅ ),  а для последнего состояния  ( если история игры конечна )  выполняется ܹ ( ݒ ݅ ) =  ݄݈ܽݐ .  Игрок  Duplicator  выигрывает в игре ,  если у него суще - ствует стратегия ,  для которой любая удовлетворяющая ей история 110  игры либо является бесконечной ,  либо завершается состоянием игро - ка  Spoiler.  Игры проверки симуляции проектируются таким образом ,  что выполнимость отношения симуляции равносильна существова - нию выигрышной стратегии игрока  Duplicator  в соответствующей иг - ре проверки симуляции .  Различные варианты игр для проверки многих отношений симу - ляции имеют много общего .  В них всегда участвуют два игрока и условия выигрыша совпадают  ( один игрок выигрывает ,  если другой игрок не может сделать ход ).  Игровые состояния представляются кортежами ,  компонентами которых являются компоненты моделей .  Множества допустимых ходов могут быть описаны булевыми форму - лами над фиксированной сигнатурой .  Это наблюдение было исполь - зовано для создания теоретико - игрового языка задания симуляций .  Определение некоторого отношения на этом языке представляет со - бой описание правил игры для проверки этого отношения и включает в себя описание устройства игровых состояний и правил ,  по которым игроки совершают свои ходы .  Самый простой вид имеет определение правил игры проверки строгой симуляции .  Предположим ,  что необходимо проверить симу - ляцию между ܯ 1 и ܯ 2 ,  где ܯ ݅  =  ۦܵ ݅ ,  ݏ ݅ 0 , ܴ ݅ , ݅ ,  ܮ ݅ ۧ .  Состояния игроков Spoiler  и  Duplicator  в этой игре представляются кортежами ,  состоя - щими из одного состояния из ܵ 1 и одного состояния из ܵ 2 ,  т .  е .  ܸ ܵ  =  ܸ ܦ = {( ݏ 1 ,  ݏ 2 )| ݏ 1 ∈ ܵ 1 ∧ݏ 2 ∈ ܵ 2 )}.  Если состояния игрока ܲ описывается па - рой значений типизированных переменных ݔ 1 ܲ и ݔ 2 ܲ  ( ݔ ݅ܲ принимает значения из ܵ ݅ ),  то допустимые переходы игроков описываются фор - мулами Поэтому множества ходов будут иметь следующий вид :  ܧ ܵ  = {(( ݏ 1 ,  ݏ 2 ), ( ݏ ′ 1 ,  ݏ 2 ))|( ݏ 1 ,  ݏ ′ 1 )  ∈ ܴ 1 }  и ܧ ܦ  = {(( ݏ 1 ,  ݏ 2 ), ( ݏ 1 ,  ݏ ′ 2 ))|( ݏ 1 ,  ݏ ′ 2 )  ∈ܴ 2 ∧ ܮ ( ݏ 1 ) =  ܮ ( ݏ ′ 2 )}.  Начальное игровое состояние полагается равным ݒ 0  =( ݏ 10 ,  ݏ 20 ).  Всего на разработанном языке были записаны правила проверки следующий отношений :  строгой симуляции и бисимуляции ,  проре - женной симуляции и бисимуляции ,  слабой симуляции  ( сохраняющей выполнимость формул ܮܶܮ ܺ ),  ݇ 2 симуляции  ( сохраняющей выполни - мость формул ܮܶܮ ).  В работе доказана корректность игр для проверки 111  прореженной симуляции и бисимуляции ,  корректность игр для про - верки остальных симуляций была доказана ранее в литературе .  Алгоритм проверки симуляций реализован по двум конечным структурам Крипке и по отношению симуляции ,  заданном на разра - ботанном языке ,  проверяет выполнимость этого отношения между этими моделями .  В алгоритме последовательно проводится построе - ние множества достижимых состояний игры ,  построение множества выигрышных для игрока  Spoiler  состояний и проверка начального со - стояния на принадлежность этому множеству .  Разработанный алго - ритм является символьным ,  т . е .  для повышения эффективности в нём проводятся операции над формулами ,  характеризующими множества ,  а не над отдельными элементами этих множеств .  Доказана коррект - ность приведённого алгоритма .  Разработано универсальное программно - инструментальное средство проверки симуляций между парами структур Крипке .  Дан - ное средство реализовано на языке  Python.  В качестве языка задания моделей используется язык широко используемого верификатора NuSMV.  Для представления формул в символьном алгоритме были использованы упорядоченные двоичные разрешающие диаграммы (OBDD).  В равной мере для символьного представления моделей и игры могут быть использованы и другие математические конструк - ции :  регулярные выражения ,  прямое формульное представление и др .  OBDD  были выбраны ввиду широкой распространённости библиотек для манипуляции с ними .  В качестве библиотеки работы с  OBDD  ис - пользуется библиотека  Cudd.  В инкрементальном методе последовательно строятся модели ܯ 1 , ...,  ܯ ݊ так ,  что каждая следующая модель является уточнением предыдущей модели и содержит больше подробностей о конструиру - емой программе .  Такой способ построения помогает избежать оши - бок при построении моделей .  Чтобы убедиться ,  что ܯ ݅ +1 уточняет ܯ ݅ ,  достаточно проверить ,  что между этими моделями выполняется неко - торое отношение симуляции  ( которое выбирается исходя из характе - ра отличий между ܯ ݅ +1 и ܯ ݅ ).  Если же это отношение симуляции не выполняется ,  то контрпример ,  выданный средством проверки симу - ляций ,  поможет найти ошибку в модели ܯ ݅ +1 .  Инкрементальный подход был применён для решения задачи справедливого разделения ресурсов в системе асинхронных взаимо - действующих процессов  ( задача  “ обедающих философов ”).  Всего были построены три модели .  В модели ܯ 1 не накладывалось никаких 112  ограничений на действия процессов  ( философов ).  В модели ܯ 2 появ - ляется маркер ;  каждый философ может получить маркер только когда вилки слева и справа от него лежат на столе .  После того ,  как философ получил маркер ,  он может взять вилки и начать есть ;  после того как он закончил есть ,  он освобождает маркер .  В окончательной модели ܯ 3 маркер движется строго по кругу ,  и каждый философ обязан за - кончить есть прежде ,  чем он передаст маркер своему соседу .  Исходя из характера отличий между моделями был сделан вы - вод о том ,  что между ܯ 2 и ܯ 1 должно выполнятся отношение строгой симуляции ,  а между ܯ 3 и ܯ 2  –  отношение прореженной симуляции .  Справедливость этих отношений была проверена при помощи разра - ботанного средства для систем с различным количеством обедающих философов .  Далее решается задача разработки алгоритма проверки симуля - ции между временными игровыми автоматами .  Будем использовать запись ࣜ ( ܺ )  для обозначения множества формул над множеством ܺ ,  удовлетворяющих грамматике ߶  ::=  ݔ ∼ ݇ |   ∧  ,  где ݇ ∈  Z ≥ 0,  ݔ∈ܺ и ∼ ∈ {<, ≤ ,=, >,  ≥ }.  Будем использовать запись ܺ ܻ для обозначения множества всех отображений из множества ܺ в множество ܻ  ( это расходится с традиционной записью ܻ ܺ ).  Оценка переменных из ܺ  –  это элемент  R ܺ ≥ 0.  Пусть ߜ ∈  R ≥ 0,  тогда будем обозначать ݒ  +  ߜ такую оценку ,  что для всех ݔ ∈ ܺ выполняется ( ݒ + ߜ )( ݔ ) =  ݒ ( ݔ )+ ߜ .  Пусть ܻ ⊆ ܺ ,  тогда будем использовать запись ݒ [ ܻ ]  для обозначения оценки ,  сопоставляющей  0  всем ݔ ∈ ܻ  ,  и ݒ ( ݔ )  всем ݔ∈ܺ∖ܻ  .  Определение  3.1 .  Временной автомат  (timed automata, TA) –  это шестёрка ۦܵ ,  ݏ 0 , ܺ ,  , ܴ , Inv ۧ ,  где ܵ  –  конечное множество дискретных состоянияй ,  ݏ 0 ∈ܵ  –  начальное дискретное состояние ,  ܺ  –  конечное множество вещественных переменных  ( таймеров ),    –  множество пометок переходов  ( действий ),  включающее в себя так называемое невидимое действие ߬ ,  ܴ⊆ܵ × ࣜ ( ܺ )×  × ℘ ( ܺ )× ܵ  –  конечное множество переходов  ( ℘ ( ܺ ) –  множество всех подмножеств ܺ ), Inv :  ܵ → ࣜ ( ܺ ) —  функция ,  сопоставляющая дискретным состояниям формулы  ( такие формулы называются инвариантами ).  Семантика временного автомата определяется размеченной си - стемой переходов  ( ܳ ,  ݍ 0, → ),  где ܳ  =  ܵ  × R ܺ ≥ 0,  ݍ 0 = ( ݏ 0 , Ԧ 0).  Из состоя - ния ݍ 1 существует дискретный переход по действию ܽ в состояние ݍ 2 ( обозначается  ),  если существует такой переход ݁  = ( ݏ ,  ݃ ,  ܽ ,  113  ܻ ,  ݏ ′ )  ∈ ܴ ,  что ݒ  |=  ݃ ,  ݒ ′  =  ݒ [ ܻ  ]  и ݒ ′  |= Inv( ݏ ′ ).  Из состояния ݍ 1  = ( ݏ ,  ݒ )  существует задержка по времени ߜ в состояние ݍ 2  = ( ݏ ,  ݒ ′ ) ( обознача - ется  ),  если ݒ ′  =  ݒ  +  ߜ и ݒ ′  |= Inv( ݏ ).  Для простоты будем полагать ,  что временные автоматы детер - менированы по действиям ,  т .  е .  для любой пары ݍ ∈ ܳ и ܽ ∈  суще - ствует не более одного такого ݍ ′ ,  что  .  Временной игровой ав - томат  (timed game automata, TGA) –  это временной автомат ,  в кото - ром множество действий  разбито на множество контролируемых (  ܿ )  и множество неконтролируемых  (  ݑ )  переходов .  Стратегия с ну - левой памятью контроллера  ( соответственно ,  среды ) –  это функция ݂ ,  определённая на множестве состояний ܳ ,  и возвращающая некоторый элемент множества  (R ≥ 0×  ܿ ) ( соответственно , (R ≥ 0 ×   ݑ )).  Определение  3.5 .  Пусть дан  TGA  ۦܵ ,  ݈ 0 ,  , ܺ , ܴ , Inv ۧ ,  и пусть  ( ߜ ܿ ,  ܽ ܿ )  и  ( ߜ ݑ ,  ܽ ݑ ) –  некоторые стратегии контроллера и среды соответ - ственно .  Вычисление будем называть порождённым этими стратегиями ,  если для лю - бого ݅∈ N  выполняется ߜ݅  = min( ߜ ܿ ( ݍ 2 ݅ ),  ߜ ݑ ( ݍ 2 ݅ ))  и :  Аналогично определяются понятие стратегии для недетермени - рованных по действиям временных игровых автоматов ,  в этом случае стратегия будет возвращать не пометки ,  а переходы .  Определена логика  ATCTL,  используемая для описания свойств временных игровых автоматов .  Эта логика состоит из формул вида ܣߪ 1 ܷ ݐ ߪ 2 и ܣߪ 1 ܹ ݐ ߪ 2 ,  где ݐ∈ Z ≥ 0  ∪  {+ ∞ },  а ߪ 1 и ߪ 2  –  некоторые множе - ства видимых действий .  Будем говорить ,  что вычисление ߨ времен - ного автомата ܯ удовлетворяет формуле ߪ 1 ܷ ݐ ߪ 2 ,  если существует та - кой префикс этого вычисления ߨ ′ ,  что все видимые действия ߨ ′ лежат в множестве ߪ 1 ,  последнее действие ߨ ′ лежит в ߪ 2 и длительность ߨ ′ не превышает ݐ .  Вычисление ߨ временного автомата ܯ удовлетворяет формуле ߪ 1 ܹ ݐ ߪ 2 ,  если это вычисление удовлетворяет формуле ߪ 1 ܷ ݐ ߪ 2 ,  или все видимые действия ߨ принадлежат множеству ߪ 1 .  Будем гово - рить ,  что формула ܣ  логики ܣܶܥܶܮ выполняется на  TGA  ܯ ,  если существует такая стратегия контроллера ݂ ܿ ,  что для любой стратегии 114  среды ݂ ݑ формула  выполняется на вычислении ,  порождённом стра - тегиями ݂ ܿ и ݂ ݑ .  Задача ,  которая решается в данной главе ,  заключается в опреде - лении отношения ⪯ ,  сохраняющего выполнимость формул логики ܣܶܥܶܮ ,  и разработке алгоритма проверки этого отношения .  На осно - вании обзора сделан вывод о том ,  что в качестве искомого отношения следует использовать  “ комбинацию ”  определений временной ,  игро - вой и ослабленной отношений симуляции ,  описанных ранее в литера - туре .  Определение  3.7  (twa- симуляция ).  Пусть даны два  TGA  ܯ 1 и ܯ 2 с множествами состояний ܳ 1 и ܳ 2 ,  где ܯ ݅  =  ۦܵ ݅ ,  ݏ ݅ 0 , ܺ ݅ ,  ݅ , ܴ ݅ , Inv ݅ ۧ .  Бу - дем говорить ,  что между ܯ 1 и ܯ 2 выполняется отношение слабой альтернирующей временной  (timed weak alternating, twa)  симуляции ,  если существует такое отношение ܪ ⊆ ܳ 1  × ܳ 2 ,  что пара начальных состояний  ( ݍ 10 ,  ݍ 20 )  находится в этом отношении и для любой пары ( ݍ 1 ,  ݍ 2 )  ∈ ܪ и для любых ݍ ′ 1 ∈ ܳ 1 ,  ݍ ′ 2 ∈ ܳ 2 ,  ߜ ∈  R ≥ 0, ܽ ∈  ∖ { ߬ }  выпол - няются следующие требования :  1.  Если  ,  то существует такое ݊ ≥ 1  и такая последова - тельность состояний автомата ܯ 1 ,  что ,   и при этом для всех ݅  =  2.. ݊ − 1  выполняется и  .  2.  Если  ,  то существует такое ݊ ≥ 1  и такая последова - тельность состояний автомата ܯ 2 ,  что ,   и при этом для всех ݅ =2.. ݊ − 1  выполняется  .  3.  Если  ,  то  ( ݍ 1 ,  ݍ ′ 2 )  ∈ ܪ .  4.  Если  ,  то  ( ݍ ′ 1 ,  ݍ 2 )  ∈ ܪ .  5.  Если  ,  то существует такое ݍ ′′ 1 ∈ ܳ 1 ,  что и ( ݍ ′′ 1 , ݍ ′ 2 ) ∈ܪ Ранее доказано ,  что введённое отношение  twa- симуляции сохра - няет выполнимость формул логики ܣܶܥܶܮ .  115  Разработан теоретико - игровой алгоритм проверки  twa- симуляции и доказана его корректность .  Поскольку в общем случае множество состояний временных автоматов бесконечно ,  то бесконеч - на и игра проверки симуляции .  Поэтому в разработанном алгоритме ведётся работа не над отдельными игровыми состояниями ,  а над формулами ,  описывающими потенциально бесконечные множества состояний .  Для операций над такими формулами используется аппа - рат матриц ограниченных разностей  (difference bounded matrixes).  Осуществлено экспериментальное исследование реализации разработанного алгоритма  twa- симуляции для решения задачи синте - за алгоритма работы контроллера в системе автоматического управ - ления .  Рассмотрим следующий пример .  Пусть имеется движущийся конвейер ,  на который ставится изделие .  Затем изделие движется по конвейеру и последовательно проходит ܰ этапов обработки ,  каждый этап занимает от  1  до  2  единиц времени .  Задача контроллера  –  после завершения последнего этапа переместить готовое изделие с конвей - ера в коробку .  Если этого не произойдёт в течение  2 ܰ  +2  единиц вре - мени с начала работы конвейера ,  то изделие будет потеряно ,  и ,  таким образом ,  задача контроллера не будет выполнена .  Данная система описывается  TGA S,  изображённом на рис . 32  слева .  Сплошными ду - гами обозначены контролируемые переходы ,  а прерывистыми  –  не - контролируемые .  Рис . 32.  Временные автоматы ,  на которых проводилось экспериментальное исследование разработанного алгоритма Задача контроллера в автомате  S –  перевести автомат в дискрет - ное состояние ܹ݅݊ ,  т .  е .  обеспечить выполнимость формулы 116  ܣ { ݊݁ݔݐ } ܷ { ݇݅ܿ݇ }.  Одна из возможных выигрышных стратегий кон - троллера ݂ ܿ  –  подождать ,  пока автомат перейдёт в дискретное состоя - ние ܴ݁ܽ݀ݕ ,  а затем выполнить переход в состояние ܹ݅݊ .  Предполо - жим теперь ,  что в реальной ситуации контроллеру неизвестно теку - щее положение изделие на конвейере .  Тогда стратегия ݂ ܿ не может использоваться в моделируемой  ( реальной )  ситуации .  Поэтому была построена другая модель  A,  изображённая на рис .  13  справа .  Эта модель уже не содержит невидимую контроллеру ин - формацию ,  и для неё у контроллера существует выигрышная страте - гия  ( её можно автоматически построить при помощи средства UPPAAL Tiga).  Для того ,  чтобы проверить ,  что та же стратегия будет выигрышной и для исходной модели ,  достаточно проверить суще - ствование  twa- симуляции между  S  и  A.  Корректность такого сведения была доказана в теореме .  Существование  twa- симуляции между  S  и  A  было проверено для нескольких значений ܰ .  Взаимное исключение с помощью мьютекса .  Мьютекс  ( одно - местный семафор )  является одним из наиболее часто используемых на практике примитивов синхронизации ,  позволяющим обеспечивать монопольный доступ клиентов к разделяемому ресурсу .  Приводится представленное ниже описание модели мьютекса на языке  Promela.  Пусть требуется проверить ,  позволяет ли данная структура га - рантировать каждому клиенту доступ к разделяемому ресурсу .  Более формально :  необходимо установить выполнимость свойства  « каждый клиент рано или поздно получит доступ к ресурсу ,  защищенному мьютексом ».  117  Предложенная задача может быть решена в ИС  SPIN  путем про - верки достижимости циклов без прогресса .  Для верификации исполь - зовалась следующая последовательность команд .  Результат верификации представлен на рис . 33.  Рис . 33.  Результат верификации в ИТС  SPIN  По описанию на языке  Promela  была построена эквивалентная структура Крипке ,  изображенная на рис . 34.  Атомарным предикатом a отмечено состояние ,  в котором доступ к ресурсу получает третий процесс .  Желаемое поведение описывается  LTL- формулой Fa  ( когда - нибудь в будущем третий клиентский процесс обязательно получит доступ к ресурсу ).  Невыполнение спецификации будет означать ,  что существует как минимум одна последовательность состояний ,  на ко - торой требуемое событие не происходит .  И если такая траектория существует ,  то ,  следовательно ,  и существуют аналогичные траекто - рии ,  на которых доступ к ресурсу не получают первый и второй про - цессы .  118  Рис . 34.  Эквивалентная описанию структура Крипке Сформированная на основе структуры Крипке и спецификации база знаний подавалась на вход программной реализации МЛВ .  По - лученные результаты представлены на рис . 35.  Применение как ИС  SPIN,  так и предлагаемого в работе подхода показали несоответствие модели и спецификации .  Таким образом ,  может быть сделан вывод о том ,  что исследуемая реализация мьютек - са не позволяет гарантировать клиентам доступ к ресурсу .  Для устра - нения ошибки необходимо ввести дополнительную  FIFO- подобную структуру для размещения запросов от клиентских процессов .  Алгоритм работы сетевого генератора данных .  Используется модель алгоритма ,  циклически генерирующего через фиксированный временной промежуток сообщение одного из двух возможных типов и отправляющего данное сообщение получателю через буферизиро - ванный канал .  119  Рис . 35.  Результат верификации с помощью МЛВ Описание модели на языке  Promela  представлено ниже .  Нежелательным поведением генератора является ситуация ,  при которой канал оказывается заполнен сообщениями первого типа .  То есть ,  корректное поведение предполагает ,  что рано или поздно гене - ратор отправит сообщение второго типа ,  а переменная  x  примет ис - тинное значение .  Для верификации в ИС  SPIN  применялась следую - щая последовательность команд .  120  Результат верификации представлен на рис . 36.  Рис . 36.  Результат верификации в ИТС  SPIN  Эквивалентная описанию на языке  Promela  структура Крипке изображена на рис . 37.  Как и в предыдущем примере ,  корректное поведение описывает - ся  LTL- формулой Fx .  Сформированная на основе структуры Крипке и спецификации база знаний подавалась на вход программной реализа - ции МЛВ .  Полученные результаты представлены на рис . 38.  ИТС  SPIN  и предлагаемый логический подход показали ,  что мо - дель не соответствует спецификации .  121  Рис . 37.  Эквивалентная описанию структура Крипке Рис . 38.  Результат верификации с помощью МЛВ 122  Алгоритм планирования  sleep-wakeup .  В работе рассматрива - ются реализации нескольких процедур ядра распределенной опера - ционной системы  UTS.  Предложено представленное ниже описание модели алгоритма работы планировщика этой операционной систе - мы .  123  Одним из основных требований ,  предъявляемых к планировщи - ку ,  является недостижимость ситуации голодания ,  при которой кли - ентский процесс всегда будет находиться в состоянии Wakeme .  Для верификации в ИС  SPIN  применялась следующая последовательность команд ,  рис . 39.  Рис . 39.  Результат верификации в ИС  SPIN  По описанию алгоритмов работы процессов Client и Server были построены изображенные на рис . 40  структуры Крипке .  Атомарным предикатом  a  отмечены состояния клиентского процесса ,  в которых выполняется условие  State == Wakeme.  124  Рис . 40.  Эквивалентные процессам структуры Крипке Модель ,  соответствующая исследуемому алгоритму планирова - ния ,  была сформирована путем построения асинхронной композиции представленных структур и последующего исключения недостижи - мых состояний .  Граф полученной структуры Крипке содержит  83  вершины .  Предъявляемое требование может быть выражено с помощью LTL- формулы GF  a  ( для каждого состояния модели всегда в буду - щем будет достижимо состояние ,  в котором клиентский процесс функционирует ).  На рис . 41  представлены результаты верификации алгоритма с помощью МВОЭ .  125  Рис . 41.  Верификация с помощью МЛВ Результаты ,  полученные в ИС  SPIN  и в программной реализации МЛВ ,  совпали с точностью до контрпримера .  Исследуемый алгоритм не отвечает предъявляемому требованию  –  возможна ситуация ,  при которой клиентский процесс перейдет в состояние  Wakeme  и не вый - дет из этого состояния в дальнейшем .  Для устранения ошибки необ - ходимо обеспечить атомарное выполнение смены состояния клиент - ского процесса и установки флага запроса на пробуждение .  126  4.  АВТОМАТИЧЕСКИЙ АНАЛИЗ БЕЗОПАСНОСТИ ПЛАТЕЖНЫХ ПРОТОКОЛОВ 4.1.  Протоколы бесконтактных платежей по банковским картам В последние годы бесконтактные банковские карты получили в мире широкое распространение .  По оценкам Всемирного банка ,  к концу  2020  года было задействовано около  900  миллионов бескон - тактных кредитных карт и  1300000  бесконтактных считывающих устройств .  Однако не все платежные протоколы ,  используемые этими банковскими картами ,  являются безопасными .  В независимом иссле - довании  [54]  был изучен набор из  20  бесконтактных банковских карт от нескольких платежных организаций и  111  крупных банков - эмитентов в США .  Исследование обнаружило уязвимости безопасно - сти разной степени во всех  20  картах .  Эксперимент Хейдта - Бенджамина и др . [43]  проводился со счи - тывающими устройствами банковских карт от двух независимых производителей .  Бесконтактные карты связываются со считывающи - ми устройствами через транспортный уровень  IS014443-B [58].  Элек - тронные данные карты были захвачены ,  и сообщения ,  передаваемые между картой и считывателем ,  были получены из последовательного порта считывателей .  Затем выходные данные были визуализированы в формате магнитной полосы  IS07813 [59],  а протоколы оплаты ,  ис - пользуемые банковскими картами ,  были преобразованы в обратную инженерию .  На основании полученных данных протоколы ,  используемые  20  банковскими картами ,  были разделены на четыре категории .  Далее формально смоделируем два из них и покажем выполнение этих двух протоколов и их атак .  Протокол оплаты банковской картой запускается ,  когда бескон - тактная банковская карта касается считывающего устройства .  Считы - ватель пересылает информацию о карте и строку описания транзак - ции  M  на внутренний сервер ,  который затем проверяет согласован - ность информации и ,  если он удовлетворен ,  сообщает шлюзу биллин - га .  Поскольку считыватель и внутренний сервер часто совместно ис - пользуют безопасный канал связи ,  такой как  TLS [57],  а считыватель просто пересылает полученную информацию ,  то опустим явное мо - 127  делирование считывателя .  Вместо этого предполагаем ,  что бескон - тактная банковская карта напрямую взаимодействует с платежным сервером с M как часть передачи сообщения .  Принимая это упроще - ние ,  теперь предоставляем высокоуровневые описания двух протоко - лов бесконтактных платежей ,  типа A и типа B ,  из  [54].  I.  Протокол карты A :  этот тип карты всегда отправляет считы - вающему устройству набор статической информации ,  которая содер - жит его основной номер счета  (PAN),  имя держателя карты и дату ис - течения срока действия .  Пример последовательного вывода коммер - ческого считывателя с этим типом карты :  Bxxxxxx7532xxxxxx^Erok/Victor ^2106101000000000000000000000000000858000000  xxxxxx7532xxxxxx=21061010000085800000  Первая строка  –  это сообщение ,  содержащееся на основной па - мяти карты ;  вторая строка содержит почти ту же информацию и представляет собой вторую запись в дополнительной памяти карты .  Здесь  «xxxxxx7532xxxxxx» –  это номер  PAN, « Erok/Victor » –  имя держателя карты ,  а  «2106» –  срок действия .  Пусть данные владельца карты  ( ДВК )  будет термином ,  который представляет собой комбина - цию  PAN,  имени держателя карты и даты истечения срока действия .  Предполагаем ,  что оставшаяся строка является подписью банка - эмитента над всеми данными держателя карты .  Делаем упрощающее предположение ,  что платежный сервер Se отвечает за выпуск банков - ских карт .  У Se имеется открытый и закрытый ключи  { k se.open ,  k se.lock }.  Формализация нашего сообщения следующее :  M . ДВК . r v (  ( ДВК ),  Se ),  где r v –  симметричное шифрование ;   ( ДВК ) –  краткое сообщение на основе хеширования .  Короткое сообщения :   ( ДВК ).  Пусть переменная ДВК представ - ляет сообщение .  Определите функцию  ( ДВК )  как короткое сообще - ния ДВК ,  вычисленный с использованием криптографической хэш - функции  [55, 56].  Предполагаем ,  что платежный терминал использует идеальное хеширование :  1.  Если  ( ДВК 1  ДВК 2 ),  тогда  (  ( ДВК 1 )    ( ДВК 2 )).  2.  Учитывая  ( ДВК ),  невозможно восстановить ДВК ,  128  3.   Пусть f  –  любая функция ,  тогда ,  если  ( ДВК  f  ( ДВК )),  тогда (  ( ДВК )    (  f  ( ДВК ))).  M . ДВК . r v (  ( ДВК ),  Se )  представляет собой объединение простого текста ДВК и подписи его хеша .  Поскольку ДВК передается в откры - том виде ,  этот протокол явно подвержен атаке с перехватом .  Более того ,  у этого типа карт нет компонента изменчивости  –  он всегда от - правляет одну и ту же строку при общении со считывателем .  Следо - вательно ,  он также подвержен атаке повторного воспроизведения .  Наконец ,  M не подписан ,  поэтому протокол уязвим для атак выреза - ния и вставки .  II.  Протокол карты B :  Этот тип карты по - прежнему отправляет данные владельца кар - ты  ( ДВК )  в открытом виде .  Тем не менее ,  он значительно повысил свою безопасность ,  сохраняя значение счетчика ,  которое монотонно увеличивается при каждом нажатии .  Пример последовательного вы - вода для этого типа карты при обмене данными со считывателем :  Bxxxxxx3272xxxxxx^ Erok/Victor ^2106101100000000000100000000000  xxxxxx3272xxxxxx=210610110000 018 0043 1  В этом примере выходных данных  « 0043 » –  это значение счет - чика ,  которое увеличивается при каждой банковской транзакции .  Это обеспечивает изменчивость каждого сообщения о транзакции .  Три предшествующие цифры  « 018 »  изменяются при каждой транзакции ( пин код ,  получаемый от банка ),  и предполагается ,  что они являются подписью над ДВК и значением счетчика .  В этом случае предполага - ем ,  что платежный сервер сохраняет сопоставление каждого ДВК с его последним значением счетчика ,  которое видел сервер .  Более того ,  платежный сервер использует уникальный симметричный ключ  k  с каждой картой ,  которая идентифицируется ДВК .  Формализованное сообщение :  M . ДВК .  C  . w ( ДВК .  C  ,  k )  где  C   –  конкретное значение счетчика ,  а w ( ДВК .  C  ,  k ) –  код аутенти - фикации сообщений на основе хеша через ДВК .  C  с использованием ключа k .  Поскольку протокол карты A всегда отправляет одно и то же статическое сообщение ,  он уязвим для атак повторного воспроизве - 129  дения .  Один из шагов ,  предпринимаемых платежным сервером после получения сообщения от бесконтактной карты и специфической для транзакции полезной нагрузки M , –  это проверка этой информации на актуальность и согласованность .  В этом протоколе имеется три прин - ципала :  банковская карта  ( Bc ),  платежный сервер  ( Se )  и биллинговый шлюз  ( Bi ),  который обрабатывает транзакции для выставления сче - тов .  Предполагаем ,  что канал между Se и Bi безопасен ,  и тем самым опускаем моделирование бесконтактного считывателя ,  поскольку он только добавляет информацию описания транзакции M и отправляет все на платежный сервер .  Диаграмма последовательности  UML  про - токола карты типа A представлена на рис . 42.  Рис . 42. Схема последовательности  UML  для протокола бесконтактных платежей типа  A  Первоначальные предположения  -  это признание того ,  что Se имеет собственные открытые и закрытые ключи .  Se моделируются в виде двух формул :  Se   ( Se ,  k se.open );  Se   ( Se ,  k se.lock ),  где  ( Se ,  k se.open ) –  k se.open является открытым ключом Se ;   ( Se ,  k se.lock ) –  k se.lock является закрытым ключом  Se .  Набор предварительных условий  –  это набор целей безопасности ,  которые ,  как ожидается ,  будут достигнуты перед каждым этапом обмена сообщениями .  Приведем возможный список целей и кратко обсудим ,  как их можно формализовать .  Рассмотрим совокупность предварительных условий ,  которые Se устанавливает перед взаимодействием с биллинговым шлюзом Bi .  Предположим ,  Se получил M . ДВК . r v (  ( ДВК ),  Se ).  Прежде чем Se отправит сообщение на сервер биллинга ,  необходимо выполнить ряд требований безопасности .  130  1 а .  Se должен полагать ,  что ДВК представляет собой информацию о карте ,  выпущенной Se .  Мы моделируем это ,  заявляя ,  что Se однажды изготовил ДВК :  Se   G  ( ДВК ,  Se ),  где G  ( ДВК ,  Se ) –  Se один раз произнес  ( изготовил )  ДВК .  2 а .  Se необходимо убедиться ,  что ДВК не поврежден ,  поскольку он был изготовлен Se .  Именно этот ДВК изготовил Se :  Se   ( ДВК ,  Se ),  где   –  целостность сообщения .  3 а .  Se необходимо убедиться ,  что транзакция  M. ДВК должна была быть совершена Bc .  Сделка ,  представленная приобретенными товарами M и финансовым инструментом ,  используемым для оплаты ДВК ,  была инициирована Bc ,  а не каким - либо другим принципалом :   Se   G ( M . ДВК ,  Bc ).  То есть M . ДВК произнес Bc .  4 а .  Запрашивается именно эта транзакция  M. ДВК ,  а не какой - либо другой M . ДВК  :  Se   ( M . ДВК ,  Bc ).  5 а .  Se необходимо убедиться ,  что запрос транзакции был последним .  Se должен быть в состоянии исключить любую атаку повторного воспроизведения ,  в которой старый запрос транзакции был записан в атаке подслушивания и повторно отображен здесь .  Формализуем это требование как следующее убеждение Se :  Se   #( M . ДВК ),  где  # –  изменение  (#( M . ДВК ) –  изменение M . ДВК ).  131  Здесь для простоты опускаем постусловия ,  которые обычно включают требования к оплате ,  такие как неотказ от авторства .  Протокол бесконтактных платежей типа A ,  представленный на рис . 42,  позволяет надежно реализовать только первый и второй пункты безопасности  ( смотри выше : 1 а , 2 а ).  Третий ,  четвертый и пятый пункты безопасности  (3 а , 4 а , 5 а )  не могут быть надежно реализованы по протоколу А .  В частности ,  третий  (3 а )  не выполняется ,  потому что сообщение M . ДВК не было подписано Bc ;  четвертый  (4 а )  не работает по той же причине ;  и пятый  (5 а )  не функционирует ,  потому что в M . ДВК нет компонента изменчивости .  Протокол для банковской карты типа B использует счетчик  C  и симметричное шифрование ,  а также код аутентификации сообщений на основе хеша .  Предполагаем ,  что Se знает последнее значение счетчика ,  связанного с данной банковской картой .  Диаграмма последовательности  UML  этого протокола представлена на рис . 43:  Рис . 43.  Схема последовательности  UML  для протокола бесконтактных платежей типа  B  Предположим ,  что Bc имеет общий симметричный ключ k с Se .  Ключ k уникален для Bc и Se ,  и ни Bc ,  ни Se не используют тот же k для других приложений .  Более того ,  Se знает ,  является ли значение счетчика  C  ,  отправленное Bc ,  новым ,  поскольку Se отслеживает последнее значение счетчика Bc .  Наконец ,  Se считает ,  что он никогда не создавал код аутентификации сообщений на основе хеша w ( ДВК .  C  ,  k ),  поэтому Bc не может его воспроизвести .  Только Se и Bc ,  которые являются единственными принципалами ,  обладающими k ,  могут построить этот код аутентификации сообщений на основе хеша .  Se считает ,  что ключи надежно хранятся и извлекаются на всех картах .  Только протокол ,  работающий на Bc ,  может иметь доступ к k в соответствии с конструкцией аппаратной защиты .  Следовательно ,  если Se считает ,  что он никогда не раскрывал w ( ДВК .  C  ,  k ),  тогда Se знает ,  что код аутентификации сообщений на 132  основе хеша является непередаваемым доказательством аутентификации Bc  ( он должен быть сгенерирован Bc ).  Таким образом ,  нам потребуется следующий набор исходных предположений :  1.  Предположение утверждает ,  что Bc знает симметричный ключ :  Bc  y K ( k ,   Bc ,  Se ),  где y K ( k ,   Bc ,  Se ) –  симметричный ключ k между Bc и Se. 2.  Предположение утверждает ,  что Se знает симметричный ключ :  Se  y K ( k ,   Bc ,  Se ).  3.  Предположение утверждает ,  что Se знает ,  что  C  изменился Se  #(  C  ).  4.  Предположение утверждает ,  что Se никогда не генерировал код аутентификации сообщений на основе хеша .  Se   G  lock  ( w ( ДВК .  C  ,   k ),   Se ),  где  G  lock  ( w ( ДВК .  C  ,   k ),   Se ) –  Se никогда не генерировал w ( ДВК .  C  ,   k ).  Теперь перечислим возможный набор предварительных и дополнительных условий .  Нам не нужны предварительные условия для сообщения номер один от Bc до Se на рис . 43.  Набор предварительных условий указан для второго сообщения ,  прежде чем Se сообщит Bi :  1 б .  Se необходимо сделать вывод ,  что информация о банковской карте ДВК .  C  отправляется Bc ,  а не какой - либо другой банковской картой Bc' .  Это требование моделируется следующим образом :  Se   G  ( ДВК .  C  ,   Bc ).  2 б .  Se необходимо получить уверенность в том ,  что ДВК .  C  не поврежден ,  поскольку Bc произнес  ( сгенерировал )  его :  133  Se   ( ДВК .  C  ,  Bc ).  3 б .  Se необходимо убедиться ,  что M . ДВК .  C  изменился :  Se   #( M . ДВК .  C  ).  4 б .  Se необходимо убедиться ,  что именно Bc запросил транзакцию M . ДВК .  C  :  Se   G  ( M . ДВК .  C  ,   Bc ).  5 б .  Se необходимо убедиться ,  что запрос транзакции M . ДВК .  C  не поврежден ,  поскольку он был передан Bc :  Se   ( M . ДВК .  C  ,   Bc ).  6 б .  Укажем одно постусловие неотказуемости .  То есть Se считает ,  что может доказать ,  что транзакция  ( включая описание товаров ,  дату ,  дату и платежный инструмент )  была запрошена Bc .  Это утверждение моделируется в виде :  Se   ( Se ,   G  ( M . ДВК .  C  ,   Bc )).  При программной реализации этой спецификации протокола были получены следующие результаты .  Первое ,  второе и третье предварительные условия  ( смотри выше : 1 б , 2 б , 3 б )  были подтверждены .  Они имеются ,  Se считает ,  что Bc сказал ДВК .  C  ;  Se верит в целостность ДВК .  C  ;  и Se считает ,  что ДВК .C  изменился .  Однако протокол не смог надежно отработать четвертое и пятое условие  (4 б , 5 б ).  Это означает ,  что намерение Bc послать M не может быть доказано .  M не подписано Bc .  Заключаем ,  что этот протокол не является корректным в отношении указанных исходных предположений ,  предварительных и постусловий .  Обратите внимание ,  что не проверятся постусловие  6 б .  Это связано с тем ,  что отказов любых предварительных условий достаточно ,  чтобы сделать протокол - кандидат недействительным .  Упростим условие моделирования ,  отбросим два предварительных условия  4 б и  5 б ,  а также постусловие  6 б .  Сравниваем исходную спецификацию протокола с этим набором 134  смягченных предварительных и постусловий и обнаруживаем ,  что теперь это корректно для функционирования банковских карт .  Теперь перейдем к этому набору упрощенных предварительных и постусловий .  Исходный протокол для карты типа B состоит из двух передач сообщений :  Bc  Se : M . ДВК .  C  . w ( ДВК .  C  ,   k );  Se  Bi : M . ДВК ,  где   –  заслуживает доверие .  Поскольку предполагается ,  что вторая передача осуществляется по защищенному каналу ,  сосредоточимся на атаке ,  которая изменяет первую передачу .  Используя стратегию модификации ,  можем заменить M . ДВК .  C  . w ( ДВК .  C  ,  k )  на путь ,  который начинается с Bc и заканчивается в Se через принципала - нарушителя Н *  модели злоумышленника  Dolev-Yao.  Конкретно ,  если позволим Н *  быть злоумышленником модели  Dolev-Yao,  первая передача может быть заменена следующим путем :  Bc  Н *: M . ДВК .  C  . w ( ДВК .  C  ,   k ),  где Н *   Se : M . ДВК .  C  . w ( ДВК .  C  ,   k ).  Такой путь можно рассматривать как атаку с подслушиванием ,  которая незаметно прослушивает канал связи между Bc и Se .  Поскольку нет никаких модификаций содержимого сообщения ,  т . е .  никакие существующие предварительные условия или постусловия не изменяются .  Однако для передачи сообщения добавляется пустой набор предварительных условий  ( Н *   Se : M . ДВК .  C  . w ( ДВК .  C  ,   k )).  Набор предварительных условий для передачи сообщения ( Bc  Н *: M . ДВК .  C  . w ( ДВК .  C  ,  k ))  остается пустым набором ,  а предварительные условия для  ( Se  Bi : M . ДВК )  состоят из : 1 б , 2 б и 3 б .  Утверждение злоумышленника ,  которое моделируется ,  касается секретности информации о банковской карте ДВК .  Поскольку 135  передачи между бесконтактными банковскими картами и считывателями транслируются ,  их может прочитать любой ,  кто их подслушивает .  В этом случае необходимо ,  чтобы злоумышленник - перехватчик Н *  не мог получить финансовую информацию ДВК в открытом виде .  Формально такое утверждение злоумышленника имеет вид :   Н *    ( Н *,  ДВК ),  где   –  отрицание ;   ( Н *,  ДВК ) –  Н *  может восстановить ДВК .  То есть злоумышленник Н *  не верит ,  что может реконструировать ДВК .  При программной реализации этой спецификации протокола протокол успешно отработал до конца .  В этом протоколе атаки не было постусловия для проверки .  Однако было обнаружено ,  что утверждение злоумышленника неверно .  Наша программная реализация правильно вычислила Н *    ( Н *,  ДВК )  как действительную формулу .  То есть злоумышленник Н *  действительно может реконструировать ДВК ,  потому что ДВК был отправлен в открытом виде от Bc до Se .  Заключаем ,  что исходный протокол неверен при столкновении с этой специфической атакой секретности .  Вывод .  Выявили ряд недостатков в вышеописанных протоколах .  В частности ,  протоколу типа A не удалось убедить Se в том ,  что транзакция была недавно инициирована Bc и содержимое транзакции было повреждено .  Протокол типа B не смог учесть намерение Bc провести транзакцию для определенного M .  Протокол уязвим для атаки методом  « вырезать и вставить »  на M и нарушает требование секретности данных ДВК держателя банковской карты .  EMV [47, 48] –  ведущий стандарт оплаты ,  администрируемый EMVCo (http://www.emvco.com). EMV  не является спецификацией для одного протокола .  Он состоит из нескольких легко настраиваемых модулей ,  предназначенных для различных компонентов платежных протоколов .  Далее формализуем аутентификационную часть протокола  EMV  и проведем его анализ .  Протокол аутентификации ,  используемый в  EMV,  можно смоделировать с использованием двух принципалов :  считывателя Re и банковской карты Bc .  Мы предполагаем ,  что все банковские карты выпущены доверенным третьим принципалом N .  Принципал N имеет пару открытого и закрытого ключей  { k N.open ,  k N.lock }.  Закрытый ключ 136  k N.lock принципала N хранится в секрете ,  а открытый ключ k N.open известен всем считывающим устройствам .  Предполагаем ,  что каждая банковская карта надежно хранит свои личные ключи k Bc.lock .  На этапе инициализации Bc и Re обмениваются последовательностью сообщений подтверждения для настройки протокола  ( эти шаги не моделируем ).  В конце инициализации Bc отправляет свой ДВК ,  включая дату истечения срока , PAN  и некоторую вспомогательную информацию ,  такую как список объектов данных управления рисками карты  (Card Risk Management  Data Object List, CDOL),  в Re .  Теперь протокол  EMV  готов к аутентификации карты .  Цель аутентификации  –  проверить целостность ДВК и проверить ,  действительно ли он исходит от заявленного Bc .  Спецификация  EMV  предоставляет три типа методов аутентификации :  статическая аутентификация данных  ( САД ),  динамическая аутентификация данных  ( ДАД )  и комбинированная аутентификация данных  ( КАД ).  КАД похож на ДАД ,  но с дополнительной транзакционной информацией ,  включенной в сообщения аутентификации .  Далее проведем формализацию протокола аутентификации САД и ДАД ,  а затем выполним их анализ .  В САД карта возвращает подпись хеш - кода ДВК ,  подписанную эмитентом карты N .  Эта подпись была предварительно вычислена во время производства и хранится на карте .  Протокол аутентификации САД можно формализовать как передачу следующего сообщения :  Bc  Re : ДВК . r v (  ( ДВК ),  N ).  Первоначальные предположения  –  это создание ключей до аутентификации .  Формально имеем :  1.  Принципал N считает ,  что ему принадлежит открытый ключ k N.open :  N   ( N ,  k N.open ).  2.  Принципал N считает ,  что ему принадлежит закрытый ключ k N.lock :  N   ( N ,  k N.lock ).  137  3.  Re считает открытый ключ k N.open принадлежит N :  Re   ( N ,  k N.open ).  4.  Re считает ,  что N заслуживает доверия :  Re  N   trustworthy.  Bc не предъявляет никаких предварительных условий перед отправкой этого сообщения .  Таким образом ,  предварительным условием для САД является пустой набор .  Набор требуемых Re постусловий формализуется следующим образом :  1 в .  Re считает ,  что ДВК был выпущен N :  Re   G  ( ДВК ,  N ).  2 в .  Re верит в целостность ДВК от N .  Именно ДВК выдал N :  Re  ( ДВК ,  N ).  3 в .  Re считает ,  что этот запрос на транзакцию отправил Bc :  Re   G  ( ДВК ,  Bc ).  4 в .  Re считает ,  что ДВК был недавно отправлен Bc и не является повтором .  Моделируя это требование ,  утверждаем Re  #( ДВК ).  5 в .  Re считает целостность ДВК от Bc :  Re  ( ДВК ,  Bc ).  Выполнив программную реализацию этой спецификации протокола ,  обнаружили ,  что последние три постусловия  3 в , 4 в и  5 в недействительны .  Использование САД оставляет злоумышленникам возможность воспроизвести некоторые r v (  ( ДВК ),  N )  в Re .  Re может проверить ,  действительно ли ДВК был выдан N .  Однако Re не может 138  доказать ,  что это был конкретный Bc ,  который недавно отправил ДВК ,  или что ДВК не поврежден ,  поскольку он был отправлен этим Bc .  Заключаем ,  что аутентификация САД не является корректной в отношении указанного набора исходных предположений ,  предварительных и последующих условий .  Обратите внимание ,  что EMV  понимает эти ограничения и рекомендует использовать САД только в условиях ограниченного и низкого риска .  Некоторые ограничения САД устраняются ДАД .  В ДАД аутентификация карты осуществляется случайным вызовом и применением цифровой подписи .  Карта также может аутентифицировать считыватель ;  мы не будем это моделировать .  Bc сначала отправляет ДВК и его сертификат Re .  Сертификат не является стандартным сертификатом  X.509 [53].  Сертификат может быть оформлен в виде подписи с отметкой времени истечения срока действия ,  открытого ключа Bc и хеша ДВК ,  подписанного N  закрытым ключом k N.lock :  Bc  Re : ДВК . r v (  *( T exp ).  ( Bc ,   k Bc . open ).  ( ДВК ),  N ),  где  *–  отметка времени истечения срока .  Далее Re отправляет объект данных динамической аутентификации данных  (Dynamic Data Authentication Data Object,  DDOL)  в Bc . DDOL  содержит сгенерированный считывателем одноразовый номер N Re ,  который ,  как известно Re ,  является измененным ,  и дополнительно содержит некоторую информация ,  которую мы не будем моделировать .  Re  Bc :  ( N Re ),  где   –  в данное время  ( в режиме реального времени ).  Получив N Re ,  Bc создает объект динамических данных  ICC  (ICCDDO, ICC Dynamic Data Object),  который состоит из только что сгенерированного одноразового номера N Bc .  Затем Bc возвращает свою подпись над  ICCDDO  и хеш - значениями  ICCDDO  и  DDOL.  Bc  Re : r v (  ( N Bc ).  (  ( N Bc ).  ( N Re )),  Bc ).  139  Сертификат в Bc  Re : ДВК . r v (  *( T exp ).  ( Bc ,   k Bc . open ).  ( ДВК ),  N )  подписан эмитентом карты R .  Он распознает ,  что открытый ключ k Bc.open связан с ДВК .  Таким образом ,  ДВК ассоциируется с любым ,  кто может продемонстрировать владение соответствующим закрытым ключом .  В Re  Bc :  ( N Re )  новый вызов отправляется Bc .  В Bc  Re : r v (  ( N Bc ).  (  ( N Bc ).  ( N Re )),  Bc )  Bc предоставляет подпись над этим одноразовым номером и демонстрирует ,  что он имеет соответствующий закрытый ключ ,  и ,  следовательно ,  аутентифицируется в Re .  Опишем формализации исходных предположений .  Исходные предположения .  1.  Эмитент банковской карты N знает ее открытый и закрытый ключи :  N   ( N ,  k N.open );  N   ( N ,  k N.lock ).  2.  Re знает открытый ключ ,  принадлежащий N :  Re   ( N ,  k N.open ).  3.  Bc знает ,  что N Bc изменился ,  а Re знает ,  что N Re изменился :  Bc   #(  ( N Bc ));  Re   #(  ( N Re )).  4.  Re знает ,  что метка времени  *( T exp )  еще не истекла :  Re    (  *( T exp )),  где   –  изменился или срок годности не истек .  5.  Re считает ,  что эмитент банковской карты N заслуживает доверия :  Re  N   trustworthy.  140  Три предварительных условия для первого ,  второго и третьего сообщения соответственно :  1.  Нуль  0 ( пустой набор ):  Bc всегда запускает аутентификационную часть протокола ДАД .  2.  После получения первого сообщения и до второго сообщения Re должен поверить ,  что ДВК был объявлен N ,  не поврежден и все еще действителен .  Re также должен верить ,  что открытый ключ Bc  –  это k Bc.open :  Re   G  ( ДВК ,  N );  Re   ( ДВК ,  N );  Re   ( Bc ,  k Bc.open ).  3.  Нуль  0 ( пустой набор ):  Bc всегда отвечает на  DDOL.  В конце протокола Re должен полагать ,  что ответ от Bc был недавно сгенерирован с использованием закрытого ключа ,  соответствующего открытому ключу k Bc.open .  Если это предположение может быть подтверждено ,  то Re считает ,  что Bc владеет закрытым ключом ,  который соответствует k Bc.open .  Следовательно ,  Bc аутентифицирован .  В этом случае постусловие имеет следующее утверждение :  Re   G  (  ( N Re ),  Bc ).  То есть Bc аутентифицирует себя и подтверждает в данный момент времени сгенерированный одноразовый номер N Re .  Программная реализация этой спецификации протокола и успешно завершилась .  Все постусловия действительны .  Заключаем ,  что протокол является корректным .  141  4.2.  Протоколы оплаты с использованием мобильных устройств В этом параграфе рассматривается мобильный протокол бесконтактных платежей ,  который обеспечивает высокий уровень безопасности ,  а также дополнительные функции ,  такие как предотвращение отказа от авторства .  Обсуждается его формализация и анализ .  Рассматриваемый протокол мобильных платежей позволяет мобильному телефону с поддержкой  NFC  производить оплату через считывающее устройство  NFC,  которое надежно подключается к шлюзу обработки платежей .  В этой главе мы подробно рассмотрим первый тип протокола мобильных платежей и его анализ .  Протокол оплаты с использованием мобильного устройства ,  обозначаемый как P D ,  позволяет мобильному телефону с поддержкой NFC  взаимодействовать с устройством чтения  NFC  для совершения транзакции через  NFCIPI (NFC-LLCP) [71].  Предполагаем ,  что считыватель  NFC  заслуживает доверия  ( заслуживающий доверия принципал обслуживается и использует правильный и аутентифицированный протокол )  и подключен к платежному серверу через безопасный канал  TLS [57, 55].  Предполагается ,  что связь между считывателем  NFC  и сервером безопасна и выходит за рамки этого анализа .  Платежный сервер отвечает за сбор доказательств транзакций и выполнение таких операций ,  как выставление счетов и аудит .  Мы будем использовать атомарные переменные Ph для обозначения телефона ,  Re для обозначения считывающего устройства и N для обозначения центра сертификации ,  который выдает сертификаты и управляет ими .  Обозначим  ( Ph ,   ( ID Ph ),   ( T 1 Ph ,  T 2 Ph ),  k ph . open ,  N )  как сертификат ,  выданный Ph .  Обозначим  ( Re ,   ( ID Re ),   ( T 1 Re ,  T 2 Re ),  k Re . open ,  N )  как сертификат ,  выданный Re .  Далее будем использовать  ( P )  в качестве сокращенного обозначения для обозначения полного сертификата X.509  принципала P .  Телефон с функцией  NFC  не поддерживает конечный автомат для платежной информации ,  такой как баланс .  Вместо этого эта информация хранится на платежном сервере .  Телефон идентифицируется по сертификату и некоторой вспомогательной 142  информации ,  такой как связанный с ним постоянный номер счета (Permanent Account Number, PAN).  На телефоне с функцией  NFC  и считывателе имеются элементы защиты  [63, 44, 38, 64, 65, 39, 68, 67, 45].  Встроенный элемент безопасности хранит закрытый ключ ,  а также любые секреты ,  которые могут быть удаленно переданы оператором на телефон или считывающее устройство .  Секреты состоят как из недолговечных симметричных ключей ,  так и из протокольных программ .  Невозможно прочитать или изменить содержимое за пределами защищенного элемента ,  и только аутентифицированные программы могут получить доступ к его соответствующим ключам или секретам .  Предполагаем ,  что существует один платежный сервер и много аутентифицированных считывателей и телефонов .  Кроме того ,  предполагаем ,  что один Re может обслуживать только одного Ph в любое время ,  согласование версии и согласование были успешно выполнены ,  и Ph и Re согласовали протокол связи .  Рассмотрение этой процедуры выходят за рамки нашего анализа .  Исходное предположение  –  это набор обоснованных формул ,  которые считаются действительными до запуска протокола .  Закрытые ключи Ph и Re генерируются внутри защищенных элементов .  После создания они никогда не покидают защищенные элементы ,  и соответствующие открытые ключи отправляются на N для сертификации .  Предполагаем ,  что сертификаты были подписаны N ,  а затем переданы Ph и Re до начала сеанса отработки протокола .  Дополнительно предполагаем :  1.  Ph и Re знают открытый ключ центра сертификации N :  Ph    ( N ,  k N . open );  Re    ( N ,  k N . open ).  2.  И Ph ,  и Re считают ,  что N заслуживает доверия .  Ph считает ,  что Re заслуживает доверия :  Ph  N  trustworthy;  Re  N  trustworthy;  Ph  Re  trustworthy.  143  3.  Ph и Re имеют доступ к своим закрытым и открытым ключам :  Ph   ( Ph ,  k ph.open );  Re   ( Re ,  k Re.open );  Ph   ( Ph ,  k ph.lock );  Re   ( Re ,  k Re.lock ).  4.  ID Ph и ID Re не включены в список аннулированных сертификатов ,  а отметки времени на сертификатах Ph и Re соответствуют текущему времени :  Ph   (  ( ID Re ));  Re   (  ( ID Ph ));  Ph    (  ( T 1 Re ,  T 2 Re ));  Re   (  ( T 1 Ph ,  T 2 Ph )),  где   –  идентичность .  5.  Re может восстановить сообщение  server-hello,  которое должно быть сгенерировано им самим в сообщении  2 ( второе сверху )  на рис . 44:  Re   ( Re ,   ( N Re ).  ( T Re ). D Tran ),  где D Tran  –  дескриптор  ( описание )  транзакции ,  которое может включать финансовую информацию о взимаемой сумме ,  продавце ,  местонахождении и т . д .  6.  Ph может реконструировать D Ph сообщения ,  который должен быть сгенерирован сам по себе в сообщении  3 ( третье сверху )  на рис . 44:  144  Ph   ( Ph ,  D Ph ).  7.  Re и Ph считают ,  что метка времени  (T Re )  изменилась :  Re    #(  ( T Re ));  Ph    #(  ( T Re )).  8.  Re считает генерируемый им в данное время  ( N Re )  поменялся :  Рис . 44.  Схема последовательности  UML  для протокола P D оплаты с использованием мобильных устройств на основе  NFC   Ниже приводится пошаговое описание протокола P D .  Шаг  1  (Client Hello).  Ph сначала отправляет свой сертификат в качестве приветствия клиента Re .  Ph  Re :  ( Ph ).  Перед выполнением шага  2  необходимо выполнить повторную проверку сертификата Ph .  Важным в этом процессе является обеспечение истечения срока действия сертификата и его отзыв .  Проверка должна быть успешной ,  и поэтому Re может получить открытый ключ Ph :  Re   ( Ph ,  k Ph.open ).  145  Шаг  2  (Server Hello).  После получения приветствия клиента от Ph ,  Re создает запрос M ,  состоящий из нового  ( измененного )  одноразового номера  ( N Re ),  метки времени  T Re ,  принадлежащей Re ,  описания транзакции D Tran и идентификатор получателя  ( ID Ph ),  который Re получает из  ( Ph ),  полученного на предыдущем этапе .  M оформляется в виде :  M  =   ( N Re ).  (T Re ). D Tran .  ( ID Ph ).  Re имеет требование конфиденциальности по M ,  поскольку D Tran содержит транзакционную информацию ,  которую нельзя раскрыть .  Затем Re отправляет свой сертификат и шифрованный текст ,  зашифрованный с использованием открытого ключа Ph ,  на Ph :  Re  Ph :  ( Re ). r p ( M . r v (  ( M ),  Re ),  Ph ).  До реализации шага  3  Ph должен подтвердить сертификат Re .  Он также проверяет целостность ,  актуальность и является ли сервер предполагаемым получателем  ( если его идентификатор подтвержден ).  Он также может выполнять некоторые семантические проверки ,  зависящие от протокола транзакции .  Например ,  он проверяет ,  является ли пакет запроса транзакции D Tran правильным и ожидаемым .  Поскольку они не имеют непосредственного отношения к модели безопасности ,  не будем их включать в предварительные условия .  Однако их легко добавить .  Таким образом ,  предварительными условиями для этой передачи являются :  1.  Ph считает ,  что открытый ключ принадлежит Re :  Ph   ( Re ,  k Re . open ).  2.  Ph считает ,  что M происходит от Re :  Ph   G  ( M ,  Re )  3.  Ph считает M измененным :  Ph    #( M ).  146  4.  Ph считает ,  что М не повреждено с тех пор ,  как произнесено Re :  Ph   ( M ,  Re ).  5.  Ph считает ,  что это предполагаемое считывающее устройство для M ,  и что M подтверждает свой идентификатор :  Ph   ( M ,  Ph );  Ph  w P ( M ,   ( ID Ph )),  где w P ( M ,   ( ID Ph )) –   ( ID Ph )  является частью M ;   ( M ,  Ph ) –  Ph является получателем от M .   ( ID Ph )  в Ph  w P ( M ,   ( ID Ph ))  является идентификатором Ph ,  содержащийся в  ( Ph ).  Это подтверждение моделирует проверку ,  которую выполняет Ph .  Если личность ,  подтвержденная Re ,  отличается от  ( ID Ph ),  тогда Ph знает ,  что транзакция фальсифицирована .  Шаг  3  ( привязка телефона , Phone Binding).  Затем Ph строит свое описательное сообщение D Ph .  D Ph будет содержать любую дополнительную информацию ,  которую Ph должен предоставить для завершения этой транзакции ,  например ,  ДВК .  Затем Ph производит подпись S Ph .  Подпись верифицирует M . D Ph в Ph .  S Ph   =  r v (  ( M . D Ph ),  Ph ).  После этого Ph шифрует D ph и подпись ,  используя открытый ключ ,  принадлежащий Re ,  и отправляет шифрованное сообщение Re .  Ph  Re : r p ( D Ph . S ph ,   Re ).  До реализации шага  4  необходимо провести повторную проверку целостности ,  и подлинности сообщения .  Кроме того ,  Re проверяет ,  подтверждает ли Ph правильный M  ( M ,  созданный Re ,  а не отправленный Ph ).  Предварительные условия на этом этапе :  1.  Re считает ,  что Ph прислала подтверждение транзакции в лице M . D Ph :  147  Re   G  ( M . D Ph ,  Ph ).  2.  Re считает ,  что M . D Ph  –  это только что сгенерированная транзакция ,  а не её повтор :  Re   #( M . D Ph ).  3.  Re считает ,  что M . D ph не поврежден ,  так как он был сгенерирован Ph :  Re   ( M . D Ph ,  Ph ).  Шаг  4  ( Получение , Receipt).  После получения D ph и проверки его целостности и подлинности Re генерирует квитанцию и передает ее Ph .  Квитанция ,  обозначаемая как D Re ,  представляет собой композицию запроса транзакции D Tran и ответа D ph плательщика ,  а также распознавания считывающим устройством двойной привязки .  Пусть R Ph.Re обозначает квитанцию ,  сгенерированную Re для отправки в Ph :  R Ph.Re  =  D Re . r v (  ( D Ph . M . D Re ),  Re ).  Наконец ,  R Ph.Re зашифровывается и отправляется Ph .  Таким образом ,  имеем Re  Ph : r p ( R Ph.Re ,  Ph ).  Постусловия :  А .  Ph проверяет :  подтверждает ли Re правильный D ph  ( Ph недавно отправил D ph )  и что D Ph . M . D Re от Re ,  изменился и неповрежденный .  Ph   G  ( D Ph . M . D Re ,   Re );  Ph   #( D Ph . M . D Re );  Ph   ( D Ph . M . D Re ,   Re )  148  Б .  Неопровержимый запрос от Re :  Ph содержит неопровержимые и неповрежденные доказательства того ,  что Re запросил платеж  ( в определенной сумме в определенное время ,  в определенном месте и т . д .).  Если Re опровергает платеж ,  Ph может предъявить подлежащее передаче доказательство арбитру :  -  обеспечение защиты авторства в отношении контента :  Ph   ( Ph ,   G  ( M ,  Re ));  -  обеспечение фиксации авторства в отношении целостности контента :  Ph   ( Ph ,   ( M ,  Re )).  В . Неопровержимый платеж от Ph :  Ph санкционировал платеж в ответ на запрос Re .  Ph предоставил такую информацию ,  как номер PAN  и сумму ,  которую он разрешил выплатить ,  а также свою готовность связать этот платеж с запросом Re .  Re хранит это неопровержимое доказательство .  Если Ph опровергает какие - либо сведения о сумме , PAN,  продавце ,  времени и месте платежа ,  тогда Re может предоставить передаваемое доказательство честности перевода :  Re   ( Re ,   G  ( M . D Ph ,   Ph ));  Re   ( Re ,   ( M . D Ph ,   Ph )).  Г . Неопровержимое подтверждение платежа :  Кроме того ,  Re не может позже опровергнуть тот факт ,  что он не получил приемлемый платеж от Ph .  Ph может предъявить передаваемое доказательство арбитру о принятии Re оплаты от Ph :  Ph   ( Ph ,   G  ( D Ph . M . D Re ,   Re ));  Ph   ( Ph ,   ( D Ph . M . D Re ,   Re )).  Программная реализация этого алгоритма показала ,  что протокол успешно завершился .  По завершении выполнения алгоритма все постусловия выполняются .  Таким образом ,  мы 149  заключаем ,  что P D является корректным .  Это означает ,  что протокол P D выполняет набор требований безопасности ,  отраженных в указанных предварительных условиях и постусловиях .  Далее рассмотрим две атаки ,  полученные путем применения функции преобразования F A на P D .  Далее рассмотрим подслушивающего злоумышленника ,  который прослушивает все передачи между Re и Ph ,  не внося никаких изменений в передаваемые сообщения .  Эта атака на P D обозначается как P D.attack  –  протокол атаки на протокол P D .  Наша цель –  убедиться ,  что соблюдены требования к секретности конфиденциальной информации .  Диаграмма последовательности P D.attack представлена на рис . 45.  Рис . 45.  Схема последовательности  UML  для протокола атаки P D.attack .  Набор исходных предположений такой же ,  как и для P D ,  за исключением того ,  что злоумышленник ,  обозначенный как H *,  знает открытые ключи центра сертификации N ,  Re и Ph .  Таким образом ,  имеем H *    ( N ,  k N . open ),   H *    ( Ph ,  k ph . open ),   H *    ( Re ,  k Re . open ).   Кроме того ,  предполагаем ,  что N и Re заслуживают доверия для злоумышленника :   150  H *   N   trustworthy;   H *   Re   trustworthy.  Постусловия для атаки злоумышленника на P D такие же ,  как для P D ,  поскольку H *  не изменяет никакие передачи ,  и все участники P D полностью участвуют в P D . attack .  Последовательность передач транзакций и предварительные условия представлены в табл . 16.  Таблица  16  Предварительные условия и обмен сообщениями при атаке P D . attack Последова - тельность Предварительные условия Обмен сообщениями 1  Нет Ph  H *:   ( Ph )  2  Нет H *   Re :   ( Ph )  3  Re   ( Ph ,  k Ph . open )  Re  H *:  ( Re ). r p ( M . r v (  ( M ), Re ), Ph )  4  Нет H *   Ph :  ( Re ). r p ( M . r v (  ( M ), Re ), Ph )  5  Ph   ( Re ,  k Re . open ),  Ph   G  ( M ,  Re ),  Ph   #( M ),  Ph   ( M ,  Re ),  Ph   ( M ,  Ph ),  Ph  w p ( M ,   ( ID Ph )) Ph  H *: r p ( D Ph . r v (  ( M . D Ph ), Ph ), Re )  6  Нет H *   Re : r p ( D Ph . r v (  ( M . D Ph ), Ph ), Re )  7  Re   G  ( M . D Ph ,  Ph ),  Re   #( M . D Ph ),  Re    ( M . D Ph ,  Ph )  Re   H *: r p ( D Re . r v (  ( D Ph . M . D Re ), Re ), Ph )  8  Нет H *   Ph : r p ( D Re . r v (  ( D Ph . M . D Re ), Re ), Ph )  Набор утверждений злоумышленников моделирует секретность с помощью отрицаний трех формул .  Они утверждают ,  что злоумышленник не может восстановить M ,  D Re или D Ph :  151  1.  Злоумышленник H *  не может восстановить сообщение транзакционного запроса M  ( секретность M )   H *    ( H *,  M ).  2.  Злоумышленник H *  не может восстановить сообщение подтверждения транзакции D Ph  ( секретность на D Ph ).   H *    ( H *,  D Ph ).  3.  Злоумышленник H *  не может восстановить сообщение D Re ( Секретность на D Re )   H *    ( H *,  D Re ).  При программной реализации атаки для протокола P D . attack .  Протокол был доведен до конца ,  и все пост - условия и утверждения злоумышленников были действительны .  Алгоритм возвращает истину и ,  следовательно , P D является правильным при атаке P D . attack .  В P D . attack мы вставили злоумышленника ,  который прослушивал все сообщения ,  которыми обменивались Re и Ph .  Программная реализация протокола P D показала ,  что злоумышленник не смог раскрыть текстовые сообщения M ,  D Re или D Ph .  При этом атака не была обнаружена ,  а все постусловия и утверждения злоумышленников были выполнены .  Это означает ,  что исходный протокол P D защищен от этого специфического типа атак с перехватом ,  поскольку обеспечивает секретность передаваемой транзакционной информации .  Теперь смоделируем другую атаку ,  в которой злоумышленник H *  пытается выдать себя за Ph ,  воспроизводя его сертификат и некоторые из старых сообщений H *,  перехваченных в предыдущем сообщении  ( M  ),  аналогичном P D . attack .  Обозначим атаку как P D 2. attack .  Последовательность передачи сообщений на языке  UML  представлена на рис . 46.  В этом протоколе Re предполагает ,  что разговаривает с Ph .  Вместо этого Re взаимодействует с злоумышленником H *,  при этом Ph заблокирован от получения каких - либо сообщений .  После получения сигнала  client-hello,  воспроизведения сертификата Ph от H *,  Re возвращает свой сертификат ,  а также  r p ( M . r v (  ( M ),  Re ),  Ph ).  152  Поскольку H *  не знает закрытый ключ Ph ,  H *  не может управлять этим сообщением ,  а H *  не может видеть его содержимое .  Вместо этого H *  отправляет повтор третьей передачи в предыдущем прогоне P D между Re и Ph ,  обозначенный как r p ( D Ph . r v (  ( M' . D Ph ),  Ph ),  Re ),  где M' отличается от M ,  т . к .  М изменился ,  и D Ph использовалась в качестве платежной информации ,  которую использовал Ph ,  в надежде ,  что Re примет платежную информацию .  Если протокол завершается ,  Re отправляет свою подпись через D Ph . M . D Re ,  где D Ph был получен Re ;  M и D Re были построены Re .  Рис . 46.  Схема последовательности  UML  для протокола атаки P D 2. attack Исходные предположения такие же ,  как и для P D . attack .  Предварительные условия и передача сообщений представлены в табл . 17.  Таблица  17  Протокол атаки P D 2. attack для протокола оплаты мобильного считывателя Последова - тельность Предварительные условия Обмен сообщениями 1  Нет H *   Re :  ( Ph )  2  Re   ( Ph ,  k Ph . open )  Re  H *:  ( Re ). r p ( M . r v (  ( M ), Re ), Ph )  3  Нет H*    Re:r p (D Ph r v (  ( M' . D Ph ),  Ph ),  Re )  4  Re   G  ( M . D Ph ,  Ph ),  Re   #( M . D Ph ),   Re   ( M . DPh ,  Ph )  Re  H *: r p ( D Re . r v (  ( D Ph . M . D Re ), Re ), Ph )  153  Все предварительные условия ,  связанные с Ph ,  удалены ,  поскольку Ph не участвовал в этом протоколе атаки .  Все предварительные условия для передачи сообщений ,  в которых злоумышленник является отправителем ,  являются пустыми .  Более того ,  три предварительных условия для сообщения  4 –  это утверждения о M ,  а не о M' .  Это связано с тем ,  что эти утверждения являются признанием Ph элемента M ,  созданного Re ,  а не признанием M элемента Re ,  получаемого от Ph .  Они утверждают ,  что на этом этапе протокола Re должен иметь возможность вывести уверенность в том ,  что M ,  построенное Re ,  является подтверждено Ph .  Ph признаёт другой M' и не изменяет цель подтверждения ,  которую ищет Re .  В этом случае имеет следующие постусловия :  1.  Re убежден в неопровержимых доказательствах подтверждения сделки Ph . M . D Ph :  Re   ( Re ,   G  ( M . D Ph ,  Ph )).  2.  Re убежден в целостность неопровержимых доказательств :  Re   ( Re ,   ( M . D Ph ,  Ph )).  Наконец ,  утверждения злоумышленника этого протокола атаки :  1.  Злоумышленник H *  не может восстановить сообщение транзакционного запроса M  ( секретность M ):   H *    ( H *,  M ).  2.  Злоумышленник  H*  не может восстановить  D Re ,  т . е .  квитанцию :   H*    (H*,  D Re ).  Эти утверждения злоумышленника отражают требования конфиденциальности ,  которые были наложены на платежную информацию M и D Re ;  два утверждения были построены и отправлены честным принципалам Re .  Программная реализация алгоритма P D 2. attack показала ,  что протокол P D остановлен после того ,  как Re получил 154  r p ( D Ph . r v (  ( M' .D Ph ), Ph ), Re )  из - за нарушения предварительного условия Re   G  ( M . D Ph ,  Ph ),  где M сгенерирован в начале протокола и было вызовом Re .  Более того ,  на момент нарушения утверждения злоумышленника были действительными .  То есть злоумышленник не может восстановить M или D Re .  Это означает ,  что исходный протокол может обнаруживать этот тип атаки ,  и на момент обнаружения никакие требования к секретности не были нарушены .  Вывод :  протокол P D ведет себя корректно при атаке P D 2. attack .  В этом параграфе был представлен протокол бесконтактных платежей с помощью мобильного считывателя с высокой степенью защиты .  Две ключевые особенности этого протокола ,  которых нет в EMV  ДАД , –  это секретность платежной информации  ( аналогичная ДВК в  EMV)  и обработка неотказуемости как для продавца ,  так и для клиента .  Мы формализовали протокол P D и показали ,  что он работает корректно .  Были рассмотрены две формы атаки :  одну на секретность ( P D . attack )  и другую за выдачу себя за другое лицо  ( P D 2. attack ).  Пришли к выводу ,  что протокол - кандидат P D защищен от этих двух атак в отношении набора начальных предположений ,  а также предварительных и последующих условий .  155  4.3.  Протоколы оплаты с использованием мобильных токенов В этом параграфе рассматривается мобильный протокол бесконтактных платежей ,  который обеспечивает высокий уровень безопасности ,  а также дополнительные функции ,  такие как предотвращение отказа от авторства .  Обсуждается его формализация и анализ .  Рассматриваемый протокол мобильных платежей позволяет NFC- телефону с возможностью подключения к серверу приобретать услуги или товары ,  идентифицируемые пассивными тегами  ( смарт - картами ).  В отличие от протокола оплаты на основе считывателя ( параграф  4.2),  телефон теперь отвечает за сбор доказательств транзакции ,  а также за их отправку на платежный сервер .  Первоначально рассмотрим протокол мобильных платежей ,  который не использует  NFC- считыватель .  Протокол ,  обозначенный как P B ,  позволяет  NFC- телефону с возможностью передачи данных сервера покупать услуги или товары ,  идентифицированные пассивными тегами  ( смарт - картами ).  В отличие от протокола оплаты на основе считывателя ,  телефон теперь отвечает за сбор доказательств транзакции ,  а также за их отправку на платежный сервер .  Пассивные теги размещаются с описанием покупаемых услуг или товаров .  Они обесточены и общаются с телефоном по схеме модуляции нагрузки .  Популярными примерами являются умные плакаты ,  где на стене вешают пассивные теги для рекламы услуг ,  а также умные дисплеи в торговом центре ,  где покупатели могут нажать ,  чтобы заплатить за отображаемые товары .  После этого покупатели могут забрать купленные товары при выходе из магазина или торгового центра .  Основное различие между этим типом платежного протокола P B и протоколом на основе считывателя P D заключается в том ,  что пассивные теги не могут представлять произвольные услуги или товары .  Вместо этого они представляют собой фиксированный набор услуг или товаров .  Преимущество состоит в том ,  что зачастую к продаваемым товарам не предъявляются требования конфиденциальности  –  каждый может их проверить .  После того ,  как телефон коснется пассивной метки ,  метка представляет  « меню »  товаров или услуг для покупки .  Такое же  « меню »  возвращается при каждом таком запросе .  Единственное требование ,  которое 156  предъявляет платежный сервер , –  это то ,  что идентифицированный телефон  ( необязательно с информацией о выбранном платежном инструменте )  согласился приобрести определенную услугу в определенное время .  Предполагаем ,  что пассивные теги могут выполнять примитивные криптографические операции ,  такие как шифрование и цифровая подпись .  Кроме того ,  у тегов достаточно памяти для хранения своих сертификатов .  Предполагается ,  что хранение закрытых ключей и секретов в этих тегах аналогично защищенному элементу ,  используемому в телефоне .  Закрытые ключи и любые секреты не могут быть прочитаны или изменены злоумышленниками .  В этом протоколе задействованы три типа принципалов :  уникальный платежный сервер Se ,  количество действующих  NFC- телефонов Ph и количество действующих смарт - карт Sm .  Предполагаем ,  что Se считается заслуживающим доверия как Ph ,  так и Sm .  Ph и Sm не считаются заслуживающими доверия Se .  Предположим ,  что выдающий орган управляет сертификатами для всех участников .  Высокоуровневое описание протокола выглядит следующим образом :  после того ,  как Se получает сигнал  client-hello  от Ph ,  Se генерирует запрос M Se  =   ( N Se ).  ( T Se ).  ( ID Ph ),  где  ( N Se ) –  глобально уникальный одноразовый номер ,  а  ( T Se ) –  временная метка ,  сгенерированная сервером .  Сообщение M Se и его подтверждение происхождения затем отправляется в Ph .  Ph затем пересылает то же сообщение Sm для подписи .  После получения подписи от Sm ,  Ph выполняет вторую подпись под подписью ,  возвращенной Sm .  Полученная в результате двойная подпись передается обратно в Se для проверки .  Наконец ,  если все верно ,  квитанция возвращается Ph .  Общая последовательность потока сообщений представлена на рис . 47.  157  Рис . 47.  Схема последовательности  UML  для телефона  NFC,  протокол P B оплаты смарт - картой Ниже представлена формализованная спецификация P B ,  включая исходные предположения ,  передачу сообщений ,  предварительные условия ,  а также постусловия .  1.  И Ph ,  и Sm считают ,  что Se заслуживает доверия . Ph, Sm  и  Se  считают ,  что это транзакция заслуживает доверия .  Таким образом :  Ph  Se  trustworthy;  Sm  Se  trustworthy;  Ph  N  trustworthy;  Sm  N  trustworthy;  Se  N  trustworthy. 2.  Ph ,  Sm и Se имеют доступ к своим личным и открытым ключам :  Ph   ( Ph ,  k Ph . open );  Sm   ( Sm ,  k Sm . open );  158  Se   ( Se ,  k Se . open );  Ph   ( Ph ,  k Ph . lock );  Sm   ( Sm ,  k Sm . lock );  Se   ( Se ,  k Se . lock ).  3.  Ph ,  Sm и Se имеют  root- сертификаты от центра сертификации и ,  следовательно ,  знают открытый ключ N :  Ph   ( N ,  k N . open );  Sm   ( N ,  k N . open );  Se   ( N ,  k N . open ).  4.  ID Ph ,  ID Se ,  ID Sm отсутствуют в списке аннулированных сертификатов ,  а отметки времени на сертификатах Ph ,  Se и Sm соответствуют текущему времени :  Ph   (  ( ID Se ));  Sm   (  ( ID Se ));  Se   (  ( ID Se ));  Se   (  ( ID Ph ));  Sm   (  ( ID Ph ));  Ph   (  ( ID Ph ));  Se   (  ( ID Sm ));  Ph   (  ( ID Sm ));  Sm   (  ( ID Sm ));  159  Ph   (  ( T 1 Se ,  T 2 Se ));  Sm   (  ( T 1 Se ,  T 2 Se ));  Se   (  ( T 1 Se ,  T 2 Se ));  Se   (  ( T 1 Ph ,  T 2 Ph ));  Sm   (  ( T 1 Ph ,  T 2 Ph ));  Ph   (  ( T 1 Ph ,  T 2 Ph ));  Ph   (  ( T 1 Sm ,  T 2 Sm ));  Se   (  ( T 1 Sm ,  T 2 Sm ));  Sm   (  ( T 1 Sm ,  T 2 Sm )),  где   –  невозможность отзыва сертификата .  5.  Se может восстановить одноразовый номер и метку времени ,  сгенерированные им самим ,   (N Se ).  ( T Se ).  Ph может восстановить сообщение M Ph ,  сгенерированное им самим :  Se   ( Se ,  ( N Se ).   ( T Se ));  Ph   ( Ph ,  M Ph ).  6.  Se и Ph полагают ,  что  ( T Se ) ,  созданное Se ,  является новой отметкой времени :  Se   (  ( T Se ));  Ph    (  ( T Se )).  7.  Se считает ,  что в данный момент времени  ( N Se )  изменился :  Описание протокола P B :  160  Шаг  1 .  Предварительных нет условий .  Ph отправляет свой сертификат Se :  Ph  Se :  ( Ph ).  Шаг  2 .  Предварительное условие  –  Se необходимо проверить сертификат Ph и тем самым получить открытый ключ Ph :  Se   ( Ph ,  k Ph . open ).  Se генерирует M Se ,  который состоит из одноразового номера  ( N Se ),  отметки времени сервера  ( T Se ),  а также тега получателя  ( ID Ph ),  который Se получает от  ( Ph ),  полученного в предыдущем сообщении .  Se не требует конфиденциальности по отношению к M Se .  Затем он отправляет свой сертификат  ( Se ),  M Se и свою подпись над хешем M Se в Ph .  Предполагаем ,  что Se отслеживает все M Se ,  которые он создает для определенного Ph :  Se  Ph :  ( Se ). M Se . r v (  ( M Se ), Se ).  Шаг  3 .  Предварительные три условия :  1.  Ph должен извлечь открытый ключ Se и убедиться ,  что M Se исходит от Se :  Ph   ( Se ,  k Se . open );  Ph   G  ( M Se ,  Se ).  2.  Ph должен гарантировать ,  что M Se изменился и неповрежденный :  Ph   #( M Se );  Ph   ( M Se ,  Se ).  3.  Ph должен убедиться ,  что M Se подтверждает ID ,  принадлежащий Ph ,  чтобы он был предназначен для Ph ,  а не для других Ph' :  161  Ph  w p ( M Se ,   ( ID Ph )).  Затем Ph отправляет хешированный M Se в Sm :  Ph  Sm :  ( M Se ).  Шаг  4 .  Предварительных нет условий .  Sm вычисляет свою подпись по хешу M Se и возвращает подпись ,  а также свой сертификат .  Sm  Ph :  ( Sm ). r v (  ( M Se ), Sm ).  Шаг  5 .  Предварительные два условия :  1.  Ph должен сначала проверить сертификат Sm  ( срок действия ,  срок действия ,  CRL и т . д .)  И извлечь открытый ключ Sm .  Ph   ( Sm ,  k Sm . open ).  2.  Ph должен проверить ,  что Sm подтвердил  ( произнес )  M Se ,  чтобы исключить любую повторную атаку .  Ph также проверяет ,  не повреждена ли M Se :  Ph   G  ( M Se ,  Sm );  Ph   ( M Se ,  Sm ).  Пусть M Sm  r v (  ( M Se ), Sm ); M Sm можно рассматривать как недавно созданный и глобально уникальный платежный запрос ,  в котором услуга и продавец идентифицируются с помощью Sm ,  а время и покупатель идентифицируются с помощью M Se .  Затем Ph готовит свои платежные реквизиты ,  такие как выбранный номер PAN,  обозначаемый строкой M Ph .  Ph подписывает хеш  M Ph .M Sm и тем самым эффективно связывает свое согласие с  M Ph и  M Sm .  Наконец ,  Ph передает сертификат Sm ,  зашифрованную строку через M Ph . M Sm и подписанный хеш :  Ph  Se :  ( Sm ). r p ( M Ph . r v (  ( M Ph . M Sm ), Ph ), Se ).  Шаг  6 .  Предварительные три условия  –  сервер должен проверить ряд элементов перед отправкой квитанции :  162  1.  Сначала сервер проверяет сертификат Sm ,   ( Sm )  и извлекает открытый ключ Sm :  Se   ( Sm ,  k Sm . open ).  2.  Затем Se извлекает M Se ,  которое было отправлено Ph ,  из своей базы данных .  Se проверяет ,  что M Se подтвержден Sm и подтверждение не повреждено :  Se   G( M Se ,  Sm );  Se   ( M Se ,  Sm ).  3.  Se необходимо убедиться ,  что M Ph . M Sm произносится Ph и не поврежден :  Se   G  ( M Ph . M Sm ,  Ph );  Se    ( M Ph . M Sm ,  Ph ).  Далее Se выдает квитанцию .  Он создает подпись поверх хеша  ( ID Sm ),  M Se и M Ph ,  которая эффективно подтверждает транзакцию между  ( ID Ph )  и  ( ID Sm )  в момент времени  ( T Se )  с платежной информацией ,  как описано в M Ph :  Se  Ph : r v (  (  ( ID Sm ). M Se . M Ph ),  Se ).  Шаг  7. Алгоритм работы протокола закончен .  Постусловия :  1.  Утверждения ,  принадлежащие Ph ,  по последнему сообщению ,  которое получил Ph .  Ph утверждает ,  что он происходит от Se ,  он не поврежден ,  и делает вывод :  Ph   G  (  ( ID Sm ). M Se . M Ph ,  Se );  Ph   (  ( ID Sm ). M Se . M Ph ,  Se ).  163  2.  Неопровержимый платеж от Ph :  Ph предоставил свою платежную информацию M Ph и привязал себя к услуге и времени .  Если Ph позже опровергнет ,  что он согласился оплатить услуги ,  идентифицированные идентификатором смарт - карты  ( ID Sm )  в момент времени  ( T Se )  с платежными реквизитами M Ph ,  платежный сервер Se может предоставить неопровержимые доказательства арбитру .  Формально это :  -  Se предлагает посредством свидетельства M Sm и строки M Se передаваемое доказательство того ,  что Sm связывает свою идентичность с M Se :   Se   ( Se ,   G  ( M Se ,  Sm ));  Se   ( Se ,   ( M Se ,  Sm ));  -  Se предлагает передаваемое доказательство того ,  что Ph связал свою личность с платежной информацией M Ph и тем же M Sm ,  Se   ( Se ,   G  ( M Ph . M Sm ,  Ph ));  Se   ( Se ,   ( M Ph . M Sm ,  Ph )).  таким образом ,  доказывает ,  что Ph согласился приобрести услугу ,  обозначенную  ( ID Sm ),  с платежной информацией M Ph и на конкретное время ,  как указано в  ( T Se ).  3.  Неопровержимое подтверждение платежа .  Кроме того , Se  не может позже опровергнуть ,  что он не получил приемлемого платежа от Ph .  Ph может предъявить передаваемое доказательство арбитру о принятии Se оплаты Ph .  Доказательства связывают согласие Se с личностями Ph и Sm ,  а также с платежной информацией и временем транзакции .  Ph   ( Ph ,   G  (  ( ID Sm ). M Se . M Ph ,  Se ));  Ph   ( Ph ,   (  ( ID Sm ). M Se . M Ph ,  Se )).  Программная реализация алгоритм P B успешно отработала до конца без нарушения предварительных условий .  Кроме того ,  все 164  постусловия были действительны на момент завершения .  P B является надёжным протоколом .  Это означает ,  что протокол P B соответствует набору бизнес - требований и целей безопасности ,  отраженных в предварительных и постусловиях .  Кроме того ,  он соответствует предпосылкам вышеупомянутого набора исходных предположений .  Все исходные предположения должны быть выполнены ,  прежде чем можно будет утверждать ,  что P B надёжный протокол .  Теперь рассмотрим две возможные атаки ,  полученные при применении функции преобразования F A к P B .  I.  Секретная атака .  Представляем злоумышленника ,  который прослушивает весь передаваемый трафик ,  не внося никаких изменений в передачу .  Это перехватывающая атака через P B ,  обозначенная как P B.Attack .  Диаграмма последовательностей для P B.Attack представлена на рис . 48.  Протокол аналогичен на P B ,  за исключением того ,  что каждая передача в P B теперь проходит через злоумышленника H *.  Набор исходных предположений аналогичен ,  как и для P B ,  за исключением того ,  что H *  теперь знает открытый ключ центра сертификации N ,  Se ,  Ph и Sm .  Таким образом ,  мы имеем :  H *    ( N ,  k N . open );  H *    ( Se ,  k Se . open );  H *    ( Ph ,  k Ph . open );  H *    ( Sm ,  k Sm . open ).  Кроме того ,  предполагаем ,  что N и Se заслуживают доверия злоумышленника :   H *   N  trustworthy; H *   Se  trustworthy. Постусловия такие же ,  как и в исходном протоколе P B ,  поскольку H *  не изменяет никаких сообщений ,  и Se ,  Ph и Sm участвуют в P B,Attack до завершения своих соответствующих ролей .  165  Рис . 48.  Схема последовательности  UML  для протокола P B . Attack ,  случай с подслушивателем 166  Предварительные условия и последовательность передачи сообщений представлены в табл . 18.  Таблица  18  Предварительные условия и обмен сообщениями для протокола атаки P B . Attack Последова - тельность Предварительные условия Обмен сообщениями 1  Нет Ph  H *:  ( Ph )  2  Нет H *   Se :  ( Ph )  3  Se   ( Ph ,  k Ph . open )  Se  H *:  ( Se ). M Se . r v (  ( M Se ),  Se )  4  Нет H *   Ph :  ( Se ). M Se . r v (  ( M Se ),  Se )  5  Ph   ( Se ,  k Se . open ),  Ph   G  ( M Se ,  Se ),  Ph   #( M Se ),  Ph   ( M Se ,  Se ),  Ph  w p ( M Se ,  ( ID Ph ))  Ph    H* :  ( M Se ) 6  Нет H *   Sm :  ( M Se )  7  Нет Sm  H *:  ( Sm ). r v (  ( M Se ),  Sm )  8  Нет H *   Ph :   ( Sm ). r v (  ( M Se ),  Sm )  9  Ph   ( Sm ,  k Sm . open ),  Ph   G  ( M Se ,  Sm ),  Ph   ( M Se ,  Sm )  Ph   H *:  ( Sm ). r p ( M Ph . M Sm . r v (  ( M Ph . M Sm ), Ph ), Se ) 10  Нет H *   Se :   ( Sm ). r p ( M Ph . M Sm . r v (  ( M Ph . M Sm ), Ph ), Se )  11  Se   ( Sm ,  k Sm . open ),  Se   G  ( M Se ,  Sm ),  Se    ( M Se ,  Sm ),  Se   G  ( M Ph . M Sm , Ph ),  Se   ( M Ph . M Sm , Ph ) Se  H *: r v (  (  ( ID Sm ). M Se . M Ph ),  Se )  12  Нет H *   Ph : r v (  (  ( ID Sm ). M Se . M Ph ),  Se )  167  Последовательность передач теперь включает в себя те последовательности ,  которые были получены и переданы нарушителем H *.  Утверждения злоумышленника ,  которые мы требуем для P B . Attack ,  просто заключаются в том ,  что перехватчик не получает реквизиты платежа ,  отправленные от Ph :   H *    ( H *,  M Ph ).  Предполагаем ,  что Sm и Se не предъявляют никаких требований к конфиденциальности .  Se генерирует новую M Se ,  которая может быть публично видна ,  а Sm может раскрыть свою идентичность ,  а также  ( M Se ).  Программная реализация алгоритма P B . Attack показала ,  что протокол успешно завершен ,  и все постусловия и утверждения злоумышленников действительны .  Программа возвращает true ,  и ,  таким образом ,  протокол P B надежен и безопасен при атаке P B . Attack .  II.  Атака с использованием ретрансляции .  Далее моделируем ретрансляционную атаку на P B ,  обозначенную как P B 2. Attack .  Схема последовательности  UML  представлена на рис . 49.  Злоумышленник H *  не позволяет Sm получить  ( M Se ),  и H *  передает  ( M Se )  на вторую аутентифицированную смарт - карту Sm' для подписи .  Затем H *  возвращает эту подпись Ph .  Ph думает ,  что он прослушивал Sm ,  но на самом деле он получил доказательства прослушивания для другой смарт - карты ,  возможно ,  в другом географическом месте .  Обратите внимание ,  что Sm не участвует в этом протоколе .  Исходные предположения такие же ,  как у P B . Attack .  Последовательность передач и их предварительные условия представлены на в табл . 19.  168  Рис . 49.  Схема последовательности  UML  для атаки P B 2. Attack ,  случай со второй аутентифицированной смарт - картой .  169  Таблица  19  Предварительные условия и обмен сообщениями для протокола атаки P B 2. Attack Последова - тельность Предварительные условия Обмен сообщениями 1  Нет Ph  Se :  ( Ph )  2  Se   ( Ph ,  k Ph . open )  Se  Ph :  ( Se ). M Se . r v (  ( M Se ), Se )  3  Ph   ( Se ,  k Se . open ),  Ph   G  ( M Se ,  Se ),  Ph   #( M Se ),  Ph   ( M Se ,  Se ),  Ph   w p ( M Se ,  ( ID Ph )) Ph  H *:  ( M Se )  4  Нет H *   Sm  :  ( M Se )  5  Нет Sm   H *:  ( Sm  ). r v (  ( M Se ),  Sm  )  6  Нет H *   Ph :  ( Sm  ). r v (  ( M Se ),  Sm  )  7  Ph   ( Sm  ,  k Sm  . open ), Ph   G  ( M Se ,  Sm  ),  Ph   ( M Se ,  Sm  )  Ph  Se :  ( Sm  ). r p ( M Ph . M Sm  . r v (  ( M Ph . M Sm  ), Ph ), Se ) 8  Se   ( Sm  ,  k Sm  . open ),  Se   G  ( M Se ,  Sm  ),  Se   ( M Se ,  Sm  ),  Se   G  ( M Ph . M Sm  , Ph ), Se   ( M Ph . M Sm  , Ph ) Se  Ph : r v (  (  ( ID Sm  ). M Se . M Ph ), Se )  Предварительные условия для обмена сообщениями  7  и  8  теперь относятся к Sm' .  Это связано с тем ,  что они были семантически связаны со смарт - картой при передаче сообщения  6,  которое возвращается злоумышленником ,  выполнившим перенаправление сообщения  ( табл . 19).  Набор постусловий и утверждений злоумышленника модифицируется в соответствии с этим изменением по сравнению с исходным протоколом .  Далее представлены постусловия ,  которые накладываем на протокол атаки P B 2. Attack :  170  1.  Утверждения Ph по последнему сообщению ,  которое получил Ph .  Ph утверждает ,  что он происходит от Se ,  он не поврежден ,  и делает вывод  ( ID Sm  ). M Se . M Ph :  Ph   G  (  ( ID Sm  ). M Se . M Ph ,  Se );  Ph   (  ( ID Sm  ). M Se . M Ph ,  Se ).  2.  Утверждения по общему протоколу по завершении :  -  Неопровержимая выплата от Ph :  Se   ( Se ,   G  ( M Se ,  Sm  ));  Se   ( Se ,   ( M Se ,  Sm  ));  Se   ( Se ,   G  ( M Ph . M Sm  ,  Ph ));  Se   ( Se ,   ( M Ph . M Sm  ,  Ph )).  -  Неопровержимое подтверждение платежа :  Ph   ( Ph ,   G  (  ( ID Sm  ). M Se . M Ph ,  Se ));  Ph    ( Ph ,   (  ( ID Sm  ). M Se . M Ph ,  Se )).  3.  Утверждение злоумышленника ,  которое мы накладываем на P B 2. Attack ,  состоит в том ,  что H *  не может восстановить M Ph :   H *    ( H *,  M Ph ).  Отличие спроектированного протокола  P B от стандартного протока  NFC  в том ,  что до шага  5  в стандартном протоколе Ph не проверяет ,  является ли Sm предполагаемым продавцом  /  товаром для покупки .  В стандартном протоколе не было указано никаких предварительных условий ,  отражающих это требование безопасности .  Иначе говоря ,  Ph не заботится ,  было ли доказательство прослушивания от Sm или какого - то Sm '.  171  На практике приложение ,  работающее на телефоне ,  может представить окно  ( диалоговую форму )  подтверждения и попросить клиента подтвердить ,  что все ,  что Ph получает обратно от Sm ,  является согласованным ,  прежде чем Ph примет транзакцию .  Разработанная модель протокола может обеспечить эту дополнительную меру предосторожности в виде предварительного условия для шага  5  в P B :  Ph  w p (  ( Sm ),  ( ID Sm )),  где  ( Sm ) –  это сертификат определенного Sm ,  который получает Ph ,  а  ( ID Sm ) –  это идентификатор смарт - карта  ( то есть подразумеваемые товары для покупки ),  которая является ожиданием покупателя .  Это поднимает интересную проблему для некоторых приложений бесконтактных платежей ,  таких как оформление билетов на общественный транспорт ,  в которых сервер должен иметь возможность определять географическое положение любого платежного устройства для целей расчета тарифов и аудита .  В традиционных протоколах контактных платежей можно предположить ,  что действительная транзакция между покупателем и продавцом физически происходит на считывающем устройстве продавца  ( предполагаем ,  что считыватель карт заслуживает доверия ).  То есть банковская карта физически присутствовала в считывающем устройстве продавца на основе технологии бесконтактной передачи транзакций на банковском терминале .  С другой стороны ,  протокол бесконтактных мобильных платежей работает в непосредственной близости ,  но физический контакт не требуется .  Это разделение ,  продемонстрированное на примере атаки P B 2. Attack ,  может быть увеличено .  Следовательно ,  в мобильных бесконтактных протоколах мы больше не можем вывести физическое присутствие клиента по транзакции .  Сама транзакция все еще может быть действительной ,  поскольку в простейшей конфигурации требуются только законные отношения между идентифицированным покупателем и продавцом .  Другой интересный случай  –  когда продавец и покупатель являются злоумышленниками и вступают в сговор  ( и ,  таким образом ,  Se взаимодействует с двумя злоумышленниками ).  Например ,  Ph нечестен и игнорирует любые предварительные условия перед тем ,  как связаться с Se ,  после того ,  как он получил сообщение от Sm' ,  расположенного в другом географическом месте .  Se просто проверяет связь между личностью Ph и идентичностью Sm' и записывает ,  что Ph хотел приобрести услугу ,  как определено  ( ID Sm' ).  Se не требует и не 172  может обеспечить ,  основываясь на ограниченной информации ,  что Ph физически находился в Sm' .  При оформлении транзитных билетов с помощью мобильных тегов клиенты входят в систему ,  нажимая на смарт - карты ,  установленные на платформах на станциях .  Платежный сервер Se имеет бизнес - требование для проверки согласованности физического местоположения клиента и сообщаемых доказательств прослушивания с любым конкретным Sm .  В этой ситуации мобильный телефон также может передавать свои аутентифицированные координаты  GPS  для проверки сервера .  Мы можем смоделировать эту проверку согласованности ,  выполняемую на платежном сервере ,  введя дополнительную семантику в предикат close By (GPS coordinates,  Sm ).  Подводя итог ,  можно указать на сложность разработки платежных протоколов .  Протоколы ,  которые являются безопасными в одном варианте использования ,  могут не удовлетворять всем требованиям бизнеса и безопасности для другого .  Однако с точки зрения анализа протокола представленная система моделирования платежного протокола с разграничением прав достаточно гибкая ,  чтобы формализовать различные наборы требований ,  и способна выполнять проверки в полной автоматизации  ( программная реализация ).  173  ЛИТЕРАТУРА 1. Аверченков ,  В . И .  Аудит информационной безопасности  /  В . И .  Аверченков . –  М .:  ФЛИНТА , 2011. – 269  с .  2. Аверченков ,  В . И .  Система обеспечения безопасности Рос - сийской Федерации  /  В . И .  Аверченков ,  В . В .  Ерохин . –  Брянск :  БГТУ ,  2005. – 120  с .  3. Аверченков ,  В . И .  Системы организационного управления  /  В . И .  Аверченков ,  В . В .  Ерохин . –  Брянск :  БГТУ , 2006. – 208  с .  4. Алиев ,  В . С .  Информационные технологии и системы фи - нансового менеджмента  /  В . С .  Алиев . –  М .: « ФОРУМ »:  ИНФРА - М ,  2007.  5. Бауэр ,  Ф .  Расшифрованные секреты .  Методы и принципы криптологии  /  Ф .  Бауэр . –  М .:  Мир , 2007. – 550  с .  6. Бернет ,  С .  Криптография .  Официальное руководство  RSA  Security /  С . Бернет ,  С . Пейн . – 2- е изд .,  стереотипное . –  М .: « Бином - Пресс », 2009. – 384  с .  7. Ван - Тилборг ,  Х . К . А .  Основы криптологии .  Профессиональ - ное руководство и интерактивный учебник  /  Х . К . А .  Ван - Тилборг . –  М .:  Мир , 2006 – 471  с .  8. Василенко ,  О . Н .  Теоретико - числовые алгоритмы в крипто - графии  /  О . Н .  Василенко . – 2- е изд .,  доп . –  М .:  МЦНМО , 2006 – 326  с .  9. Гольдштейн ,  Б . С .  Сети связи  /  Б . С .  Гольдштейн ,  Н . А .  Соколов ,  Г . Г .  Яновский . –  СПб .:  БХВ - Петербург , 2011.  10. Гордеев ,  А . В .  Операционные системы  /  А . В .  Гордеев . –  СПб .:  Питер , 2006. – 416  с .  11. Дейт ,  К . Дж Введение в системы баз данных  /  К . Дж .  Дейт  –  М .:  Издательский дом  « Вильямс », 2006. – 1328  с .  12. Ерохин ,  В . В .  Безопасность информационных систем  /  В . В .  Ерохин ,  Д . А .  Погонышева ,  И . Г .  Степченко . –  М .:  ФЛИНТА , 2015. –  184  с .  13. Ерохин ,  В . В . Верификация информационных систем ком - мерческого банка  /  В . В .  Ерохин ,  Е . В .  Елисеева  //  Вестник образова - тельного консорциума среднерусский университет .  Информационные технологии . – 2017. –  № 1(9). –  С . 20-23.  14. Ерохин ,  В . В .  Защита информации электронных торговых сетей банков  /  В . В .  Ерохин ,  Е . В .  Елисеева и др . //  Вопросы современ - 174  ной науки :  коллект .  науч .  монография ; [ под ред .  Н . Р .  Красовской ]. –  М .:  Изд .  Интернаука , 2017.  Т . 18. –  С . 123-140.  15. Ерохин ,  В . В .  Защита программного обеспечения и верифи - кация информации в информационно - телекоммуникационных систе - мах банка . –  М .:  Изд - во МГУ , 2015. – 129  с .  16. Ерохин ,  В . В .  Управление доступом к информационному и программному обеспечению в коммерческом банке  /  В . В .  Ерохин ,  Е . В .  Елисеева ,  А . М .  Хлопяников  //  Результаты социально - экономических и междисциплинарных научных исследований  XXI  века :  монография . –  Самара :  Поволжская научная корпорация , 2016. –  С . 189-202.  17. Зильбербург ,  Л . И .  Информационные технологии в проекти - ровании и производстве  /  Л . И .  Зильбербург ,  В . И .  Молочник ,  Е . И .  Яб - лочников . –  СПб .:  Политехника , 2008.  18. Игнатьев ,  В . А .  Информационная безопасность современно - го коммерческого предприятия  /  В . А . Игнатьев  –  Старый Оскол :  ООО « ТНТ », 2005. – 448  с .  19. Ключников ,  К . К .  Методы снижения сбоев в работе биллин - говой системы  /  К . К .  Ключников  //  Мобильные системы . – 2007. –  № 08 –  С . 46-48.  20. Кузнецов ,  С . Л .  Современные технологии документационно - го обеспечения управления  /  С . Л .  Кузнецов . –  М .:  МЭИ , 2010. – 232  с .  21. Кэрриэ ,  Б .  Криминалистический анализ файловых систем  /  Б .  Кэрриэ  –  СПб .:  Питер , 2007. – 352  с .  22. Марков ,  А . С .  Методы оценки несоответствия средств защи - ты информации  /  А . С .  Марков ,  В . Л .  Цирлов ,  В . Л .  Баранов . –  М .:  Го - рячая линия - Телеком , 2012. – 192  с .  23. Мельников ,  В . П .  Информационная безопасность  /  В . П .  Мельников ,  С . А .  Клейменов ,  А . М .  Петраков  –  М .:  Издательский центр  « Академия », 2012. – 336  с .  24. Олифер ,  В . Г .  Компьютерные сети  /  В . Г .  Олифер  [ и др .]. –  СПб .:  Питер , 2008. – 958  с .  25. Олифер ,  В . Г .  Сетевые операционные системы  /  В . Г .  Олифер ,  Н . А .  Олифер . –  СПб .:  Питер , 2009. – 672  с .  26. Панасенко ,  С .  Алгоритмы шифрования .  Специальный спра - вочник  /  С . Панасенко . –  СПб .:  БХВ - Петербург , 2009. – 578  с .  27. Платонов ,  В . В .  Программно - аппаратные средства обеспече - ния информационной безопасности вычислительных сетей  /  В . В .  Платонов  –  М .:  Издательский центр  « Академия », 2006. – 240  с .  175  28. Скиба ,  В . Ю .  Руководство по защите от внутренних угроз информационной безопасности  /  В . Ю .  Скиба ,  В . А .  Курбатов  –  СПб .:  Питер , 2008. – 320  с .  29. Созыкин ,  А . В .  Модели и методы создания интегрированной инфраструктуры управления доступом к сервисам  /  А . В .  Созыкин  //  Системы управления и информационные технологии . – 2007. –  № 4.1(30). –  С . 191-195.  30. Тихонов ,  В . А .  Информационная безопасность :  концепту - альные ,  правовые ,  организационные и технические аспекты  /  В . А .  Тихонов ,  В . В .  Рай  –  М .:  Солон - пресс , 2006. – 528  с .  31. Трофимов ,  В . В .  Информационные системы и технологии в экономике и управлении  /  В . В .  Трофимов ,  О . П .  Ильина ,  Е . В .  Трофимова ,  В . И .  Кияев ,  Приходченко А . П . /  под ред .  проф .  В . В . Трофимова . –  М .:  КНОРУС , 2011.  32. Хорев ,  П . Б .  Методы и средства защиты информации в ком - пьютерных системах  /  П . Б .  Хорев . –  М .:  Издательский центр  « Акаде - мия », 2008. – 256  с .  33. Anada, H., Yasuda, T., Kawamoto, J., Weng, J., Sakurai, K.  (2019). RSA public keys with inside  structure: Proofs of  key generation  and identities for web-of-trust.  Journal of Information Security and  Applications, 45 , 10-19. doi:10.1016/j.jisa.2018.12.006.  34. Asokan, N., Nyman, T., Rattanavipanon, N., Sadeghi, A. -., Tsu- dik, G. (2018). ASSURED: Architecture  for secure software update of re- alistic embedded devices.  IEEE Transactions on Computer-Aided Design  of Integrated Circuits and Systems, 37 (11), 2290-2300.  doi:10.1109/TCAD.2018.2858422.  35. Bailey, D. V., Dürmuth, M., Paar, C. (2014).  Statistics on pass- word re-use and adaptive strength for financial accounts.  doi:10.1007/978-3-319-10879-7_13.  36. Bailey, D.V., Brainard, J., Rohde, S., Paar, C. (2009). One-touch  financial transaction authenticat ion. Paper presented at the  ICETE 2009 -  International Joint Conference on e-Business and Telecommunications,  5- 12.  37. Bailey, D.V., Brainard, J., Rohde, S., Paar, C. (2011).  Wireless  authentication and transaction-confirmation token.  doi:10.1007/978-3- 642-20077-9_13.  38. Brasser, F., Capkun, S., Dmitrienko, A., Frassetto, T.,  Kostiainen, K., Sadeghi, A. -. (2019). Dr.SGX: Automated and adjustable  side-channel protection for sgx usin g data location randomization. Paper  176  presented at the  ACM International Conference Proceeding Series,  788- 800. doi:10.1145/3359789.3359809.  39. Brasser, F., Müller, U., Dmitrienko, A., Kostiainen, K., Capkun,  S., Sadeghi, A. -. (2017). Software grand exposure: SGX cache attacks are  practical. Paper presented at the  11th USENIX Workshop on Offensive  Technologies, WOOT 2017, Co-Located with USENIX Security 2017. 40. Bulychev, P. Computing (bi)simulation relations preserving ctlx  logic for ordinary and fair kripke structures / P. Bulychev, I. Konnov, V.  Zakharov //  Труды Института системного программирования РАН . –  2007. – Vol. 12. – Pp. 59-76.  41. Calder, M. Detecting feature interactions: how many compo- nents do we need? / M. Calder, A. Miller // Objects, Agents and Features.  – 2004. – Vol. 2975. – Pp. 45-66.  42. Cheng, L., Liljestrand, H., Ahmed, M.S., Nyman, T., Jaeger, T.,  Asokan, N., Yao, D.D. (2019). Explo itation techniques and defenses for  data-oriented attacks. Paper presented at the  Proceedings - 2019 IEEE Se- cure Development, SecDev 2019,  114-128.  doi:10.1109/SecDev.2019.00022.  43. Danev, B., Heydt-Benjamin, T. S.,  Č apkun, S. (2009). Physical- layer identification of RFID de vices. Paper presented at the  Proceedings of  the 18th USENIX Security Symposium,  199-214.  44. Dhar, A., Puddu, I., Kostiainen, K., Capkun, S. (2020). Proximi- TEE: Hardened SGX attestation by proxi mity verification. Paper presented  at the  CODASPY 2020 - Proceedings of the 10th ACM Conference on Da- ta and Application Security and Privacy,  5-16.  doi:10.1145/3374664.3375726.  45. Ekberg, J. -., Kostiainen, K., Asokan, N. (2014). The untapped  potential of trusted execution environments on mobile devices.  IEEE  Security and Privacy, 12 (4), 29-37. doi:10.1109/MSP.2014.38.  46. Emerson, E.A. Parameterized model checking of ring-based  message passing systems / E.A. Emerso n, V. Kahlon // Computer Science  Logic. – 2004. – Vol. 3210/2004 of LNCS. – Pp. 325-339.  47. EMVC0. The EMV 4.3 Specificati ons - Book 2 - Security and  Key Management [online], 2011. Avai able at: http : //www.emvco.com   specifications.aspx?id = 223.  48. EMVC0. The EMV Contactiess Specifications - Book D: Con- tactless Communication Protocol [online], 2011. Avaiable at: http       www.emvco.com/specifications.aspc?id = 21.  177  49. Erokhin V.V., Fetshchenko V.V., Panina I.S., Kazimirova N.P.,  Novikov S.P., Novikova A.V. Verification of Computer Systems of Com- mercial Bank // International Journa l Of Applied Business and Economic  Research. – 2017. – Volume 15, Number 12. –  Р . 297 – 306.  50. Erokhin V.V., Kulikova G.A., Mudrova N.V., Shadoba E.M.,  Romanov V.A. Podobai N.V. Controlling Access to the Information and  Software in a Commercial Bank // International Journal Of Applied Busi- ness and Economic Research. – 2017. – Volume 15, Number 12. –  Р . 159  – 170.  51. Fan, J., Bailey, D.V., Batina, L., Güneysu, T., Paar, C., Verbau- whede, I. (2010). Breaki ng elliptic curve cryptosystems using reconfigura- ble hardware. Paper presented at the  Proceedings - 2010 International  Conference on Field Programmable Logic and Applications, FPL  2010,  133-138. doi:10.1109/FPL.2010.34.  52. Foltz, K., Simpson, W.R. (2020). Public key infrastructure issues  for enterprise level securi ty. Paper presented at the  ICEIS 2020 - Proceed- ings of the 22nd International Conference on Enterprise Information Sys- tems,  91-98.  53. Hawanna, V., Kulkarni, V. Y., Rane, R. A. (2017). Risk assess- ment of X.509 certificate by evalua ting certification practice statements.  Paper presented at the  International Conference on Computing, Analytics  and Security Trends, CAST 2016,  501-506.  doi:10.1109/CAST.2016.7915020.  54. Heydt-Benjamin, T.S., Bailey, D.V., Fu, K., Juels, A., O'Hare, T.  (2007).  Vulnerabilities in first-generation RFID-enabled credit  cards.  doi:10.1007/978-3-540-77366-5_2.  55. IETF Internet Engineering Task  Force. US Secure Hash Algo- rithm 1 (SHAI) [online], 2012. Available at:  http://tools.ietf.org/html/rfc3174.  56. IETF Internet Engineering Task Force. Using SHA2 algorithms  with cryptographic message syntax [online], 2012. Available at:  http//tools.ietf.org/html/rfc5754.  57. IETF-RFC5246. The Transport Layer Security (TLS) protocol  version 1.2 [online], 2008. Avaiable a t: http : //tools.ietf.org/html/rfc5246.  58. ISO/1EC-14443. Identification ca rds Contactless integrated cir- cuit cards Proximity cards [online] 2008. Avaiable at:  http//www.iso.org/iso/iso-catal ogue/catalogue-ics catalogue-detail- ics.htm?csnumber = 28730.  178  59. ISO/1EC-7813. Information technology Identification cards Fi- nancial transaction cards [ online], 2008. Avaiable at:  http//www.iso.org/iso/iso-catalogue/catalogue-tc/catalogue- detail.htm?csnumber 43317.  60. Karthikeyan, S., Patan, R., Balamurugan, B.  (2019).  Enhancement of security in the internet of things (IoT) by using  X.509 authentication mechanism.  doi:10.1007/978-981-13-2685-1_22.  61. Kelly, D., Hammoudeh, M. (2018). Optimisation of the public  key encryption infrastructure for the internet of things. Paper presented at  the  ACM International Conference Proceeding Se- ries,  doi:10.1145/3231053.3231098.  62. Khan, M.S.N., Marchal, S., Buchegger, S., Asokan, N. (2019).  Chowniot: Enhancing IoT privacy by automated handling of ownership  change . doi:10.1007/978-3-030-16744-8_14.  63. Kostiainen, K., Ekberg, J. -., Asokan, N., Rantala, A. (2009).  On-board credentials with open provisioning. Paper presented at  the  Proceedings of the 4th International Symposium on ACM Symposium  on Information, Computer and Communications Security, ASI- ACCS'09,  104-115. doi:10.1145/1533057.1533074.  64. Malisa, L., Kostiainen, K., Capkun, S. (2017). Detecting mobile  application spoofing attacks by levera ging user visual similarity percep- tion. Paper presented at the  CODASPY 2017 - Proceedings of the 7th ACM  Conference on Data and Application Security and Privacy,  289-300.  doi:10.1145/3029806.3029819.  65. Malisa, L., Kostiainen, K., Knell, T., Sommer, D., Capkun, S.  (2017).  Hacking in the blind: (almost) invisible runtime user interface at- tacks  doi:10.1007/978-3-319-66787-4_23.  66. Mannan, M., Asokan, N. (2020). Confronting the limitations of  hardware-assisted security.  IEEE Security and Privacy, 18 (5), 6-7.  doi:10.1109/MSEC.2020.3015413.  67. Marforio, C., Masti, R. J.,  Soriente, C., Kostiainen, K.,  Č apkun,  S. (2016). Evaluation of personalized  security indicators as an anti- phishing mechanism for smartphone  applications. Paper presented at  the  Conference on Human Factors in Computing Systems - Proceed- ings,  540-551. doi:10.1145/2858036.2858085.  68. Marforio, C., Masti, R.J., Sorien te, C., Kostiainen, K., Capkun,  S. (2016). Hardened setup of personali zed security indicators to counter  phishing attacks in mobile bank ing. Paper presented at the  SPSM 2016 -  Proceedings of the 6th Workshop on  Security and Privacy in Smartphones  179  and Mobile Devices, Co-Located with CCS 2016,  83-92.  doi:10.1145/2994459.2994462.  69. Markert, P., Bailey, D. V., Golla , M., Durmuth, M., Avig, A.J.  (2020). This PIN can be easily guessed: Analyzing the security of  smartphone unlock PINs.  Paper presented at the  Proceedings - IEEE Sym- posium on Security and Privacy, 2020-May  286-303.  doi:10.1109/SP40000.2020.00100.  70. Mumtaz, M., Akram, J., Ping, L. (2019). An RSA based authen- tication system for smart IoT environment. Paper presented at  the  Proceedings - 21st IEEE Internatio nal Conference on High Perfor- mance Computing and Communications, 17th IEEE International Confer- ence on Smart City and 5th IEEE Inte rnational Conference on Data Sci- ence and Systems, HPCC/SmartCity/DSS 2019,  758-765.  doi:10.1109/HPCC/SmartCity/DSS.2019.00112.  71. NFC-Forum. NFC Logical Link Control Protocol (LLCP) tech- nical specification [online]. 2012. Avaiable at: http  www.nfcforum.org/s pecs/spec-list/.  72. Ruan, O., Zhang, Y., Zhang, M., Zhou, J., Harn, L. (2018). Af- ter-the-fact leakage-resilient id entity-based authenticated key  exchange.  IEEE  Systems  Journal, 12 (2), 2017-2026.  doi:10.1109/JSYST.2017.2685524.  73. Shivaprasad, S., Sadanandam, M., Sowjanya, M., Kondapalli, S.  V. (2019). Deliver an accurate image  on the digital certificate and digital  signature using RSA and SHA.  Journal of Advanced Research in  Dynamical and Control Systems, 11 (7), 501-514.  74. Wang, L., Asharov, G., Pass, R., Ristenpart, T., Shelat, A.  (2019). Blind certificate author ities. Paper presented at the  Proceedings -  IEEE Symposium on Security and Privacy, 2019-May  1015-1032.  doi:10.1109/SP.2019.00007.  180  ОГЛАВЛЕНИЕ ВВЕДЕНИЕ  ............................................................................................... 3 1.  АНАЛИЗ АВТОМАТИЗИРОВАННЫХ МЕТОДОВ ПОСТРОЕНИЯ УПРАВЛЕНИЯ ДОСТУПОМ К ИНФОРМАЦИОННОМУ И ПРОГРАММНОМУ ОБЕСПЕЧЕНИЮ БАНКА  ....................................................................... 8 1.1.  Управления доступом к информационному и программному обеспечению в коммерческом банке  ................................................................... 34 1.2.  Анализ методов проверки корректности работы программного обеспечения  ............................................................................................................ 41 2.  АВТОМАТИЗАЦИЯ ПРОЦЕССА УПРАВЛЕНИЯ ДОСТУПОМ К ИНФОРМАЦИОННОМУ И ПРОГРАММНОМУ ОБЕСПЕЧЕНИЮ БАНКА  ..................................................................... 50 2.1.  Автоматизация разграничения доступа к информационному и программному обеспечению банка  ..................................................................... 50 2.2.  Обеспечение надёжности и доступности компьютерных систем банка  ....................................................................................................................... 74 3.  АНАЛИЗ ДОСТОВЕРНОСТИ И ВЕРИФИКАЦИИ ИНФОРМАЦИИ В ИНФОРМАЦИОННО - ТЕЛЕКОММУНИКАЦИОННЫХ СИСТЕМАХ БАНКА  ................... 84 3.1.  Алгоритм анализа достоверности и верификации информации  ............... 84 3.2.  Верификация вычислительных систем банка  ........................................... 101 3.3.  Совершенствования верификации симуляций между моделями программ ............................................................................................................... 107 4.  АВТОМАТИЧЕСКИЙ АНАЛИЗ БЕЗОПАСНОСТИ ПЛАТЕЖНЫХ ПРОТОКОЛОВ  .......................................................... 126 4.1.  Протоколы бесконтактных платежей по банковским картам  ................. 126 4.2.  Протоколы оплаты с использованием мобильных устройств  ................. 141 4.3.  Протоколы оплаты с использованием мобильных токенов  ..................... 155 ЛИТЕРАТУРА  ....................................................................................... 173 Научное издание Ерохин Виктор Викторович , Бахадиров Хикмет Муратович ВЕРИФИКАЦИЯ ИНФОРМАЦИИ И ЗАЩИТА ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ В ИНФОРМАЦИОННО - ТЕЛЕКОММУНИКАЦИОННЫХ СИСТЕМАХ БАНКА Монография Издательство  « Спутник  +»  109428,  Москва ,  Рязанский проспект ,  д . 8 А .  Тел .: (495) 730-47-74, 778-45-60 ( с  9.00  до  18.00)  Подписано в печать  17.05.2021.  Формат  60×90/16.  Бумага офсетная .  Усл .  печ .  л . 11,31.  Тираж  25  экз .  Заказ  161.  Отпечатано в ООО  « Издательство  « Спутник  +» 